/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(8);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),
/* 2 */
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 3 */
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),
/* 5 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),
/* 6 */
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),
/* 7 */
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),
/* 8 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ":root {\n  --siteheaderheight: 3.125rem;\n  --fullsectionheight: calc(100vh - var(--siteheaderheight));\n  --sixnine: 56.25%;\n  --mw: 40rem;\n}\n@media (min-width: 768px) {\n  :root {\n    --siteheaderheight: 5rem;\n  }\n}\n\n* {\n  font-family: inherit;\n  color: inherit;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-optical-sizing: auto;\n  font-stretch: normal;\n  box-sizing: border-box;\n  border: 0;\n  margin: 0;\n  padding: 0;\n}\n*:before, *:after {\n  box-sizing: border-box;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100%;\n  scroll-behavior: smooth;\n}\n\nbody {\n  overflow-x: hidden;\n}\n\nimg,\nsvg {\n  width: 100%;\n  height: auto;\n}\n\nul {\n  list-style: none;\n}\n\na,\nbutton {\n  cursor: pointer;\n}\n\na {\n  color: inherit;\n  text-decoration: none;\n}\n\nbutton {\n  background: transparent;\n}\n\ninput,\ntextarea {\n  width: 100%;\n}\n\ninput[type=submit], input[type=checkbox] {\n  width: auto;\n}\n\n:root {\n  --genfontfam: \"Poppins\", sans-serif;\n  --genfontsize: 1.1rem;\n  --genfontlineheight: 1.3;\n  --headlinefontfam: var(--genfontfam);\n  --headlinelineheight: 1.7;\n  --lightfontweight: 300;\n  --regfontweight: 400;\n  --medfontweight: 500;\n  --semiboldfontweight: 600;\n  --boldfontweight: 700;\n  --extraboldfontweight: 800;\n  --blackfontweight: 900;\n  --h1size: 2.5rem;\n  --h2size: 2rem;\n  --h3size: 1.5rem;\n  --h4size: 0.9rem;\n  --h5size: 0.8rem;\n  --h6size: 0.6rem;\n  --smallsize: 0.6rem;\n}\n\nhtml,\nbody {\n  font-family: var(--genfontfam);\n  font-size: var(--genfontsize);\n  font-weight: var(--regfontweight);\n  line-height: var(--genfontlineheight);\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-rendering: optimizeLegibility;\n}\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-family: var(--headlinefontfam);\n}\n\nh1,\nh2,\nh3,\nh4 {\n  font-weight: var(--boldfontweight);\n  line-height: var(--headlinelineheight);\n}\n\nh5,\nh6 {\n  font-weight: var(--regfontweight);\n}\n\nh1 {\n  font-size: var(--h1size);\n}\n\nh2 {\n  font-size: var(--h2size);\n}\n\nh3 {\n  font-size: var(--h3size);\n}\n\nh4 {\n  font-size: var(--h4size);\n}\n\nh5 {\n  font-size: var(--h5size);\n}\n\nh6 {\n  font-size: var(--h6size);\n}\n\nsmall {\n  font-size: var(--smallsize);\n}\n\nstrong {\n  font-weight: var(--boldfontweight);\n}\n\nlabel {\n  font-size: 0.75rem;\n}\n\ninput,\ntextarea {\n  border: 1px solid;\n  padding: 0.5rem 1rem;\n}\n\ninput,\nbutton {\n  border-radius: 0.5rem;\n}\n\ntextarea {\n  border-radius: 0.5rem 0.5rem 0 0.5rem;\n  min-height: 12ch;\n}\n\nbutton,\ninput[type=submit] {\n  cursor: pointer;\n}\n\n:root {\n  --black: #222222;\n  --white: #FFFFFF;\n  --basefontcolor: var(--black);\n}\n\nbody {\n  color: var(--basefontcolor);\n}\n\n.siteheader,\n.sitefooter {\n  color: var(--white);\n  background-color: var(--black);\n}\n\n[class*=__grid],\n.grid {\n  display: grid;\n}\n\n[class*=__label] {\n  font-size: 0.8rem;\n  font-weight: var(--boldfontweight);\n  line-height: 1;\n}\n\nhtml,\nbody {\n  overflow-x: hidden;\n}\n\n.siteheader,\n.sitefooter {\n  min-height: var(--siteheaderheight);\n  z-index: 123456789;\n}\n\n.sitewrapper {\n  min-height: var(--fullsectionheight);\n  background-color: var(--white);\n}\n\n.fullsection {\n  min-height: var(--fullsectionheight);\n}\n\n.maxwidth {\n  max-width: var(--mw);\n  margin: auto;\n}\n\n.mod__header {\n  border: 1px;\n  border-style: none none solid;\n  padding: 0 0 0.5rem;\n  margin: 0 0 0.5rem;\n}\n.mod__headline {\n  font-size: clamp(1.5rem, 0.0263rem + 8.4211vw, 2rem);\n}\n.mod__headline > span {\n  text-transform: capitalize;\n}\n.mod__headline > span:last-child {\n  text-transform: uppercase;\n}\n.mod__latlong {\n  display: flex;\n  gap: 1rem;\n}\n\n.flexcol {\n  display: flex;\n  flex-direction: column;\n}\n\n.flexcolcenter {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n}\n\n.gap8 {\n  gap: 0.5rem;\n  grid-gap: 0.5rem;\n}\n\n.gap16 {\n  gap: 1rem;\n  grid-gap: 1rem;\n}\n\n.gap32 {\n  gap: 2rem;\n  grid-gap: 2rem;\n}\n\n.apicall {\n  font-family: \"Courier New\", Courier, monospace;\n  font-size: 0.8rem;\n  width: 100%;\n}\n.apicall h4 {\n  margin: 0 0 0.5rem;\n}\n.apicall pre {\n  margin: 0 0 2rem;\n}\n\n.siteheader {\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0;\n}\n.currentconditions {\n  background: linear-gradient(to bottom, #1e5799 0%, #ffffff 100%);\n}\n.currentconditions__grid {\n  grid-gap: 0.5rem;\n  padding: 2rem 1rem 5rem;\n}\n.currentconditions__icon {\n  text-align: center;\n}\n.currentconditions__icon__caption {\n  display: flex;\n  justify-content: center;\n  font-size: 0.8rem;\n  font-weight: var(--boldfontweight);\n  text-transform: uppercase;\n}\n.currentconditions__icon > img {\n  width: 100%;\n  max-width: 240px;\n}\n.currentconditions__ind {\n  font-size: 0.8rem;\n}\n.currentconditions__temp__far {\n  font-size: 3rem;\n}\n.currentconditions__section__wind, .currentconditions__section__snow {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 0.5rem;\n}\n.currentconditions__section__wind__label, .currentconditions__section__snow__label {\n  grid-column: span 2;\n}\n.currentconditions__footer {\n  width: 100%;\n  overflow-x: auto;\n  padding: 1rem 0;\n}\n@media (min-width: 667px) {\n  .currentconditions__body {\n    grid-template-columns: 1fr 2fr;\n    grid-template-rows: auto auto;\n  }\n  .currentconditions__icon {\n    grid-row: span 2;\n  }\n}\n\n.forecast__wrapper {\n  padding: 2rem 1rem;\n}\n.forecast h3 {\n  margin: 1rem 0;\n}\n\n.staticmap__grid {\n  text-align: center;\n  grid-gap: 1rem;\n  margin: 0 0 2rem;\n}\n\n.interactivemap__wrapper {\n  padding: 2rem 1rem;\n}\n.interactivemap__grid {\n  margin: 0 0 2rem;\n}", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),
/* 9 */
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),
/* 10 */
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _aerisweather_javascript_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);

window.addEventListener('load', () => {

    let modwrapper = document.querySelector('[mod]');
    const aeris = new _aerisweather_javascript_sdk__WEBPACK_IMPORTED_MODULE_0__["default"]('ZsXEQGZcQQ297GNvUPbEw', 'qg4V7TY719k33od8qlRPwVFGKgKwawJVZmZPFHDI');

    aeris.api().endpoint('observations').place('minneapolis,mn').get().then((result) => {
        const place = result.data;
        const data = result.data.ob;
        //console.log(data);
        const modheader = (
            `<header class="currentconditions__header mod__header flexcol gap8">
                <span class="currentconditions__label">Current Conditions For:</span>
                <h2 class="currentconditions__headline mod__headline"><span>${place.place.name}</span>, <span>${place.place.state}</span></h2>
                <div class="currentconditions__latlong mod__latlong">
                    <small class="currentconditions__latlong__lat mod__latlong__lat">lat: ${place.loc.lat}</small>
                    <small class="currentconditions__latlong__long  mod__latlong__long">long: ${place.loc.long}</small>
                </div>
            </header>`
        )
        modwrapper.insertAdjacentHTML('afterbegin', modheader);

        const modbody = (
            `<section class="currentconditions__body grid gap32" key=${data.weather}>
                <figure class="currentconditions__icon flexcolcenter gap8">
                    <span class="currentconditions__icon__caption"><span>${data.weather}</span></span>
                    <img src="images/icons/${data.icon}" width="55" height="55" alt="" />
                </figure>
                <div class="currentconditions__section currentconditions__section__temp flexcol gap8">
                    <h3 class="currentconditions__temp__far"><span>${Math.round(data.tempF)}&deg;</span></h3>
                    <h4 class="currentconditions__temp__feelslike"><span>Feels Like: ${Math.round(data.feelslikeF)}&deg;</span></h4>
                    
                </div>
                <div class="currentconditions__section currentconditions__section__wind">
                    <span class="currentconditions__ind"><strong>Humidity:</strong> ${Math.round(data.humidity)}%</span>
                    <span class="currentconditions__ind"><strong>Wind:</strong> ${Math.round(data.windSpeedMPH)}MPH ${data.windDir}</span>
                </div>
            </section>`
        )
        modwrapper.insertAdjacentHTML('beforeend', modbody);

        const modfooter = (
            `<footer class="currentconditions__footer">
                <div class="apicall">
                    <div class="apicall__wrapper">
                    <h4>Obtain the Conditions for Minneapolis, MN</h4>
<pre>
import AerisWeather from '@aerisweather/javascript-sdk';

window.addEventListener('load', () => {
    const aeris = new AerisWeather('KIP_ID', 'KIP_SECRET');
    const request = aeris.api();
    request.endpoint('observations');
    request.place('minneapolis,mn');
    request.get().then((result) => {
        const data = result.data.ob;
        console.log(data);
    });
});
</pre>
<h4>Obtain the latest Conditions for Minneapolis, but only return the temperature in Fahrenheit.</h4>
<pre>
import AerisWeather from '@aerisweather/javascript-sdk';

window.addEventListener('load', () => {
    const aeris = new AerisWeather('KIP_ID', 'KIP_SECRET');
    const request = aeris.api();
    request.endpoint('observations');
    request.place('minneapolis,mn');
    request.fields('ob.tempF');
    request.get().then((result) => {
        const data = result.data;
        console.log(data);
    });
});
</pre>
                    </div>
                </div>
            </footer>`
        )
        modwrapper.insertAdjacentHTML('beforeend', modfooter);
    });

})

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AerisWeather", ({
  enumerable: true,
  get: function () {
    return _AerisWeather.default;
  }
}));
Object.defineProperty(exports, "Account", ({
  enumerable: true,
  get: function () {
    return _Account.default;
  }
}));
Object.defineProperty(exports, "ApiRequest", ({
  enumerable: true,
  get: function () {
    return _ApiRequest.default;
  }
}));
Object.defineProperty(exports, "MapRequest", ({
  enumerable: true,
  get: function () {
    return _MapRequest.default;
  }
}));
Object.defineProperty(exports, "InteractiveMap", ({
  enumerable: true,
  get: function () {
    return _InteractiveMap.default;
  }
}));
Object.defineProperty(exports, "InteractiveMapApp", ({
  enumerable: true,
  get: function () {
    return _InteractiveMapApp.default;
  }
}));
exports["default"] = void 0;

var _AerisWeather = _interopRequireDefault(__webpack_require__(13));

var _Account = _interopRequireDefault(__webpack_require__(14));

var _ApiRequest = _interopRequireDefault(__webpack_require__(100));

var _MapRequest = _interopRequireDefault(__webpack_require__(135));

var _InteractiveMap = _interopRequireDefault(__webpack_require__(220));

var _InteractiveMapApp = _interopRequireDefault(__webpack_require__(329));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = _AerisWeather.default;
exports["default"] = _default;

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.modulesLoader = modulesLoader;
exports["default"] = void 0;

var _Account = _interopRequireDefault(__webpack_require__(14));

var utils = _interopRequireWildcard(__webpack_require__(17));

var strings = _interopRequireWildcard(__webpack_require__(133));

var colors = _interopRequireWildcard(__webpack_require__(139));

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _globals = __webpack_require__(134);

var _mapsgl = __webpack_require__(162);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const isValidKey = key => utils.isEmpty(key) === false && utils.isString(key) && /_/.test(key) === false;

function modulesLoader(callback) {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(163)));
    return new Promise((resolve, reject) => {
      const m = module.Modules;
      resolve(m);
      if (callback) callback(m);
    }).catch(error => {
      console.error('AerisWeather.Modules - ERROR', error);
    });
  });
}

;
/**
 * The main entry point for interacting with AerisWeather API services.
 */

class AerisWeather {
  /**
   * Initializes an AerisWeather instance configured with the specified client id and secret.
   * @param id
   * @param secret
   * @param server
   */
  constructor(id, secret, servers) {
    if (!isValidKey(id) || !isValidKey(secret)) {
      const error = new Error('AerisWeather must be initialized with valid access keys. Refer to https://www.aerisweather.com/support/docs/api/getting-started/ for more information.');
      console.error(error.message);
      throw error;
    }

    this._account = new _Account.default(id, secret);
    this._servers = servers || _globals.servers;
    this._account.servers = this._servers;
  }
  /**
   * Provides access to the library's utility functions.
   *
   * General utility functions are accessible at the root of the `utils` object, but additional
   * functions are available for specific data types, such as colors, strings, etc:
   *
   * - `utils.strings`: String-related utility functions
   * - `utils.colors`: Color-related utility functions
   * - `utils.dates`: Date-related utility functions
   *
   * @readonly
   * @type {({ [key: string]: Function | { [key: string]: Function }})}
   * @memberof AerisWeather
   */


  get utils() {
    return Object.assign(Object.assign({
      $: _DOM.default
    }, utils), {
      strings: Object.assign({}, strings),
      colors: Object.assign({}, colors),
      dates: {
        format: utils.formatDate,
        parse: utils.parseDate
      }
    });
  }
  /**
   * Returns the Account instance used when performing API requests.
   */


  account() {
    return this._account;
  }
  /**
   * Returns the API server used when performing API requests.
   */


  servers() {
    return this._servers;
  }
  /**
   * Creates and returns a new ApiRequest configured for the current account.
   *
   * @returns {ApiRequest}
   * @memberof AerisWeather
   */


  api(config) {
    return this.account().api(config);
  }
  /**
   * Creates and returns a new MapRequest configured for the current account.
   *
   * @returns {MapRequest}
   * @memberof AerisWeather
   */


  map(config) {
    return this.account().map(config);
  }
  /**
   * Provides access to the views module of the library.
   *
   * The `views` module is loaded asynchronously using this method, which means you'll need to
   * wait for it to be loaded before working with any of its features. You can use the `Promise`
   * that's returned, or provide a callback function as a parameter to be notified once the
   * module is available.
   *
   * @param {(views: any) => void} [callback]
   * @returns {Promise<any>}
   * @memberof AerisWeather
   */


  views(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(219)));
      return new Promise((resolve, reject) => {
        const m = module.Views;
        m.setAccount(this.account());
        m.setServers(this.servers());
        resolve(module.Views);
        if (callback) callback(module.Views);
      }).catch(error => {
        console.error('AerisWeather.Views - ERROR', error);
      });
    });
  }
  /**
   * Provides access to the apps module of the library.
   *
   * The `apps` module is loaded asynchronously using this method, which means you'll need to
   * wait for it to be loaded before working with any of its features. You can use the `Promise`
   * that's returned, or provide a callback function as a parameter to be notified once the
   * module is available.
   *
   * @param {(apps: any) => void} [callback]
   * @returns {Promise<any>}
   * @memberof AerisWeather
   */


  apps(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(328)));
      return new Promise((resolve, reject) => {
        const m = module.Apps;
        m.setAccount(this.account());
        m.setServers(this.servers());
        resolve(module.Apps);
        if (callback) callback(module.Apps);
      }).catch(error => {
        console.error('AerisWeather.Apps - ERROR', error);
      });
    });
  }
  /**
   * Provides access to the external modules library.
   *
   * The `modules` library is loaded asynchronously using this method, which means you'll need to
   * wait for it to be loaded before working with any of its features. You can use the `Promise`
   * that's returned, or provide a callback function as a parameter to be notified once the
   * library is available.
   *
   * @param {(modules: any) => void} [callback]
   * @returns {Promise<any>}
   * @memberof AerisWeather
   */


  modules(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      return modulesLoader(callback);
    });
  }

  mapsgl(app, options = {}) {
    return new Promise((resolve, reject) => {
      const {
        version = 'latest'
      } = options,
            opts = __rest(options, ["version"]);

      Promise.all([utils.loadStyles(`https://cdn.aerisapi.com/sdk/js/mapsgl/${version}/aerisweather.mapsgl.css`), utils.loadScript(`https://cdn.aerisapi.com/sdk/js/mapsgl/${version}/aerisweather.mapsgl.js`)]).then(() => {
        var _a;

        const mapsgl = (_a = window.aerisweather) === null || _a === void 0 ? void 0 : _a.mapsgl;

        if (mapsgl) {
          (0, _mapsgl.setupMapsGL)(mapsgl, app, opts, controller => {
            resolve({
              controller,
              mapsgl
            });
          });
        } else {
          reject(new Error('Failed to load MapsGL library'));
        }
      }).catch(error => {
        console.error(`Failed to load MapsGL library for version '${version}'`, error);
      });
    });
  }

}

var _default = AerisWeather;
exports["default"] = _default;

/***/ }),
/* 14 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Permissions = _interopRequireDefault(__webpack_require__(15));

var _ApiRequest = _interopRequireDefault(__webpack_require__(100));

var _MapRequest = _interopRequireDefault(__webpack_require__(135));

var _globals = __webpack_require__(134);

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Account {
  constructor(id, secret) {
    this.id = id;
    this.secret = secret;
    this.servers = _globals.servers;
    this._permissions = new _Permissions.default(id, secret);
  }

  credentials() {
    return {
      id: this.id,
      secret: this.secret
    };
  }

  permissions() {
    return this._permissions;
  }

  canAccess(endpoint) {
    return this.permissions().canAccess(endpoint);
  }
  /**
   * Creates and returns a new ApiRequest configured for the account.
   *
   * @returns {ApiRequest}
   * @memberof Account
   */


  api(config) {
    return new _ApiRequest.default((0, _utils.extend)({
      server: this.servers.api,
      client: {
        id: this.id,
        secret: this.secret
      }
    }, config));
  }
  /**
   * Creates and returns a new MapRequest configured for the account.
   *
   * @returns {MapRequest}
   * @memberof Account
   */


  map(config) {
    return new _MapRequest.default((0, _utils.extend)({
      server: this.servers.maps,
      client: {
        id: this.id,
        secret: this.secret
      }
    }, config));
  }

}

var _default = Account;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 15 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _ApiRequest = _interopRequireDefault(__webpack_require__(100));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `Permissions` object is responsible for requesting and storing access permissions information
 * associated with an Aeris API account.
 */
class Permissions extends _EventDispatcher.default {
  /**
   * Initializes a permissions object for an account associated with the specified client id
   * and secret.
   *
   * @param id
   * @param secret
   */
  constructor(id, secret) {
    super();
    this.loading = false;
    this.id = id;
    this.secret = secret;
    this.get();
  }
  /**
   * Returns a Promise containing the permissions data, fetching the data from the API initially
   * if required.
   */


  get() {
    return new Promise((resolve, reject) => {
      // always return a copy of our data object in case callers change the data contained within
      if (this.hasLoaded()) {
        resolve((0, _utils.cloneDeep)(this.permissions));
      } else if (this.loading) {
        this.on('load:done', () => {
          resolve((0, _utils.cloneDeep)(this.permissions));
        });
      } else {
        this.loading = true;
        this.trigger('load:start');
        const request = new _ApiRequest.default({
          client: {
            id: this.id,
            secret: this.secret
          }
        });
        request.endpoint('oauth2/permissions').get().then(result => {
          this.loading = false;

          if (result.data) {
            this.permissions = result.data;
            this.cached = new Date();
          }

          resolve((0, _utils.cloneDeep)(this.permissions));
          this.trigger('load:done');
        });
      }
    });
  }
  /**
   * A Boolean value indicating if permissions data is currently being requested from the API.
   */


  isLoading() {
    return this.loading;
  }
  /**
   * A Boolean value indicating if permissions have been loaded.
   */


  hasLoaded() {
    return this.permissions != null;
  }
  /**
   * Returns whether the account has access to the specified endpoint or destination.
   * @param endpoint
   */


  canAccess(endpoint) {
    const result = (0, _utils.get)(this.permissions, endpoint);

    if (result) {
      return result.allow;
    }

    return false;
  }

}

var _default = Permissions;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 16 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _Event = _interopRequireDefault(__webpack_require__(99));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The EventDispatcher class is the base class for all classes that dispatch events.
 *
 * @export
 * @class EventDispatcher
 */
class EventDispatcher {
  constructor() {
    /**
     * @ignore
     * @type {*}
     * @memberof EventDispatcher
     */
    this.parentEvent = null;
    /**
     * @ignore	 *
     * @protected
     * @type {*}
     * @memberof EventDispatcher
     */

    this._listeners = {};
  }
  /**
   * Registers a listener function to be executed each time an event occurs
   *
   * @param {string} type Name of the event to listen for. Value can contain multiple event names
   * separated by spaces to trigger the same handler function for each event name.
   * @param {Function} callback Handler function to be called when the event occurs
   * @param {*} [scope=null]
   * @param {number} [priority=0]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  on(type, callback, scope = null, priority = 0) {
    scope = scope || this;

    if (/\s+/.test(type)) {
      const events = type.split(' ');
      events.forEach(event => {
        this.on(event, callback, scope, priority);
      });
      return this;
    }

    let list = this._listeners[type];

    if (list == null) {
      list = [];
      this._listeners[type] = list;
    }

    let index = 0;
    let listener;
    let i = list.length - 1;

    while (i > -1) {
      listener = list[i];

      if (listener.callback === callback && listener.scope === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.priority < priority) {
        index = i + 1;
      }

      i -= 1;
    } // insert the event listener to the list array at the index value


    list.splice(index, 0, {
      callback,
      scope,
      priority,
      once: false
    });
    return this;
  }
  /**
   * Registers a listener function to be executed the first time an event occurs.
   *
   * @param {string} type Name of the event to listen for. Value can contain multiple event names
   * separated by spaces to trigger the same handler function for each event name.
   * @param {Function} callback Handler function to be called when the event occurs
   * @param {*} [scope=null]
   * @param {number} [priority=0]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  once(type, callback, scope = null, priority = 0) {
    scope = scope || this;

    if (/\s+/.test(type)) {
      const events = type.split(' ');
      events.forEach(event => {
        this.once(event, callback, scope, priority);
      });
      return this;
    }

    this.on(type, callback, scope, priority); // get the listeners just added

    const list = this._listeners[type];
    const listener = list[0]; // change the value to true so it will be removed after `trigger` is called

    listener.once = true;
    return this;
  }
  /**
   * Removes a registered listener function for the specified event.
   *
   * @param {string} type Name of the event to remove the listener for.
   * @param {Function} callback Handler function to remove so it won't be executed next time the
   * event is triggered.
   * @param {*} [scope=null]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  off(type, callback, scope = null) {
    scope = scope || this;

    if (/\s+/.test(type)) {
      const events = type.split(' ');
      events.forEach(event => {
        this.off(event, callback, scope);
      });
      return this;
    }

    const list = this._listeners[type];

    if (undefined !== list) {
      let i = list.length - 1;

      while (i > -1) {
        // if the callback and scope are the same then remove the event listener
        if (list[i].callback === callback && list[i].scope === scope) {
          list.splice(i, 1);
          break;
        }

        i -= 1;
      }
    }

    return this;
  }

  offAll() {
    this._listeners = {};
    return this;
  }
  /**
   * Triggers the specified event so that all registered listeners will be executed with the
   * specified parameters.
   *
   * @param {*} type Event name to trigger
   * @param {*} [data=null] Object containing data to pass to all listener functions.
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  trigger(type, data = null) {
    let event = type;

    if (typeof event === 'string') {
      event = new _Event.default(type, false, true, data);
    } else if (event instanceof _Event.default) {
      type = event.type;

      if ((0, _utils.isset)(data)) {
        event.data = data;
      }
    }

    if (event instanceof _Event.default && event.target == null) {
      event.target = this;
      event.currentTarget = this;
    }

    const list = this._listeners[type];

    if (undefined !== list) {
      const cachedList = list.slice();
      let i = cachedList.length - 1;
      let listener;

      while (i > -1) {
        // if cancellable and isImmediatePropagationStopped are true then break out of the
        // while loop
        if (event.cancellable === true && event.isImmediatePropagationStopped === true) {
          break;
        }

        listener = cachedList[i];
        listener.callback.call(listener.scope, event); // if the `once` value is true we want to remove the listener right after this
        // callback was called

        if (listener.once === true) {
          this.off(event.type, listener.callback, listener.scope);
        }

        i -= 1;
      }
    }

    if (this.parentEvent != null && event.bubbles === true) {
      if (event.cancellable === true && event.isImmediatePropagationStopped === true) {
        return this;
      } // assign the current object that is currently processing the event (e.g. event
      // bubbling at)


      event.currentTarget = this; // pass the event to the parentEvent (event bubbling)

      this.parentEvent.trigger(event);
    }

    return this;
  }
  /**
   * Returns whether the listeners are registered for the specified event name.
   *
   * @param {string} type
   * @returns {boolean}
   * @memberof EventDispatcher
   */


  has(type) {
    return this._listeners[type] !== undefined;
  }

}

var _default = EventDispatcher;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.extend = extend;
exports.loadStyles = exports.loadScript = exports.debounce = exports.isPromise = exports.dateFromISO = exports.adjustDate = exports.parseDate = exports.formatDate = exports.toTimeOffsetHours = exports.toTimeStr = exports.toQueryStr = exports.toRangeStr = exports.toBool = exports.interval = exports.flatten = exports.cloneDeep = exports.pickBy = exports.pick = exports.hasKeys = exports.has = exports.set = exports.get = exports.mergeUnique = exports.unique = exports.merge = exports.replace = exports.toUTC = exports.offsetToTime = exports.isZipcode = exports.isValidCoord = exports.isCoord = exports.isDOM = exports.isHTMLElement = exports.isPlainObject = exports.isObject = exports.isEmpty = exports.isDate = exports.isNumeric = exports.isNumber = exports.isString = exports.isBoolean = exports.isFunction = exports.isArray = exports.isset = exports.isUndefined = exports.isNull = exports.toTypeName = exports.toType = void 0;

var _format = _interopRequireDefault(__webpack_require__(18));

var _parse = _interopRequireDefault(__webpack_require__(53));

var _formatDistanceStrict = _interopRequireDefault(__webpack_require__(96));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const toString = {}.toString;

const toType = a => toString.call(a).match(/([a-z]+)(:?\])/i)[1];

exports.toType = toType;

const toTypeName = o => {
  const objectToString = Object.prototype.toString.call(o).slice(8, -1);

  if (objectToString === 'Function') {
    const instanceToString = o.toString();

    if (instanceToString.indexOf(' => ') !== -1) {
      return 'ArrowFunction';
    }

    const getFunctionName = /^function ([^(]+)\(/;
    const match = instanceToString.match(getFunctionName);

    if (match === null) {
      return 'AnonymousFunction';
    }

    return 'Function';
  }

  return objectToString;
};

exports.toTypeName = toTypeName;

const isNull = obj => obj === null;

exports.isNull = isNull;

const isUndefined = obj => undefined === obj;

exports.isUndefined = isUndefined;

const isset = obj => !isUndefined(obj) && !isNull(obj);

exports.isset = isset;

const isArray = value => toString.call(value) === '[object Array]';

exports.isArray = isArray;

const isFunction = value => typeof value === 'function';

exports.isFunction = isFunction;

const isBoolean = value => value === true || value === false || toString.call(value) === '[object Boolean]';

exports.isBoolean = isBoolean;

const isString = obj => toString.call(obj) === '[object String]';

exports.isString = isString;

const isNumber = obj => typeof obj === 'number' && !Number.isNaN(obj);

exports.isNumber = isNumber;

const isNumeric = obj => !isString(obj) && isNumber(obj) || isString(obj) && !isNull(obj.match(/^[\-\+]?\d*\.?\d*$/)) && !isNull(obj.match(/\d/));

exports.isNumeric = isNumeric;

const isDate = obj => isset(obj) && obj.constructor.toString().indexOf('Date') > -1 && typeof obj.getTime !== 'undefined' && !Number.isNaN(obj.getTime());

exports.isDate = isDate;

const isEmpty = obj => {
  if (!isset(obj)) return true;
  if (obj == null) return true;
  if (isNumber(obj)) return false;
  if (isArray(obj) || isString(obj)) return obj.length === 0;
  return Object.keys(obj).length === 0;
};

exports.isEmpty = isEmpty;

const isObject = value => value !== null && typeof value === 'object';

exports.isObject = isObject;

const isPlainObject = value => isObject(value) && value.constructor.name === 'Object' && !isArray(value) && !isFunction(value) && toString.call(value) === '[object Object]';

exports.isPlainObject = isPlainObject;

const isHTMLElement = value => value instanceof HTMLElement === true;

exports.isHTMLElement = isHTMLElement;

const isDOM = value => isObject(value) && (value.constructor.name === 'DOMtastic' || isset(value[0]));

exports.isDOM = isDOM;

const isMergebleObject = value => isPlainObject(value) && !Array.isArray(value);

const isCoord = str => /^(-?[\d\.]+),\s*(-?[\d\.]+)$/.test(str);

exports.isCoord = isCoord;

const isValidCoord = value => {
  const {
    lat,
    lon
  } = value || {
    lat: null,
    lon: null
  };
  return isset(lat) && isset(lon) && Number.isNaN(lat) === false && Number.isNaN(lon) === false;
};

exports.isValidCoord = isValidCoord;

const isZipcode = str => /^(\d\d\d\d\d(?:-\d\d\d\d)?|[ABCEGHJKLMNPRSTVXY]\d[A-Z] ?\d[A-Z]\d)$/.test(str);

exports.isZipcode = isZipcode;

const offsetToTime = str => {
  let offset = 0;
  const matches = (str || '').match(/^([\d\.-]+)(\w*)$/);

  if (matches && matches.length >= 3) {
    const [match, value, type] = matches;
    offset = parseFloat(value);

    if (/^days?/.test(type)) {
      offset *= 86400;
    } else if (/^hours?/.test(type)) {
      offset *= 3600;
    } else if (/^minutes?/.test(type)) {
      offset *= 60;
    }
  }

  return new Date().getTime() + offset * 1000;
};

exports.offsetToTime = offsetToTime;

const toUTC = date => {
  const utc = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  return new Date(utc);
};

exports.toUTC = toUTC;

const replace = (target, value, replacement) => {
  if (target.indexOf(value) !== -1) {
    target[target.map((e, i) => [i, e]).filter(e => e[1] === value)[0][0]] = replacement;
  }
};

exports.replace = replace;

const merge = (target, ...sources) => {
  if (!sources.length) {
    return target;
  }

  const source = sources.shift();

  if (source === undefined) {
    return target;
  }

  if (isMergebleObject(target) && isMergebleObject(source)) {
    const targetObj = target;
    const sourceObj = source;
    Object.keys(source).forEach(key => {
      if (isMergebleObject(sourceObj[key])) {
        if (!targetObj[key]) {
          targetObj[key] = {};
        }

        merge(targetObj[key], sourceObj[key]);
      } else if (isset(sourceObj[key])) {
        targetObj[key] = sourceObj[key];
      }
    });
  } else if (isObject(target) && isObject(source)) {
    for (const name in source) {
      // eslint-disable-line no-restricted-syntax
      if (target.hasOwnProperty(name) && isset(source[name])) {
        // eslint-disable-line no-prototype-builtins
        target[name] = source[name];
      }
    }
  }

  return merge(target, ...sources);
};

exports.merge = merge;

const unique = ar => {
  const a = ar.concat();

  for (let i = 0; i < a.length; i += 1) {
    for (let j = i + 1; j < a.length; j += 1) {
      if (a[i] === a[j]) {
        a.splice(j--, 1); // eslint-disable-line no-plusplus
      }
    }
  }

  return a;
};

exports.unique = unique;

const mergeUnique = (arr1, arr2) => arr1.concat(arr2.filter(item => arr1.indexOf(item) === -1));
/**
 * Access a deep value inside a object.
 * Works by passing a path like "foo.bar", also works with nested arrays like "foo[0][1].baz"
 * @author Victor B. https://gist.github.com/victornpb/4c7882c1b9d36292308e
 * Unit tests: http://jsfiddle.net/Victornpb/0u1qygrh/
 */


exports.mergeUnique = mergeUnique;

const get = (obj, path, fallbackValue = undefined) => {
  if (typeof obj === 'undefined' || obj === null || !isset(path) || !isString(path)) return fallbackValue;
  const props = path.split(/[\.\[\]\"\']{1,2}/);
  const len = props.length;

  for (let i = 0; i < len; i += 1) {
    if (!isEmpty(props[i])) {
      obj = obj[props[i]];
      if (typeof obj === 'undefined' || obj === null) return fallbackValue;
    }
  }

  return obj || fallbackValue;
};
/**
 * Set a deep property on nested objects.
 * @param  {object}   obj  A object
 * @param  {String}   path A path
 * @param  {Any}      val  Anything that can be set
 * @author Victor B. https://gist.github.com/victornpb/4c7882c1b9d36292308e
 */


exports.get = get;

const set = (obj, path, val) => {
  if (!isset(path)) return obj;
  const props = path.split('.');
  const len = props.length - 1;
  let i;

  for (i = 0; i < len; i += 1) {
    obj[props[i]] = obj[props[i]] || {};
    obj = obj[props[i]];
  }

  obj[props[i]] = val;
  return obj;
};

exports.set = set;

const has = (obj, path) => {
  if (!isset(path)) return false;
  const props = path.split(/[\.\[\]\"\']{1,2}/).filter(val => val !== '');
  return !!props.reduce((el, prop) => el && el[prop] ? el[prop] : undefined, obj);
};

exports.has = has;

const hasKeys = (obj, keys) => {
  if (!isArray(keys) || !isset(obj) || !isPlainObject(obj)) return false;
  let _has = true;
  keys.forEach(k => {
    if (obj.hasOwnProperty(k) === false) {
      // eslint-disable-line no-prototype-builtins
      _has = false;
    }
  });
  return _has;
};
/**
 * @ignore
 */


exports.hasKeys = hasKeys;

const _pick = (obj, paths, predicate) => {
  if (!paths || paths.length === 0) {
    return null;
  }

  const len = paths.length;
  const result = {};
  let index = 0;

  while (index < len) {
    const path = paths[index];
    const val = get(obj, path);

    if (predicate(val, path)) {
      set(result, path, val);
    }

    index += 1;
  }

  return result;
};

const pick = (obj, paths) => {
  return obj == null ? {} : _pick(obj, paths, (val, path) => has(obj, path));
};

exports.pick = pick;

const pickBy = (obj, predicate) => {
  if (obj == null) return {};
  const props = Object.keys(obj);
  return _pick(obj, props, (val, path) => predicate(val, path[0]));
};

exports.pickBy = pickBy;

const cloneDeep = obj => {
  if (isArray(obj)) {
    const ar = obj;

    if (ar.length > 0) {
      return ar.map(el => {
        if (isPlainObject(el)) {
          return cloneDeep(el);
        }

        return el;
      });
    }

    return ar.slice(0);
  }

  return merge({}, obj);
};

exports.cloneDeep = cloneDeep;

const flatten = (arr, result = []) => {
  for (let i = 0, length = arr.length; i < length; i += 1) {
    const value = arr[i];

    if (Array.isArray(value)) {
      flatten(value, result);
    } else {
      result.push(value);
    }
  }

  return result;
};

exports.flatten = flatten;

const interval = (value, int) => {
  if (value % int === 0) {
    return value;
  }

  return Math.round((value + int / 2) / int) * int;
};

exports.interval = interval;

const toBool = value => {
  if (isBoolean(value)) return value;
  if (isString(value)) return value === 'true' || value === '1';
  if (isNumber(value)) return value === 1;
  return false;
};

exports.toBool = toBool;

const toRangeStr = (min, max, valueInterval) => {
  const nearestInterval = (value, int) => Math.floor((value + int / 2) / int) * int;

  const minInterval = nearestInterval(min, valueInterval);
  const maxInterval = nearestInterval(max, valueInterval);

  if (minInterval === maxInterval) {
    return `${minInterval}`;
  }

  return `${minInterval}-${maxInterval}`;
};

exports.toRangeStr = toRangeStr;

const toQueryStr = obj => Object.keys(obj).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(obj[k])}`).join('&');

exports.toQueryStr = toQueryStr;

const toTimeStr = (date, from) => {
  const relativeTo = from || new Date();

  if (Math.abs(date.getTime() - relativeTo.getTime()) < 60 * 1000) {
    return '';
  }

  const now = new Date();
  const month = 86400 * 30 * 1000;
  const delta = Math.abs(now.getTime() - date.getTime());

  if (delta > month) {
    return (0, _format.default)(date, 'M/d/yyyy');
  }

  const str = (0, _formatDistanceStrict.default)(relativeTo, date).replace(/\s+/, '');

  if (date.getTime() < relativeTo.getTime()) {
    return `-${str}`;
  }

  return str;
};

exports.toTimeStr = toTimeStr;

const toTimeOffsetHours = str => {
  str = str.replace(/\s/g, '');
  const factors = {
    second: 1 / 3600,
    minute: 1 / 60,
    hour: 1,
    day: 24,
    week: 168,
    month: 720,
    year: 8760
  };
  let offset = 0;
  const m = str.match(/[\d\.-]+\w+/g);

  if (m && m.length > 0) {
    m.forEach(result => {
      const parts = result.match(/^([\d\.-]+)(\w+)$/);

      if (parts && parts.length >= 3) {
        const val = parseFloat(parts[1]);
        const period = (parts[2] || '').replace(/s$/, '');
        const multiplier = factors[period] || 0;
        offset += val * multiplier;
      }
    });
  }

  return offset;
};
/**
 * Formats a date to a string using `date-fns`.
 */


exports.toTimeOffsetHours = toTimeOffsetHours;

const formatDate = (date, formatStr) => {
  if (!isset(formatStr) || isEmpty(formatStr)) {
    console.warn(`[Aeris] Cannot format date with invalid format string "${formatStr}". Refer to the supported format options at https://date-fns.org/docs/format`);
    return null;
  }

  return (0, _format.default)(date, formatStr);
};
/**
 * Converts a string to a Date using `date-fns`.
 */


exports.formatDate = formatDate;
const parseDate = _parse.default;
exports.parseDate = parseDate;

const adjustDate = (date, tzoffset = null) => {
  const utcOffset = new Date().getTimezoneOffset() * 60000;
  const tzShift = tzoffset ? utcOffset + tzoffset : 0; // need to add timezone offset difference between the local and alert timezones

  return new Date(date.getTime() + tzShift);
};

exports.adjustDate = adjustDate;

const dateFromISO = isoDate => {
  isoDate = isoDate || '';
  const parts = isoDate.split(/[\D\-\+]+/).map(v => parseInt(v, 10));
  const tz = isoDate.replace(/^.+\d\d(\-?\d\d\:\d\d)Z?$/, '$1');
  const utcOffset = new Date().getTimezoneOffset() / 60 * -1; // const result = new Date();
  // result.setUTCFullYear(parts[0]);
  // result.setUTCMonth(parts[1] - 1);
  // result.setUTCDate(parts[2]);
  // result.setUTCHours(parts[3]);
  // result.setUTCMinutes(parts[4]);
  // result.setUTCSeconds(parts[5]);
  // result.setUTCMilliseconds(parts[6]);

  const result = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]);
  let tzHourOffset = 0;

  if (!isEmpty(tz)) {
    const tzParts = tz.split(':');

    if (tzParts.length === 2) {
      const [h, m] = tzParts.map(v => parseInt(v, 10));
      tzHourOffset += h;
      tzHourOffset += m / 60;
    }
  } // result.setHours(result.getUTCHours() + tzHourOffset);


  return result;
};

exports.dateFromISO = dateFromISO;

const isPromise = value => isset(value) && has(value, 'then') && typeof value.then === 'function' // && Object.prototype.toString.call(value) === '[object Promise]'
;

exports.isPromise = isPromise;

const debounce = (fn, wait, isImmediate = false) => {
  let timeout;
  return function (...args) {
    const context = this;

    const later = () => {
      timeout = undefined;

      if (!isImmediate) {
        fn.apply(context, args);
      }
    };

    const shouldCall = isImmediate && timeout === undefined;

    if (timeout !== undefined) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(later, wait);

    if (shouldCall) {
      fn.apply(context, args);
    }
  };
};

exports.debounce = debounce;

const loadScript = src => {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.charset = 'utf-8';
    script.async = true;
    script.src = src; // script.timeout = 120000;

    script.addEventListener('load', resolve);
    script.addEventListener('error', () => reject(new Error('Error loading script.')));
    script.addEventListener('abort', () => reject(new Error('Script loading aborted.')));
    document.body.appendChild(script);
  });
};

exports.loadScript = loadScript;

const loadStyles = src => {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';

    link.onload = () => {
      resolve();
    };

    link.href = src;
    const head = document.getElementsByTagName('head');

    if (head) {
      head[0].appendChild(link);
    }
  });
};

exports.loadStyles = loadStyles;

function extend(...args) {
  // let args = Array.prototype.slice.call(arguments, 1);
  // let args = arguments;
  const len = args.length;
  if (len === 0) return null;
  let target = args[0] || {};
  if (len < 2 || target == null) return target;

  if (!isObject(target) && typeof target === 'function') {
    target = {};
  }

  let obj;
  let src;
  let cp;
  let clone;

  const assignKey = (o, key) => {
    src = target[key];
    cp = o[key]; // console.log('...key: '+key+', src: '+src+', cp: '+cp+', typeof: '+(typeof cp));
    // prevent endless loop

    if (target !== cp) {
      if (isset(cp) && isPlainObject(cp)) {
        if (isArray(cp)) {
          clone = src && isArray(src) ? src : []; // need to perform a deep copy of array so internal objects are no longer references

          const arCopy = [];
          cp.forEach((el, j) => {
            if (isPlainObject(el)) {
              arCopy[j] = cloneDeep(el);
            } else {
              arCopy[j] = el;
            }
          }); // target[key] = cp.slice();	// make copy of array instead of passing by reference

          target[key] = arCopy;
        } else if (isFunction(cp)) {
          target[key] = cp;
        } else if (isDate(cp)) {
          target[key] = cp;
        } else {
          clone = isset(src) && isPlainObject(src) ? src : {};
          target[key] = extend({}, clone, cp);
        }
      } else if (isset(cp)) {
        target[key] = cp;
      }
    }
  };

  for (let i = 1; i < len; i += 1) {
    obj = args[i];

    if (obj != null) {
      Object.keys(obj).forEach(key => assignKey(obj, key)); // eslint-disable-line no-loop-func
    }
  }

  return target;
}

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
/* harmony import */ var _isValid_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34);
/* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(40);
/* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39);
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(36);
/* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(52);
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/* harmony import */ var _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);










 // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions = (0,_lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  var firstWeekContainsDate = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(dirtyDate);

  if (!(0,_isValid_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(originalDate);
  var utcDate = (0,_subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_8__["default"][firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }

    var formatter = _lib_format_formatters_index_js__WEBPACK_IMPORTED_MODULE_9__["default"][firstCharacter];

    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.isProtectedWeekYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.isProtectedDayOfYearToken)(substring)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_10__.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);

  if (!matched) {
    return input;
  }

  return matched[1].replace(doubleQuoteRegExp, "'");
}

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requiredArgs)
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultOptions": () => (/* binding */ getDefaultOptions),
/* harmony export */   "setDefaultOptions": () => (/* binding */ setDefaultOptions)
/* harmony export */ });
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_locale_en_US_index_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(29);






/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: _lib_formatDistance_index_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  formatLong: _lib_formatLong_index_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  formatRelative: _lib_formatRelative_index_js__WEBPACK_IMPORTED_MODULE_2__["default"],
  localize: _lib_localize_index_js__WEBPACK_IMPORTED_MODULE_3__["default"],
  match: _lib_match_index_js__WEBPACK_IMPORTED_MODULE_4__["default"],
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (locale);

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatDistance);

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: (0,_lib_buildFormatLongFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatLong);

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFormatLongFn)
/* harmony export */ });
function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatRelative);

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: (0,_lib_buildLocalizeFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localize);

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildLocalizeFn)
/* harmony export */ });
function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);


var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: (0,_lib_buildMatchPatternFn_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: (0,_lib_buildMatchFn_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (match);

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildMatchPatternFn)
/* harmony export */ });
function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildMatchFn)
/* harmony export */ });
function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toInteger)
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isValid)
/* harmony export */ });
/* harmony import */ var _isDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);



/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);

  if (!(0,_isDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  return !isNaN(Number(date));
}

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimezoneOffsetInMilliseconds)
/* harmony export */ });
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ subMilliseconds)
/* harmony export */ });
/* harmony import */ var _addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);



/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyAmount);
  return (0,_addMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate, -amount);
}

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addMilliseconds)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);



/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var timestamp = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate).getTime();
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);
  return new Date(timestamp + amount);
}

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};

var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};

var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (longFormatters);

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(51);
/* harmony import */ var _lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49);
/* harmony import */ var _lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47);
/* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);
/* harmony import */ var _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);







var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */
var formatters = {
  // Era
  G: function G(date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function y(date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize, options) {
    var signedWeekYear = (0,_lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = (0,_lib_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date); // Padding

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function M(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize, options) {
    var week = (0,_lib_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize) {
    var isoWeek = (0,_lib_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoWeek, token.length);
  },
  // Day of the month
  d: function d(date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].d(date, token);
  },
  // Day of year
  D: function D(date, token, localize) {
    var dayOfYear = (0,_lib_getUTCDayOfYear_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function a(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function h(date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].h(date, token);
  },
  // Hour [0-23]
  H: function H(date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(hours, token.length);
  },
  // Minute
  m: function m(date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].m(date, token);
  },
  // Second
  s: function s(date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].s(date, token);
  },
  // Fraction of second
  S: function S(date, token) {
    return _lightFormatters_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(Math.floor(absOffset / 60), 2);
  var minutes = (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters = {
  // Year
  y: function y(date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return (0,_addLeadingZeros_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fractionalSeconds, token.length);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formatters);

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addLeadingZeros)
/* harmony export */ });
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCWeekYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);





function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = (0,_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_2__.getDefaultOptions)();
  var firstWeekContainsDate = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);




function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var defaultOptions = (0,_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var weekStartsOn = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCISOWeekYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);



function getUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);


function startOfUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var weekStartsOn = 1;
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
/* harmony import */ var _startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);




var MILLISECONDS_IN_WEEK = 604800000;
function getUTCWeek(dirtyDate, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options).getTime() - (0,_startOfUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCWeekYear)
/* harmony export */ });
/* harmony import */ var _getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);





function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var defaultOptions = (0,_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var firstWeekContainsDate = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = (0,_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(firstWeek, options);
  return date;
}

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);




var MILLISECONDS_IN_WEEK = 604800000;
function getUTCISOWeek(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var diff = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date).getTime() - (0,_startOfUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfUTCISOWeekYear)
/* harmony export */ });
/* harmony import */ var _getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);



function startOfUTCISOWeekYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var year = (0,_getUTCISOWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = (0,_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fourthOfJanuary);
  return date;
}

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getUTCDayOfYear)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);


var MILLISECONDS_IN_DAY = 86400000;
function getUTCDayOfYear(dirtyDate) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isProtectedDayOfYearToken": () => (/* binding */ isProtectedDayOfYearToken),
/* harmony export */   "isProtectedWeekYearToken": () => (/* binding */ isProtectedWeekYearToken),
/* harmony export */   "throwProtectedError": () => (/* binding */ throwProtectedError)
/* harmony export */ });
var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(37);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33);
/* harmony import */ var _lib_assign_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(95);
/* harmony import */ var _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(39);
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36);
/* harmony import */ var _lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(52);
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _lib_Setter_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54);
/* harmony import */ var _lib_parsers_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(55);
/* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }












 // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = (0,_lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__["default"];

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  var firstWeekContainsDate = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [new _lib_Setter_js__WEBPACK_IMPORTED_MODULE_5__.DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter in _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_6__["default"]) {
      var longFormatter = _lib_format_longFormatters_index_js__WEBPACK_IMPORTED_MODULE_6__["default"][firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  var _iterator = _createForOfIteratorHelper(tokens),
      _step;

  try {
    var _loop = function _loop() {
      var token = _step.value;

      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_7__.isProtectedWeekYearToken)(token)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_7__.throwProtectedError)(token, formatString, dirtyDateString);
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_7__.isProtectedDayOfYearToken)(token)) {
        (0,_lib_protectedTokens_index_js__WEBPACK_IMPORTED_MODULE_7__.throwProtectedError)(token, formatString, dirtyDateString);
      }

      var firstCharacter = token[0];
      var parser = _lib_parsers_index_js__WEBPACK_IMPORTED_MODULE_8__.parsers[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale.match, subFnOptions);

        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }

        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_typeof(_ret) === "object") return _ret.v;
    } // Check if the remaining input contains something other than whitespace

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])(dirtyReferenceDate);

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.


  var utcDate = (0,_subMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_9__["default"])(date, (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_10__["default"])(date));
  var flags = {};

  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;

      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

      if (Array.isArray(result)) {
        utcDate = result[0];
        (0,_lib_assign_index_js__WEBPACK_IMPORTED_MODULE_11__["default"])(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return utcDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DateToSystemTimezoneSetter": () => (/* binding */ DateToSystemTimezoneSetter),
/* harmony export */   "Setter": () => (/* binding */ Setter),
/* harmony export */   "ValueSetter": () => (/* binding */ ValueSetter)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck(this, Setter);

    _defineProperty(this, "subPriority", 0);
  }

  _createClass(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);

  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits(ValueSetter, _Setter);

  var _super = _createSuper(ValueSetter);

  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;

    _classCallCheck(this, ValueSetter);

    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;

    if (subPriority) {
      _this.subPriority = subPriority;
    }

    return _this;
  }

  _createClass(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);

  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits(DateToSystemTimezoneSetter, _Setter2);

  var _super2 = _createSuper(DateToSystemTimezoneSetter);

  function DateToSystemTimezoneSetter() {
    var _this2;

    _classCallCheck(this, DateToSystemTimezoneSetter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);

    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);

    return _this2;
  }

  _createClass(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }

      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);

  return DateToSystemTimezoneSetter;
}(Setter);

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parsers": () => (/* binding */ parsers)
/* harmony export */ });
/* harmony import */ var _EraParser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _YearParser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);
/* harmony import */ var _LocalWeekYearParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(62);
/* harmony import */ var _ISOWeekYearParser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/* harmony import */ var _ExtendedYearParser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(64);
/* harmony import */ var _QuarterParser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(65);
/* harmony import */ var _StandAloneQuarterParser_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(66);
/* harmony import */ var _MonthParser_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(67);
/* harmony import */ var _StandAloneMonthParser_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(68);
/* harmony import */ var _LocalWeekParser_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(69);
/* harmony import */ var _ISOWeekParser_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(71);
/* harmony import */ var _DateParser_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(73);
/* harmony import */ var _DayOfYearParser_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(74);
/* harmony import */ var _DayParser_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(75);
/* harmony import */ var _LocalDayParser_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(77);
/* harmony import */ var _StandAloneLocalDayParser_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(78);
/* harmony import */ var _ISODayParser_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(79);
/* harmony import */ var _AMPMParser_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(81);
/* harmony import */ var _AMPMMidnightParser_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(82);
/* harmony import */ var _DayPeriodParser_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(83);
/* harmony import */ var _Hour1to12Parser_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(84);
/* harmony import */ var _Hour0to23Parser_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(85);
/* harmony import */ var _Hour0To11Parser_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(86);
/* harmony import */ var _Hour1To24Parser_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(87);
/* harmony import */ var _MinuteParser_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(88);
/* harmony import */ var _SecondParser_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(89);
/* harmony import */ var _FractionOfSecondParser_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(90);
/* harmony import */ var _ISOTimezoneWithZParser_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(91);
/* harmony import */ var _ISOTimezoneParser_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(92);
/* harmony import */ var _TimestampSecondsParser_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(93);
/* harmony import */ var _TimestampMillisecondsParser_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(94);































/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */

var parsers = {
  G: new _EraParser_js__WEBPACK_IMPORTED_MODULE_0__.EraParser(),
  y: new _YearParser_js__WEBPACK_IMPORTED_MODULE_1__.YearParser(),
  Y: new _LocalWeekYearParser_js__WEBPACK_IMPORTED_MODULE_2__.LocalWeekYearParser(),
  R: new _ISOWeekYearParser_js__WEBPACK_IMPORTED_MODULE_3__.ISOWeekYearParser(),
  u: new _ExtendedYearParser_js__WEBPACK_IMPORTED_MODULE_4__.ExtendedYearParser(),
  Q: new _QuarterParser_js__WEBPACK_IMPORTED_MODULE_5__.QuarterParser(),
  q: new _StandAloneQuarterParser_js__WEBPACK_IMPORTED_MODULE_6__.StandAloneQuarterParser(),
  M: new _MonthParser_js__WEBPACK_IMPORTED_MODULE_7__.MonthParser(),
  L: new _StandAloneMonthParser_js__WEBPACK_IMPORTED_MODULE_8__.StandAloneMonthParser(),
  w: new _LocalWeekParser_js__WEBPACK_IMPORTED_MODULE_9__.LocalWeekParser(),
  I: new _ISOWeekParser_js__WEBPACK_IMPORTED_MODULE_10__.ISOWeekParser(),
  d: new _DateParser_js__WEBPACK_IMPORTED_MODULE_11__.DateParser(),
  D: new _DayOfYearParser_js__WEBPACK_IMPORTED_MODULE_12__.DayOfYearParser(),
  E: new _DayParser_js__WEBPACK_IMPORTED_MODULE_13__.DayParser(),
  e: new _LocalDayParser_js__WEBPACK_IMPORTED_MODULE_14__.LocalDayParser(),
  c: new _StandAloneLocalDayParser_js__WEBPACK_IMPORTED_MODULE_15__.StandAloneLocalDayParser(),
  i: new _ISODayParser_js__WEBPACK_IMPORTED_MODULE_16__.ISODayParser(),
  a: new _AMPMParser_js__WEBPACK_IMPORTED_MODULE_17__.AMPMParser(),
  b: new _AMPMMidnightParser_js__WEBPACK_IMPORTED_MODULE_18__.AMPMMidnightParser(),
  B: new _DayPeriodParser_js__WEBPACK_IMPORTED_MODULE_19__.DayPeriodParser(),
  h: new _Hour1to12Parser_js__WEBPACK_IMPORTED_MODULE_20__.Hour1to12Parser(),
  H: new _Hour0to23Parser_js__WEBPACK_IMPORTED_MODULE_21__.Hour0to23Parser(),
  K: new _Hour0To11Parser_js__WEBPACK_IMPORTED_MODULE_22__.Hour0To11Parser(),
  k: new _Hour1To24Parser_js__WEBPACK_IMPORTED_MODULE_23__.Hour1To24Parser(),
  m: new _MinuteParser_js__WEBPACK_IMPORTED_MODULE_24__.MinuteParser(),
  s: new _SecondParser_js__WEBPACK_IMPORTED_MODULE_25__.SecondParser(),
  S: new _FractionOfSecondParser_js__WEBPACK_IMPORTED_MODULE_26__.FractionOfSecondParser(),
  X: new _ISOTimezoneWithZParser_js__WEBPACK_IMPORTED_MODULE_27__.ISOTimezoneWithZParser(),
  x: new _ISOTimezoneParser_js__WEBPACK_IMPORTED_MODULE_28__.ISOTimezoneParser(),
  t: new _TimestampSecondsParser_js__WEBPACK_IMPORTED_MODULE_29__.TimestampSecondsParser(),
  T: new _TimestampMillisecondsParser_js__WEBPACK_IMPORTED_MODULE_30__.TimestampMillisecondsParser()
};

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EraParser": () => (/* binding */ EraParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits(EraParser, _Parser);

  var _super = _createSuper(EraParser);

  function EraParser() {
    var _this;

    _classCallCheck(this, EraParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 140);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);

    return _this;
  }

  _createClass(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return EraParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_0__.Parser);

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parser": () => (/* binding */ Parser)
/* harmony export */ });
/* harmony import */ var _Setter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck(this, Parser);
  }

  _createClass(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);

      if (!result) {
        return null;
      }

      return {
        setter: new _Setter_js__WEBPACK_IMPORTED_MODULE_0__.ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);

  return Parser;
}();

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YearParser": () => (/* binding */ YearParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits(YearParser, _Parser);

  var _super = _createSuper(YearParser);

  function YearParser() {
    var _this;

    _classCallCheck(this, YearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 130);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(4, dateString), valueCallback);

        case 'yo':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeTwoDigitYear)(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return YearParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dayPeriodEnumToHours": () => (/* binding */ dayPeriodEnumToHours),
/* harmony export */   "isLeapYearIndex": () => (/* binding */ isLeapYearIndex),
/* harmony export */   "mapValue": () => (/* binding */ mapValue),
/* harmony export */   "normalizeTwoDigitYear": () => (/* binding */ normalizeTwoDigitYear),
/* harmony export */   "parseAnyDigitsSigned": () => (/* binding */ parseAnyDigitsSigned),
/* harmony export */   "parseNDigits": () => (/* binding */ parseNDigits),
/* harmony export */   "parseNDigitsSigned": () => (/* binding */ parseNDigitsSigned),
/* harmony export */   "parseNumericPattern": () => (/* binding */ parseNumericPattern),
/* harmony export */   "parseTimezonePattern": () => (/* binding */ parseTimezonePattern)
/* harmony export */ });
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);


function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_0__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_0__.millisecondsInMinute + seconds * _constants_index_js__WEBPACK_IMPORTED_MODULE_0__.millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.singleDigit, dateString);

    case 2:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.twoDigits, dateString);

    case 3:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.threeDigits, dateString);

    case 4:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.fourDigits, dateString);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.singleDigitSigned, dateString);

    case 2:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.twoDigitsSigned, dateString);

    case 3:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.threeDigitsSigned, dateString);

    case 4:
      return parseNumericPattern(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.fourDigitsSigned, dateString);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "daysInWeek": () => (/* binding */ daysInWeek),
/* harmony export */   "daysInYear": () => (/* binding */ daysInYear),
/* harmony export */   "maxTime": () => (/* binding */ maxTime),
/* harmony export */   "millisecondsInHour": () => (/* binding */ millisecondsInHour),
/* harmony export */   "millisecondsInMinute": () => (/* binding */ millisecondsInMinute),
/* harmony export */   "millisecondsInSecond": () => (/* binding */ millisecondsInSecond),
/* harmony export */   "minTime": () => (/* binding */ minTime),
/* harmony export */   "minutesInHour": () => (/* binding */ minutesInHour),
/* harmony export */   "monthsInQuarter": () => (/* binding */ monthsInQuarter),
/* harmony export */   "monthsInYear": () => (/* binding */ monthsInYear),
/* harmony export */   "quartersInYear": () => (/* binding */ quartersInYear),
/* harmony export */   "secondsInDay": () => (/* binding */ secondsInDay),
/* harmony export */   "secondsInHour": () => (/* binding */ secondsInHour),
/* harmony export */   "secondsInMinute": () => (/* binding */ secondsInMinute),
/* harmony export */   "secondsInMonth": () => (/* binding */ secondsInMonth),
/* harmony export */   "secondsInQuarter": () => (/* binding */ secondsInQuarter),
/* harmony export */   "secondsInWeek": () => (/* binding */ secondsInWeek),
/* harmony export */   "secondsInYear": () => (/* binding */ secondsInYear)
/* harmony export */ });
/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
var daysInWeek = 7;
/**
 * Days in 1 year
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * @name daysInYear
 * @constant
 * @type {number}
 * @default
 */

var daysInYear = 365.2425;
/**
 * Maximum allowed time.
 *
 * @name maxTime
 * @constant
 * @type {number}
 * @default
 */

var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;
/**
 * Minimum allowed time.
 *
 * @name minTime
 * @constant
 * @type {number}
 * @default
 */

var minTime = -maxTime;
/**
 * Minutes in 1 hour
 *
 * @name minutesInHour
 * @constant
 * @type {number}
 * @default
 */

var minutesInHour = 60;
/**
 * Months in 1 quarter
 *
 * @name monthsInQuarter
 * @constant
 * @type {number}
 * @default
 */

var monthsInQuarter = 3;
/**
 * Months in 1 year
 *
 * @name monthsInYear
 * @constant
 * @type {number}
 * @default
 */

var monthsInYear = 12;
/**
 * Quarters in 1 year
 *
 * @name quartersInYear
 * @constant
 * @type {number}
 * @default
 */

var quartersInYear = 4;
/**
 * Seconds in 1 hour
 *
 * @name secondsInHour
 * @constant
 * @type {number}
 * @default
 */

var secondsInHour = 3600;
/**
 * Seconds in 1 minute
 *
 * @name secondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var secondsInMinute = 60;
/**
 * Seconds in 1 day
 *
 * @name secondsInDay
 * @constant
 * @type {number}
 * @default
 */

var secondsInDay = secondsInHour * 24;
/**
 * Seconds in 1 week
 *
 * @name secondsInWeek
 * @constant
 * @type {number}
 * @default
 */

var secondsInWeek = secondsInDay * 7;
/**
 * Seconds in 1 year
 *
 * @name secondsInYear
 * @constant
 * @type {number}
 * @default
 */

var secondsInYear = secondsInDay * daysInYear;
/**
 * Seconds in 1 month
 *
 * @name secondsInMonth
 * @constant
 * @type {number}
 * @default
 */

var secondsInMonth = secondsInYear / 12;
/**
 * Seconds in 1 quarter
 *
 * @name secondsInQuarter
 * @constant
 * @type {number}
 * @default
 */

var secondsInQuarter = secondsInMonth * 3;

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "numericPatterns": () => (/* binding */ numericPatterns),
/* harmony export */   "timezonePatterns": () => (/* binding */ timezonePatterns)
/* harmony export */ });
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalWeekYearParser": () => (/* binding */ LocalWeekYearParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalWeekYearParser, _Parser);

  var _super = _createSuper(LocalWeekYearParser);

  function LocalWeekYearParser() {
    var _this;

    _classCallCheck(this, LocalWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 130);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(4, dateString), valueCallback);

        case 'Yo':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = (0,_lib_getUTCWeekYear_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeTwoDigitYear)(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return (0,_lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return (0,_lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(date, options);
    }
  }]);

  return LocalWeekYearParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_3__.Parser);

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISOWeekYearParser": () => (/* binding */ ISOWeekYearParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // ISO week-numbering year

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOWeekYearParser, _Parser);

  var _super = _createSuper(ISOWeekYearParser);

  function ISOWeekYearParser() {
    var _this;

    _classCallCheck(this, ISOWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 130);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigitsSigned)(4, dateString);
      }

      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigitsSigned)(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return (0,_lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(firstWeekOfYear);
    }
  }]);

  return ISOWeekYearParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExtendedYearParser": () => (/* binding */ ExtendedYearParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(ExtendedYearParser, _Parser);

  var _super = _createSuper(ExtendedYearParser);

  function ExtendedYearParser() {
    var _this;

    _classCallCheck(this, ExtendedYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 130);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigitsSigned)(4, dateString);
      }

      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigitsSigned)(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ExtendedYearParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuarterParser": () => (/* binding */ QuarterParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits(QuarterParser, _Parser);

  var _super = _createSuper(QuarterParser);

  function QuarterParser() {
    var _this;

    _classCallCheck(this, QuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 120);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return QuarterParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StandAloneQuarterParser": () => (/* binding */ StandAloneQuarterParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneQuarterParser, _Parser);

  var _super = _createSuper(StandAloneQuarterParser);

  function StandAloneQuarterParser() {
    var _this;

    _classCallCheck(this, StandAloneQuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 120);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneQuarterParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MonthParser": () => (/* binding */ MonthParser)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits(MonthParser, _Parser);

  var _super = _createSuper(MonthParser);

  function MonthParser() {
    var _this;

    _classCallCheck(this, MonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    _defineProperty(_assertThisInitialized(_this), "priority", 110);

    return _this;
  }

  _createClass(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return MonthParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StandAloneMonthParser": () => (/* binding */ StandAloneMonthParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneMonthParser, _Parser);

  var _super = _createSuper(StandAloneMonthParser);

  function StandAloneMonthParser() {
    var _this;

    _classCallCheck(this, StandAloneMonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 110);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneMonthParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalWeekParser": () => (/* binding */ LocalWeekParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_setUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/* harmony import */ var _lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





 // Local week of year

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalWeekParser, _Parser);

  var _super = _createSuper(LocalWeekParser);

  function LocalWeekParser() {
    var _this;

    _classCallCheck(this, LocalWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 100);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.week, dateString);

        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return (0,_lib_startOfUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_lib_setUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, value, options), options);
    }
  }]);

  return LocalWeekParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_4__.Parser);

/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setUTCWeek)
/* harmony export */ });
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(47);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);




function setUTCWeek(dirtyDate, dirtyWeek, options) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var week = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyWeek);
  var diff = (0,_getUTCWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISOWeekParser": () => (/* binding */ ISOWeekParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_setUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





 // ISO week of year

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOWeekParser, _Parser);

  var _super = _createSuper(ISOWeekParser);

  function ISOWeekParser() {
    var _this;

    _classCallCheck(this, ISOWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 100);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.week, dateString);

        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return (0,_lib_startOfUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_lib_setUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date, value));
    }
  }]);

  return ISOWeekParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_4__.Parser);

/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setUTCISOWeek)
/* harmony export */ });
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);




function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var isoWeek = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyISOWeek);
  var diff = (0,_getUTCISOWeek_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DateParser": () => (/* binding */ DateParser)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits(DateParser, _Parser);

  var _super = _createSuper(DateParser);

  function DateParser() {
    var _this;

    _classCallCheck(this, DateParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 90);

    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.date, dateString);

        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYearIndex)(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DateParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DayOfYearParser": () => (/* binding */ DayOfYearParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayOfYearParser, _Parser);

  var _super = _createSuper(DayOfYearParser);

  function DayOfYearParser() {
    var _this;

    _classCallCheck(this, DayOfYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 90);

    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.dayOfYear, dateString);

        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isLeapYearIndex)(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayOfYearParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DayParser": () => (/* binding */ DayParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(76);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // Day of week

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayParser, _Parser);

  var _super = _createSuper(DayParser);

  function DayParser() {
    var _this;

    _classCallCheck(this, DayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 90);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setUTCDay)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);




function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var defaultOptions = (0,_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var weekStartsOn = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
  var day = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LocalDayParser": () => (/* binding */ LocalDayParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // Local day of week

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits(LocalDayParser, _Parser);

  var _super = _createSuper(LocalDayParser);

  function LocalDayParser() {
    var _this;

    _classCallCheck(this, LocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 90);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);

    return _this;
  }

  _createClass(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString), valueCallback);
        // 3rd

        case 'eo':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return LocalDayParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StandAloneLocalDayParser": () => (/* binding */ StandAloneLocalDayParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // Stand-alone local day of week

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits(StandAloneLocalDayParser, _Parser);

  var _super = _createSuper(StandAloneLocalDayParser);

  function StandAloneLocalDayParser() {
    var _this;

    _classCallCheck(this, StandAloneLocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 90);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);

    return _this;
  }

  _createClass(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString), valueCallback);
        // 3rd

        case 'co':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = (0,_lib_setUTCDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneLocalDayParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISODayParser": () => (/* binding */ ISODayParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
/* harmony import */ var _lib_setUTCISODay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // ISO day of week

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISODayParser, _Parser);

  var _super = _createSuper(ISODayParser);

  function ISODayParser() {
    var _this;

    _classCallCheck(this, ISODayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 90);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
        // 2nd

        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T

        case 'iiiii':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu

        case 'iiiiii':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday

        case 'iiii':
        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = (0,_lib_setUTCISODay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ISODayParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ setUTCISODay)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var _requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);



function setUTCISODay(dirtyDate, dirtyDay) {
  (0,_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var day = (0,_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AMPMParser": () => (/* binding */ AMPMParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits(AMPMParser, _Parser);

  var _super = _createSuper(AMPMParser);

  function AMPMParser() {
    var _this;

    _classCallCheck(this, AMPMParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 80);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dayPeriodEnumToHours)(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AMPMMidnightParser": () => (/* binding */ AMPMMidnightParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits(AMPMMidnightParser, _Parser);

  var _super = _createSuper(AMPMMidnightParser);

  function AMPMMidnightParser() {
    var _this;

    _classCallCheck(this, AMPMMidnightParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 80);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dayPeriodEnumToHours)(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMMidnightParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DayPeriodParser": () => (/* binding */ DayPeriodParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


 // in the morning, in the afternoon, in the evening, at night

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits(DayPeriodParser, _Parser);

  var _super = _createSuper(DayPeriodParser);

  function DayPeriodParser() {
    var _this;

    _classCallCheck(this, DayPeriodParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 80);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);

    return _this;
  }

  _createClass(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.dayPeriodEnumToHours)(value), 0, 0, 0);
      return date;
    }
  }]);

  return DayPeriodParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hour1to12Parser": () => (/* binding */ Hour1to12Parser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour1to12Parser, _Parser);

  var _super = _createSuper(Hour1to12Parser);

  function Hour1to12Parser() {
    var _this;

    _classCallCheck(this, Hour1to12Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 70);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.hour12h, dateString);

        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour1to12Parser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hour0to23Parser": () => (/* binding */ Hour0to23Parser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour0to23Parser, _Parser);

  var _super = _createSuper(Hour0to23Parser);

  function Hour0to23Parser() {
    var _this;

    _classCallCheck(this, Hour0to23Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 70);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.hour23h, dateString);

        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);

  return Hour0to23Parser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hour0To11Parser": () => (/* binding */ Hour0To11Parser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour0To11Parser, _Parser);

  var _super = _createSuper(Hour0To11Parser);

  function Hour0To11Parser() {
    var _this;

    _classCallCheck(this, Hour0To11Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 70);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.hour11h, dateString);

        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour0To11Parser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hour1To24Parser": () => (/* binding */ Hour1To24Parser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits(Hour1To24Parser, _Parser);

  var _super = _createSuper(Hour1To24Parser);

  function Hour1To24Parser() {
    var _this;

    _classCallCheck(this, Hour1To24Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 70);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);

    return _this;
  }

  _createClass(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.hour24h, dateString);

        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);

  return Hour1To24Parser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MinuteParser": () => (/* binding */ MinuteParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits(MinuteParser, _Parser);

  var _super = _createSuper(MinuteParser);

  function MinuteParser() {
    var _this;

    _classCallCheck(this, MinuteParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 60);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.minute, dateString);

        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);

  return MinuteParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 89 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SecondParser": () => (/* binding */ SecondParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits(SecondParser, _Parser);

  var _super = _createSuper(SecondParser);

  function SecondParser() {
    var _this;

    _classCallCheck(this, SecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 50);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNumericPattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.numericPatterns.second, dateString);

        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });

        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);

  return SecondParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FractionOfSecondParser": () => (/* binding */ FractionOfSecondParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits(FractionOfSecondParser, _Parser);

  var _super = _createSuper(FractionOfSecondParser);

  function FractionOfSecondParser() {
    var _this;

    _classCallCheck(this, FractionOfSecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 30);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.mapValue)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseNDigits)(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);

  return FractionOfSecondParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISOTimezoneWithZParser": () => (/* binding */ ISOTimezoneWithZParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // Timezone (ISO-8601. +00:00 is `'Z'`)

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOTimezoneWithZParser, _Parser);

  var _super = _createSuper(ISOTimezoneWithZParser);

  function ISOTimezoneWithZParser() {
    var _this;

    _classCallCheck(this, ISOTimezoneWithZParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 10);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'x']);

    return _this;
  }

  _createClass(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.basicOptionalMinutes, dateString);

        case 'XX':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.basic, dateString);

        case 'XXXX':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.basicOptionalSeconds, dateString);

        case 'XXXXX':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.extendedOptionalSeconds, dateString);

        case 'XXX':
        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneWithZParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ISOTimezoneParser": () => (/* binding */ ISOTimezoneParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // Timezone (ISO-8601)

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits(ISOTimezoneParser, _Parser);

  var _super = _createSuper(ISOTimezoneParser);

  function ISOTimezoneParser() {
    var _this;

    _classCallCheck(this, ISOTimezoneParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 10);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'X']);

    return _this;
  }

  _createClass(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.basicOptionalMinutes, dateString);

        case 'xx':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.basic, dateString);

        case 'xxxx':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.basicOptionalSeconds, dateString);

        case 'xxxxx':
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.extendedOptionalSeconds, dateString);

        case 'xxx':
        default:
          return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseTimezonePattern)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_2__.Parser);

/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimestampSecondsParser": () => (/* binding */ TimestampSecondsParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampSecondsParser, _Parser);

  var _super = _createSuper(TimestampSecondsParser);

  function TimestampSecondsParser() {
    var _this;

    _classCallCheck(this, TimestampSecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 40);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseAnyDigitsSigned)(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampSecondsParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimestampMillisecondsParser": () => (/* binding */ TimestampMillisecondsParser)
/* harmony export */ });
/* harmony import */ var _Parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);

  var _super = _createSuper(TimestampMillisecondsParser);

  function TimestampMillisecondsParser() {
    var _this;

    _classCallCheck(this, TimestampMillisecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 20);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.parseAnyDigitsSigned)(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampMillisecondsParser;
}(_Parser_js__WEBPACK_IMPORTED_MODULE_1__.Parser);

/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ assign)
/* harmony export */ });
function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      ;
      target[property] = object[property];
    }
  }

  return target;
}

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatDistanceStrict)
/* harmony export */ });
/* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/* harmony import */ var _lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(36);
/* harmony import */ var _compareAsc_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(97);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(33);
/* harmony import */ var _lib_cloneObject_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(98);
/* harmony import */ var _lib_assign_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95);
/* harmony import */ var _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);








var MILLISECONDS_IN_MINUTE = 1000 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;
/**
 * @name formatDistanceStrict
 * @category Common Helpers
 * @summary Return the distance between the given dates in words.
 *
 * @description
 * Return the distance between the given dates in words, using strict units.
 * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
 * 'less than' and the like.
 *
 * | Distance between dates | Result              |
 * |------------------------|---------------------|
 * | 0 ... 59 secs          | [0..59] seconds     |
 * | 1 ... 59 mins          | [1..59] minutes     |
 * | 1 ... 23 hrs           | [1..23] hours       |
 * | 1 ... 29 days          | [1..29] days        |
 * | 1 ... 11 months        | [1..11] months      |
 * | 1 ... N years          | [1..N]  years       |
 *
 * @param {Date|Number} date - the date
 * @param {Date|Number} baseDate - the date to compare with
 * @param {Object} [options] - an object with options.
 * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
 * @param {'second'|'minute'|'hour'|'day'|'month'|'year'} [options.unit] - if specified, will force a unit
 * @param {'floor'|'ceil'|'round'} [options.roundingMethod='round'] - which way to round partial units
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @returns {String} the distance in words
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `baseDate` must not be Invalid Date
 * @throws {RangeError} `options.roundingMethod` must be 'floor', 'ceil' or 'round'
 * @throws {RangeError} `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
 * @throws {RangeError} `options.locale` must contain `formatDistance` property
 *
 * @example
 * // What is the distance between 2 July 2014 and 1 January 2015?
 * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
 * //=> '6 months'
 *
 * @example
 * // What is the distance between 1 January 2015 00:00:15
 * // and 1 January 2015 00:00:00?
 * const result = formatDistanceStrict(
 *   new Date(2015, 0, 1, 0, 0, 15),
 *   new Date(2015, 0, 1, 0, 0, 0)
 * )
 * //=> '15 seconds'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, with a suffix?
 * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
 *   addSuffix: true
 * })
 * //=> '1 year ago'
 *
 * @example
 * // What is the distance from 1 January 2016
 * // to 1 January 2015, in minutes?
 * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
 *   unit: 'minute'
 * })
 * //=> '525600 minutes'
 *
 * @example
 * // What is the distance from 1 January 2015
 * // to 28 January 2015, in months, rounded up?
 * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
 *   unit: 'month',
 *   roundingMethod: 'ceil'
 * })
 * //=> '1 month'
 *
 * @example
 * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
 * import { eoLocale } from 'date-fns/locale/eo'
 * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
 *   locale: eoLocale
 * })
 * //=> '1 jaro'
 */

function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale, _options$roundingMeth;

  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var defaultOptions = (0,_lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _lib_defaultLocale_index_js__WEBPACK_IMPORTED_MODULE_2__["default"];

  if (!locale.formatDistance) {
    throw new RangeError('locale must contain localize.formatDistance property');
  }

  var comparison = (0,_compareAsc_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate, dirtyBaseDate);

  if (isNaN(comparison)) {
    throw new RangeError('Invalid time value');
  }

  var localizeOptions = (0,_lib_assign_index_js__WEBPACK_IMPORTED_MODULE_4__["default"])((0,_lib_cloneObject_index_js__WEBPACK_IMPORTED_MODULE_5__["default"])(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison: comparison
  });
  var dateLeft;
  var dateRight;

  if (comparison > 0) {
    dateLeft = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(dirtyBaseDate);
    dateRight = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(dirtyDate);
  } else {
    dateLeft = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(dirtyDate);
    dateRight = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_6__["default"])(dirtyBaseDate);
  }

  var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : 'round');
  var roundingMethodFn;

  if (roundingMethod === 'floor') {
    roundingMethodFn = Math.floor;
  } else if (roundingMethod === 'ceil') {
    roundingMethodFn = Math.ceil;
  } else if (roundingMethod === 'round') {
    roundingMethodFn = Math.round;
  } else {
    throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
  }

  var milliseconds = dateRight.getTime() - dateLeft.getTime();
  var minutes = milliseconds / MILLISECONDS_IN_MINUTE;
  var timezoneOffset = (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(dateRight) - (0,_lib_getTimezoneOffsetInMilliseconds_index_js__WEBPACK_IMPORTED_MODULE_7__["default"])(dateLeft); // Use DST-normalized difference in minutes for years, months and days;
  // use regular difference in minutes for hours, minutes and seconds.

  var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE;
  var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
  var unit;

  if (!defaultUnit) {
    if (minutes < 1) {
      unit = 'second';
    } else if (minutes < 60) {
      unit = 'minute';
    } else if (minutes < MINUTES_IN_DAY) {
      unit = 'hour';
    } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
      unit = 'day';
    } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
      unit = 'month';
    } else {
      unit = 'year';
    }
  } else {
    unit = String(defaultUnit);
  } // 0 up to 60 seconds


  if (unit === 'second') {
    var seconds = roundingMethodFn(milliseconds / 1000);
    return locale.formatDistance('xSeconds', seconds, localizeOptions); // 1 up to 60 mins
  } else if (unit === 'minute') {
    var roundedMinutes = roundingMethodFn(minutes);
    return locale.formatDistance('xMinutes', roundedMinutes, localizeOptions); // 1 up to 24 hours
  } else if (unit === 'hour') {
    var hours = roundingMethodFn(minutes / 60);
    return locale.formatDistance('xHours', hours, localizeOptions); // 1 up to 30 days
  } else if (unit === 'day') {
    var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
    return locale.formatDistance('xDays', days, localizeOptions); // 1 up to 12 months
  } else if (unit === 'month') {
    var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
    return months === 12 && defaultUnit !== 'month' ? locale.formatDistance('xYears', 1, localizeOptions) : locale.formatDistance('xMonths', months, localizeOptions); // 1 year up to max Date
  } else if (unit === 'year') {
    var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
    return locale.formatDistance('xYears', years, localizeOptions);
  }

  throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
}

/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compareAsc)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);


/**
 * @name compareAsc
 * @category Common Helpers
 * @summary Compare the two dates and return -1, 0 or 1.
 *
 * @description
 * Compare the two dates and return 1 if the first date is after the second,
 * -1 if the first date is before the second or 0 if dates are equal.
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Number} the result of the comparison
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Compare 11 February 1987 and 10 July 1989:
 * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
 * //=> -1
 *
 * @example
 * // Sort the array of dates:
 * const result = [
 *   new Date(1995, 6, 2),
 *   new Date(1987, 1, 11),
 *   new Date(1989, 6, 10)
 * ].sort(compareAsc)
 * //=> [
 * //   Wed Feb 11 1987 00:00:00,
 * //   Mon Jul 10 1989 00:00:00,
 * //   Sun Jul 02 1995 00:00:00
 * // ]
 */

function compareAsc(dirtyDateLeft, dirtyDateRight) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeft = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
  var dateRight = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();

  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1; // Return 0 if diff is 0; return NaN if diff is NaN
  } else {
    return diff;
  }
}

/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cloneObject)
/* harmony export */ });
/* harmony import */ var _assign_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);

function cloneObject(object) {
  return (0,_assign_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, object);
}

/***/ }),
/* 99 */
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
;
/**
 * The Event class is used as the base class for the creation of Event objects
 *
 * @export
 * @class Event
 * @implements {IEvent}
 */

class Event {
  /**
   * Creates an `Event` object for the specified event.
   *
   * @param {string} type
   * @param {boolean} [bubbles=false]
   * @param {boolean} [cancellable=false]
   * @param {*} [data=null]
   * @memberof Event
   */
  constructor(type, bubbles = false, cancellable = false, data = null) {
    /**
     * The event target.
     *
     * @type {*}
     * @memberof Event
     */
    this.target = null;
    /**
     * The object that is actively processing the Event object with an event listener.
     *
     * @type {*}
     * @memberof Event
     */

    this.currentTarget = null;
    /**
     * Indicates whether an event is a bubbling event.
     *
     * @type {boolean}
     * @memberof Event
     */

    this.bubbles = false;
    /**
     * Indicates whether the behavior associated with the event can be cancelled.
     *
     * @type {boolean}
     * @memberof Event
     */

    this.cancellable = false;
    this.isPropagationStopped = false;
    this.type = type;
    this.bubbles = bubbles;
    this.cancellable = cancellable;
    this.data = data;
    this.defaultPrevented = false;
  }
  /**
   * Returns a JSON object representation of the event.
   *
   * @returns {EventObject}
   * @memberof Event
   */


  toJSON() {
    return {
      type: this.type,
      data: this.data
    };
  }
  /**
   * Prevents processing of any event listeners in nodes subsequent to the current node in the
   * event flow.
   *
   * @memberof Event
   */


  stopPropagation() {
    this.isPropagationStopped = true;
  }
  /**
   * Prevents processig of any event listeners in the current node and any subsequent nodes in
   * the event flow.
   *
   * @memberof Event
   */


  stopImmediatePropagation() {
    this.stopPropagation();
    this.isPropagationStopped = true;
  }
  /**
   * Checks whether the `preventDefault()` method has been called on the event.
   *
   * @returns {boolean}
   * @memberof Event
   */


  isDefaultPrevented() {
    return this.defaultPrevented;
  }
  /**
   * Cancels an event's default behavior if that behavior can be cancelled.
   *
   * @memberof Event
   */


  preventDefault() {
    this.defaultPrevented = true;
  }

}

var _default = Event;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 100 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Http = _interopRequireDefault(__webpack_require__(101));

var _ApiResult = _interopRequireDefault(__webpack_require__(131));

var _Query = _interopRequireDefault(__webpack_require__(132));

var _utils = __webpack_require__(17);

var strings = _interopRequireWildcard(__webpack_require__(133));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const apiResultFromResponse = res => {
  const json = res && res.data ? res.data : {};
  let error = json.error;

  if (error && (error.code === 'warn_no_data' || error.code === 'warn_invalid_param' || error.code === 'invalid_location')) {
    error = null;
  }

  return new _ApiResult.default(res, json.response || json, error, null);
};
/**
 * An object that is responsible for configuring and performing a single request to the Aeris
 * Weather API.
 *
 * @export
 * @class ApiRequest
 */


class ApiRequest {
  /**
   * Initializes a new request instance configured with the specified client access keys.
   *
   * @param {ApiConfig} [config]
   * @memberof ApiRequest
   */
  constructor(config, opts) {
    /**
     * Base configuration for the request.
     *
     * @type {ApiConfig}
     * @memberof ApiRequest
     */
    this.config = {
      server: 'https://api.aerisapi.com',
      client: {
        id: undefined,
        secret: undefined
      }
    };
    /**
     * The parameters associated with the request.
     *
     * @private
     * @type {ApiRequestOptions}
     * @memberof ApiRequest
     */

    this._params = {
      endpoint: undefined
    };
    this._requests = [];
    this._paramKeys = ['p', 'limit', 'radius', 'filter', 'fields', 'query', 'sort', 'skip', 'from', 'to', 'plimit', 'psort', 'pskip', 'callback', 'metric', 'requests', 'lang', 'format', 'mindist', 'pfilter', 'lod', 'mindist'];
    this._requestKeys = [];
    this.config = (0, _utils.merge)(this.config, config);
    this._http = new _Http.default(this.config.server);
    this._range = {};

    if (opts) {
      this.setParams(opts);
    } // // add convenience methods for setting params
    // this._paramKeys.forEach((param: string) => {
    // 	const self = this as any;
    // 	if (!self[param]) {
    // 		self[param] = function() {
    // 			var args = Array.prototype.slice.call(arguments);
    // 			this.setParam.apply(this, args);
    // 			return this;
    // 		}.bind(this, param);
    // 	}
    // }, this);

  }

  get requests() {
    return this._requests;
  }
  /**
   * Sets or returns the specified parameter.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {(ApiRequest | any)}
   * @memberof ApiRequest
   */


  param(key, value) {
    if ((0, _utils.isset)(value)) {
      if (this._paramKeys.indexOf(key) !== -1) {
        (0, _utils.set)(this._params, key, value);
      }

      return this;
    }

    return (0, _utils.get)(this._params, key);
  }
  /**
   * Returns the current request parameters.
   *
   * @returns {ApiRequestOptions}
   * @memberof ApiRequest
   */


  getParams() {
    return (0, _utils.cloneDeep)(this._params);
  }
  /**
   * Sets multiple request parameters.
   *
   * @param {ApiRequestOptions} params
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  setParams(params) {
    if (!(0, _utils.isset)(params)) {
      return this;
    }

    const filtered = Object.keys(params).filter(p => this._paramKeys.indexOf(p) !== -1).reduce((result, key) => {
      result[key] = params[key];
      return result;
    }, {});
    this._params = (0, _utils.merge)(this._params, filtered);
    return this;
  }

  resetParams() {
    this._params = {
      endpoint: this._endpoint
    };
    return this;
  }
  /**
   * Sets the endpoint for the request (required).
   *
   * @param {string} endpoint
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  endpoint(endpoint) {
    this._endpoint = endpoint;
    this.param('endpoint', endpoint);
    return this;
  }
  /**
   * Returns the endpoint for the request.
   *
   * @returns {string}
   * @memberof ApiRequest
   */


  getEndpoint() {
    return this._endpoint;
  }
  /**
   * Sets the action for the request.
   *
   * @param {string} action
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  action(action) {
    this._action = action;
    return this;
  }
  /**
   * Returns the action for the request.
   *
   * @returns {string}
   * @memberof ApiRequest
   */


  getAction() {
    return this._action;
  }
  /**
   * Sets the place for the request.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  place(value) {
    this.param('p', value);
    return this;
  }
  /**
   * Sets the request's place to the coordinate bounds string.
   *
   * @param {GeoBounds} bounds
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  bounds(bounds) {
    if ((0, _utils.isString)(bounds)) {
      const str = bounds;

      if (/,/.test(str)) {
        const b = str.split(',').map(v => parseFloat(v));

        if (b.length === 4) {
          bounds = {
            north: b[0],
            west: b[1],
            south: b[2],
            east: b[3]
          };
        }
      }
    }

    return this.place(strings.toBounds(bounds));
  }
  /**
   * Sets the limit parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  limit(value) {
    this.param('limit', value);
    return this;
  }
  /**
   * Sets the lod (level-of-detail) parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  lod(value) {
    this.param('lod', value);
    return this;
  }
  /**
   * Sets the mindist parameter.
   *
   * @param {(string | number)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  mindist(value) {
    if ((0, _utils.isNumber)(value)) {
      value = `${value}mi`;
    }

    this.param('mindist', value);
    return this;
  }
  /**
   * Sets the radius parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  radius(value) {
    this.param('radius', value);
    return this;
  }
  /**
   * Sets the filter parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  filter(value) {
    this.param('filter', value);
    return this;
  }
  /**
   * Sets the fields parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  fields(value) {
    this.param('fields', value);
    return this;
  }
  /**
   * Sets the query parameter.
   *
   * @param {(string | Query)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  query(value) {
    if (value instanceof _Query.default) {
      value = value.toString();
    }

    this.param('query', value);
    return this;
  }
  /**
   * Sets the sort parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  sort(value) {
    this.param('sort', value);
    return this;
  }
  /**
   * Sets the skip parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  skip(value) {
    this.param('skip', value);
    return this;
  }
  /**
   * Sets the from parameter.
   *
   * @param {(string | Date)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  from(value) {
    if ((0, _utils.isDate)(value)) {
      const date = value; // don't set `from` value if it's a date that's within 1 minute of the current time

      if (Math.abs(date.getTime() - new Date().getTime()) < 60 * 1000) {
        this.param('from', 'now');
        return this;
      }

      value = (0, _utils.toTimeStr)(date);
      this._range.from = date;
    }

    this.param('from', value);
    return this;
  }
  /**
   * Sets the to parameter.
   *
   * @param {(string | Date)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  to(value) {
    if ((0, _utils.isDate)(value)) {
      const date = value; // don't set `to` value if it's a date that's within 1 minute of the current time

      if (Math.abs(date.getTime() - new Date().getTime()) < 60 * 1000) {
        this.param('to', 'now');
        return this;
      }

      value = (0, _utils.toTimeStr)(date, this._range.from);
      this._range.to = date;
    }

    this.param('to', value);
    return this;
  }
  /**
   * Sets the plimit paramter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  plimit(value) {
    this.param('plimit', value);
    return this;
  }
  /**
   * Sets the psort parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  psort(value) {
    this.param('psort', value);
    return this;
  }
  /**
   * Sets the pskip parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  pskip(value) {
    this.param('pskip', value);
    return this;
  }
  /**
   * Sets the format parameters.
   *
   * @param value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  format(value) {
    this.param('format', value);
    return this;
  }

  route(value) {
    this._route = value;
    return this;
  }
  /**
   * Adds a request to the batch request.
   *
   * Adding child requests to this request automatically converts the containing request to a batch request.
   *
   * @param {ApiRequest} request
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  addRequest(request) {
    const url = request.url(); // make sure we're not adding the same request multiple times based on url

    let allow = this._requests.indexOf(request) === -1;

    if (allow) {
      this._requestKeys.forEach(key => {
        if (url === key) {
          allow = false;
        }
      });
    }

    if (allow) {
      this._requestKeys.push(url);

      this._requests.push(request);
    }

    return this;
  }
  /**
   * Removes a request from the batch request.
   *
   * @param {ApiRequest} request
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  removeRequest(request) {
    const index = this._requests.indexOf(request);

    if (index >= 0) {
      this._requests.splice(index, 1);
    }

    return this;
  }
  /**
   * Removes all requests from the batch request, converting the request instance to a non-batch request.
   *
   * @memberof ApiRequest
   */


  removeAllRequests() {
    this._requests = [];
  }
  /**
   * Perform the request.
   *
   * @param {(result: ApiResult) => void} [callback]
   * @returns {Promise<ApiResult>}
   * @memberof ApiRequest
   */


  get(callback) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      try {
        this._http.cancel();

        const fetcher = this._action === "route"
        /* ROUTE */
        ? url => this._http.post(url, this._route) : url => this._http.get(url);
        const res = yield fetcher(this.url());

        if (res) {
          const result = apiResultFromResponse(res);

          if (callback) {
            callback(result);
          }

          resolve(result);
        }
      } catch (e) {
        console.error('ApiRequest Error', e);
        resolve(new _ApiResult.default(null, null, e, null));
      }
    }));
  }
  /**
   * Cancels any active request.
   *
   * @memberof ApiRequest
   */


  cancel() {
    this._http.cancel();
  }
  /**
   * Returns the url string for the request based on the configured parameters and options.
   *
   * @param {boolean} [isBatch=false]
   * @returns {string}
   * @memberof ApiRequest
   */


  url(isBatch = false) {
    let url = isBatch ? '' : this.config.server;
    const params = (0, _utils.merge)({}, (0, _utils.pickBy)(this._params, o => !(0, _utils.isEmpty)(o)), isBatch ? {} : {
      client_id: this.config.client.id,
      client_secret: this.config.client.secret
    });

    if (this._requests.length > 0) {
      url += '/batch';
      const urls = [];

      this._requests.forEach(request => {
        urls.push(request.url(true));
      });

      params.requests = urls.join(',');
    } else {
      if (this._endpoint) {
        url += `/${this._endpoint}`;
      } else {
        throw new Error('Invalid ApiRequest - No endpoint specified');
      }

      if (this._action && this._action !== ":id"
      /* ID */
      && this._action !== ":all"
      /* ALL */
      ) {
        url += `/${this._action}`;
      } else if (params.p) {
        url += `/${encodeURIComponent(params.p)}`;
        delete params.p;
      }
    }

    const query = Object.keys(params).filter(param => param !== 'endpoint').map(k => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`).join('&');

    if (query.length > 0) {
      url += `?${query}`;
    }

    return url;
  }
  /**
   * Returns a copy of the request.
   *
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  clone() {
    const request = new ApiRequest(this.config);
    request.setParams(this._params);
    return request;
  }

}

var _default = ApiRequest;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.createCancelToken = exports.isCancel = void 0;

var _axios = _interopRequireDefault(__webpack_require__(102));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const CancelToken = _axios.default.CancelToken;

const isCancel = e => _axios.default.isCancel(e);

exports.isCancel = isCancel;

const createCancelToken = () => {
  const source = CancelToken.source();
  return {
    token: source.token,
    source,
    cancel: () => {
      source.cancel();
    },
    isCancel: e => isCancel(e)
  };
};
/**
 * An `Http` object is an adapter that performs HTTP requests using the underlying request library.
 */


exports.createCancelToken = createCancelToken;

class Http {
  /**
   * Initializes an instance with the baseUrl and header configuration. The `baseUrl` value will
   * be prepended to all relative urls made with this instance, whereas absolute urls will be
   * passed through without prefixing.
   *
   * @param baseUrl
   * @param headers
   */
  constructor(baseUrl, headers) {
    this._client = _axios.default.create({
      baseURL: baseUrl,
      headers: (0, _utils.extend)({
        'Content-Type': 'application/json'
      }, headers)
    });
  }
  /**
   * Performs a GET request for the relative or absolute url.
   *
   * @param {string} url
   * @param {*} [opts=undefined]
   * @returns
   * @memberof Http
   */


  get(url, opts = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const res = yield this._client.get(url, (0, _utils.extend)({
          cancelToken: new CancelToken(c => {
            this._source = c;
          })
        }, opts));
        return res;
      } catch (e) {
        if (_axios.default.isCancel && _axios.default.isCancel(e)) {
          console.info('Request canceled', e.message); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }

      return null;
    });
  }
  /**
   * Performs a POST request for the relative or absolute url.
   *
   * @param {string} url
   * @param {*} data
   * @param {*} [opts=undefined]
   * @returns
   * @memberof Http
   */


  post(url, data, opts = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const res = yield this._client.post(url, data, (0, _utils.extend)({
          cancelToken: new CancelToken(c => {
            this._source = c;
          })
        }, opts));
        return res;
      } catch (e) {
        if (_axios.default.isCancel && _axios.default.isCancel(e)) {
          console.info('Request canceled', e.message); // eslint-disable-line no-console
        } else {
          throw e;
        }
      }

      return null;
    });
  }

  cancel() {
    if (this._source) {
      this._source();
    }
  }
  /**
   * A class method that performs a request to an absolute url.
   *
   * @param url
   * @param opts
   */


  static request(url, opts = undefined) {
    return __awaiter(this, void 0, void 0, function* () {
      const res = yield _axios.default.get(url, opts);
      return res;
    });
  }

}

var _default = Http;
exports["default"] = _default;

/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(103);

/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);
var bind = __webpack_require__(105);
var Axios = __webpack_require__(106);
var mergeConfig = __webpack_require__(124);
var defaults = __webpack_require__(111);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(127);
axios.CancelToken = __webpack_require__(128);
axios.isCancel = __webpack_require__(123);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(129);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(130);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(105);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),
/* 105 */
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);
var buildURL = __webpack_require__(107);
var InterceptorManager = __webpack_require__(108);
var dispatchRequest = __webpack_require__(109);
var mergeConfig = __webpack_require__(124);
var validator = __webpack_require__(125);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 107 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 109 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);
var transformData = __webpack_require__(110);
var isCancel = __webpack_require__(123);
var defaults = __webpack_require__(111);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 110 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);
var defaults = __webpack_require__(111);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),
/* 111 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);
var normalizeHeaderName = __webpack_require__(112);
var enhanceError = __webpack_require__(113);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(114);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(114);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),
/* 112 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 113 */
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),
/* 114 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);
var settle = __webpack_require__(115);
var cookies = __webpack_require__(117);
var buildURL = __webpack_require__(107);
var buildFullPath = __webpack_require__(118);
var parseHeaders = __webpack_require__(121);
var isURLSameOrigin = __webpack_require__(122);
var createError = __webpack_require__(116);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),
/* 115 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(116);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 116 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(113);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 117 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),
/* 118 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(119);
var combineURLs = __webpack_require__(120);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),
/* 119 */
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 120 */
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 121 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),
/* 123 */
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(104);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(126);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),
/* 126 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ }),
/* 127 */
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 128 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(127);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 129 */
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 130 */
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),
/* 131 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

/**
 * An `ApiResult` object contains response information about an API request.
 */
class ApiResult {
  /**
   * Initializes a result instance with the necessary response information.
   *
   * @param {*} response
   * @param {*} data
   * @param {*} error
   * @param {*} [params=null]
   * @memberof ApiResult
   */
  constructor(response, data, error, params = null) {
    let warning = null; // move error info to the warning property if the code is prefixed by `warn_`

    if (error) {
      const {
        code
      } = error || {};

      if (/^warn_/.test(code)) {
        warning = error;
      }
    }

    this.response = response;
    this.data = data;
    this.error = (0, _utils.isset)(warning) ? null : error;
    this.warning = warning;
    this.params = params;
  }
  /**
   * Returns the headers returned by the response, if any.
   *
   * @returns {*}
   * @memberof ApiResult
   */


  headers() {
    return this.response ? this.response.headers : undefined;
  }

}

var _default = ApiResult;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.QueryCondition = void 0;

/**
 * A `QueryCondition` object stores information about a single property-value condition.
 */
class QueryCondition {
  /**
   * Initializes a query condition instance for the specified property and value and optional
   * next operator.
   *
   * @param {string} property
   * @param {*} value
   * @param {Operator} [nextOperator=Operator.AND]
   * @memberof QueryCondition
   */
  constructor(property, value, nextOperator = ","
  /* AND */
  ) {
    this.property = property;
    this.value = value;
    this.nextOperator = nextOperator;
  }
  /**
   * Returns the formatted query string to be used with API requests.
   *
   * @returns {string}
   * @memberof QueryCondition
   */


  toString() {
    return `${this.property}:${this.value}`;
  }

}
/**
 * A `Query` object is a convenience wrapper for setting up and configuring a query string used
 * for API queries.
 */


exports.QueryCondition = QueryCondition;

class Query {
  /**
   * Initializes a query instance, optionally with an array of query conditions.
   *
   * @param {QueryCondition[]} [conditions=[]]
   * @memberof Query
   */
  constructor(conditions = []) {
    this._conditions = conditions || [];
  }
  /**
   * Adds a query condition.
   *
   * @param {QueryCondition} condition
   * @returns {Query}
   * @memberof Query
   */


  addCondition(condition) {
    this._conditions.push(condition);

    return this;
  }
  /**
   * Removes a query condition.
   *
   * @param {QueryCondition} condition
   * @returns {Query}
   * @memberof Query
   */


  removeCondition(condition) {
    const index = this._conditions.indexOf(condition);

    if (index !== -1) {
      this._conditions.splice(index, 1);
    }

    return this;
  }
  /**
   * Removes all query conditions.
   *
   * @returns {Query}
   * @memberof Query
   */


  removeAllConditions() {
    this._conditions = [];
    return this;
  }
  /**
   * Returns the formatted string from all query conditions to be used for API requests.
   *
   * @returns {string}
   * @memberof Query
   */


  toString() {
    const last = this._conditions.length - 1;
    return this._conditions.reduce((prev, current, index) => {
      prev += `${current.toString()}${index < last ? current.nextOperator : ''}`;
      return prev;
    }, '');
  }

}

var _default = Query;
exports["default"] = _default;

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parse = exports.isPercentage = exports.toDate = exports.prefixCSSClassName = exports.formatDirections = exports.toDirectionLong = exports.toName = exports.toBounds = exports.toCoord = exports.hyphenate = exports.camelcase = exports.ucfirst = exports.ucwords = exports.countries = exports.states = void 0;

var _ = __webpack_require__(17);

var _globals = __webpack_require__(134);

/**
 * @ignore
 */
const _states = {
  us: {
    al: 'alabama',
    ak: 'alaska',
    az: 'arizona',
    ar: 'arkansas',
    ca: 'california',
    co: 'colorado',
    ct: 'connecticut',
    de: 'delaware',
    fl: 'florida',
    ga: 'georgia',
    hi: 'hawaii',
    id: 'idaho',
    il: 'illinois',
    in: 'indiana',
    ia: 'iowa',
    ks: 'kansas',
    ky: 'kentucky',
    la: 'louisiana',
    me: 'maine',
    md: 'maryland',
    ma: 'massachusetts',
    mi: 'michigan',
    mn: 'minnesota',
    ms: 'mississippi',
    mo: 'missouri',
    mt: 'montana',
    ne: 'nebraska',
    nv: 'nevada',
    nh: 'new hampshire',
    nj: 'new jersey',
    nm: 'new mexico',
    ny: 'new york',
    nc: 'north carolina',
    nd: 'north dakota',
    oh: 'ohio',
    ok: 'oklahoma',
    or: 'oregon',
    pa: 'pennsylvania',
    ri: 'rhode island',
    sc: 'south carolina',
    sd: 'south dakota',
    tn: 'tennessee',
    tx: 'texas',
    ut: 'utah',
    vt: 'vermont',
    va: 'virginia',
    wa: 'washington',
    wv: 'west virginia',
    wi: 'wisconsin',
    wy: 'wyoming',
    pr: 'puerto rico',
    vi: 'virgin islands',
    gu: 'guam',
    dc: 'district of columbia'
  },
  ca: {
    ab: 'alberta',
    bc: 'british columbia',
    pe: 'prince edward',
    mb: 'manitoba',
    nb: 'new brunswick',
    ns: 'nova scotia',
    on: 'ontario',
    qc: 'qu\u00c8bec',
    sk: 'saskatchewan',
    nf: 'new foundland',
    nt: 'northwest territories',
    nu: 'nunavut',
    yk: 'yukon'
  }
};
/**
 * @ignore
 */

const _countries = {
  ad: 'andorra',
  ae: 'united arab emirates',
  af: 'afghanistan',
  ag: 'antigua and barbuda',
  ai: 'anguilla',
  al: 'albania',
  am: 'armenia',
  ao: 'angola',
  aq: 'antarctica',
  ar: 'argentina',
  as: 'american samoa',
  at: 'austria',
  au: 'australia',
  aw: 'aruba',
  ax: 'aland islands',
  az: 'azerbaijan',
  ba: 'bosnia and herzegovina',
  bb: 'barbados',
  bd: 'bangladesh',
  be: 'belgium',
  bf: 'burkina faso',
  bg: 'bulgaria',
  bh: 'bahrain',
  bi: 'burundi',
  bj: 'benin',
  bl: 'saint barth\ufffdlemy',
  bm: 'bermuda',
  bn: 'brunei',
  bo: 'bolivia',
  bq: 'bonaire, saint eustatius and saba',
  br: 'brazil',
  bs: 'bahamas',
  bt: 'bhutan',
  bv: 'bouvet island',
  bw: 'botswana',
  by: 'belarus',
  bz: 'belize',
  ca: 'canada',
  cc: 'cocos islands',
  cd: 'democratic republic of the congo',
  cf: 'central african republic',
  cg: 'republic of the congo',
  ch: 'switzerland',
  ci: 'ivory coast',
  ck: 'cook islands',
  cl: 'chile',
  cm: 'cameroon',
  cn: 'china',
  co: 'colombia',
  cr: 'costa rica',
  cu: 'cuba',
  cv: 'cape verde',
  cw: 'cura\ufffdao',
  cx: 'christmas island',
  cy: 'cyprus',
  cz: 'czech republic',
  de: 'germany',
  dj: 'djibouti',
  dk: 'denmark',
  dm: 'dominica',
  do: 'dominican republic',
  dz: 'algeria',
  ec: 'ecuador',
  ee: 'estonia',
  eg: 'egypt',
  eh: 'western sahara',
  er: 'eritrea',
  es: 'spain',
  et: 'ethiopia',
  fi: 'finland',
  fj: 'fiji',
  fk: 'falkland islands',
  fm: 'micronesia',
  fo: 'faroe islands',
  fr: 'france',
  ga: 'gabon',
  gb: 'united kingdom',
  gd: 'grenada',
  ge: 'georgia',
  gf: 'french guiana',
  gg: 'guernsey',
  gh: 'ghana',
  gi: 'gibraltar',
  gl: 'greenland',
  gm: 'gambia',
  gn: 'guinea',
  gp: 'guadeloupe',
  gq: 'equatorial guinea',
  gr: 'greece',
  gs: 'south georgia and the south sandwich islands',
  gt: 'guatemala',
  gu: 'guam',
  gw: 'guinea-bissau',
  gy: 'guyana',
  hk: 'hong kong',
  hm: 'heard island and mcdonald islands',
  hn: 'honduras',
  hr: 'croatia',
  ht: 'haiti',
  hu: 'hungary',
  id: 'indonesia',
  ie: 'ireland',
  il: 'israel',
  im: 'isle of man',
  in: 'india',
  io: 'british indian ocean territory',
  iq: 'iraq',
  ir: 'iran',
  is: 'iceland',
  it: 'italy',
  je: 'jersey',
  jm: 'jamaica',
  jo: 'jordan',
  jp: 'japan',
  ke: 'kenya',
  kg: 'kyrgyzstan',
  kh: 'cambodia',
  ki: 'kiribati',
  km: 'comoros',
  kn: 'saint kitts and nevis',
  kp: 'north korea',
  kr: 'south korea',
  kw: 'kuwait',
  ky: 'cayman islands',
  kz: 'kazakhstan',
  la: 'laos',
  lb: 'lebanon',
  lc: 'saint lucia',
  li: 'liechtenstein',
  lk: 'sri lanka',
  lr: 'liberia',
  ls: 'lesotho',
  lt: 'lithuania',
  lu: 'luxembourg',
  lv: 'latvia',
  ly: 'libya',
  ma: 'morocco',
  mc: 'monaco',
  md: 'moldova',
  me: 'montenegro',
  mf: 'saint martin',
  mg: 'madagascar',
  mh: 'marshall islands',
  mk: 'macedonia',
  ml: 'mali',
  mm: 'myanmar',
  mn: 'mongolia',
  mo: 'macao',
  mp: 'northern mariana islands',
  mq: 'martinique',
  mr: 'mauritania',
  ms: 'montserrat',
  mt: 'malta',
  mu: 'mauritius',
  mv: 'maldives',
  mw: 'malawi',
  mx: 'mexico',
  my: 'malaysia',
  mz: 'mozambique',
  na: 'namibia',
  nc: 'new caledonia',
  ne: 'niger',
  nf: 'norfolk island',
  ng: 'nigeria',
  ni: 'nicaragua',
  nl: 'netherlands',
  no: 'norway',
  np: 'nepal',
  nr: 'nauru',
  nu: 'niue',
  nz: 'new zealand',
  om: 'oman',
  pa: 'panama',
  pe: 'peru',
  pf: 'french polynesia',
  pg: 'papua new guinea',
  ph: 'philippines',
  pk: 'pakistan',
  pl: 'poland',
  pm: 'saint pierre and miquelon',
  pn: 'pitcairn',
  pr: 'puerto rico',
  ps: 'palestinian territory',
  pt: 'portugal',
  pw: 'palau',
  py: 'paraguay',
  qa: 'qatar',
  re: 'reunion',
  ro: 'romania',
  rs: 'serbia',
  ru: 'russia',
  rw: 'rwanda',
  sa: 'saudi arabia',
  sb: 'solomon islands',
  sc: 'seychelles',
  sd: 'sudan',
  se: 'sweden',
  sg: 'singapore',
  sh: 'saint helena',
  si: 'slovenia',
  sj: 'svalbard and jan mayen',
  sk: 'slovakia',
  sl: 'sierra leone',
  sm: 'san marino',
  sn: 'senegal',
  so: 'somalia',
  sr: 'suriname',
  ss: 'south sudan',
  st: 'sao tome and principe',
  sv: 'el salvador',
  sx: 'sint maarten',
  sy: 'syria',
  sz: 'swaziland',
  tc: 'turks and caicos islands',
  td: 'chad',
  tf: 'french southern territories',
  tg: 'togo',
  th: 'thailand',
  tj: 'tajikistan',
  tk: 'tokelau',
  tl: 'east timor',
  tm: 'turkmenistan',
  tn: 'tunisia',
  to: 'tonga',
  tr: 'turkey',
  tt: 'trinidad and tobago',
  tv: 'tuvalu',
  tw: 'taiwan',
  tz: 'tanzania',
  ua: 'ukraine',
  ug: 'uganda',
  um: 'united states minor outlying islands',
  us: 'united states',
  uy: 'uruguay',
  uz: 'uzbekistan',
  va: 'vatican',
  vc: 'saint vincent and the grenadines',
  ve: 'venezuela',
  vg: 'british virgin islands',
  vi: 'u.s. virgin islands',
  vn: 'vietnam',
  vu: 'vanuatu',
  wf: 'wallis and futuna',
  ws: 'samoa',
  xk: 'kosovo',
  ye: 'yemen',
  yt: 'mayotte',
  za: 'south africa',
  zm: 'zambia',
  zw: 'zimbabwe',
  uk: 'united kingdom'
};
/**
 * Returns a states collection keyed by country (`us` or `ca`) and the two-letter state
 * abbreviation.
 *
 * @returns {{ [key: string]: { [key: string]: string }}}
 */

const states = () => _states;
/**
 * Returns a country collection keyed by two-letter country abbreviation.
 *
 * @returns {{ [key: string]: string }}
 */


exports.states = states;

const countries = () => _countries;
/**
 * Returns a new string by capitalizing the first letter of each word in the specified string.
 *
 * @param {string} str
 * @returns {string}
 */


exports.countries = countries;

const ucwords = str => {
  str = `${str}`.toLowerCase();
  return `${str}`.replace(/^([a-z])|\s+([a-z])|\/([a-z])|(\-[a-z])/g, $1 => $1.toUpperCase());
};
/**
 * Returns a new string by capitalizing the first letter in the specified string.
 *
 * @param {string} str
 * @returns {string}
 */


exports.ucwords = ucwords;

const ucfirst = str => {
  str += '';
  const f = str.charAt(0).toUpperCase();
  return f + str.substr(1);
};
/**
 * Returns a new string by converting the specified string to camelcase.
 *
 * @param {string} str
 * @returns {string}
 */


exports.ucfirst = ucfirst;

const camelcase = str => (str || '').replace(/[^A-Za-z0-9]/g, ' ').replace(/^\w|[A-Z]|\b\w|\s+/g, (match, index) => {
  if (+match === 0 || match === '-' || match === '.') {
    return ''; // or if (/\s+/.test(match)) for white spaces
  }

  return index === 0 ? match.toLowerCase() : match.toUpperCase();
});
/**
 * Returns a new string by converting a camelcase string to hyphenated.
 *
 * @param {string} str
 * @returns {string}
 */


exports.camelcase = camelcase;

const hyphenate = str => (str || '').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
/**
 * Converts the specified coordinate to a string whose values are rounded to the nearest decimal
 * place according to `places`.
 *
 * @param {number} lat
 * @param {number} lon
 * @param {number} [places=3]
 * @returns {string}
 */


exports.hyphenate = hyphenate;

const toCoord = (lat, lon, places = 3) => {
  const latStr = lat < 0 ? `${Math.abs(lat).toFixed(places)} S` : `${lat.toFixed(places)} N`;
  const lonStr = lon < 0 ? `${Math.abs(lon).toFixed(places)} W` : `${lon.toFixed(places)} E`;
  return `${latStr}, ${lonStr}`;
};
/**
 * Converts the specified coordinate bounds object to a string whose values are rounded to the
 * nearest decimal place according to `places`.
 *
 * @param {GeoBounds} bounds
 * @param {number} [places=3]
 * @returns {string}
 */


exports.toCoord = toCoord;

const toBounds = (bounds, places = 3) => {
  if (!bounds || Object.keys(bounds).length === 0) return null;
  const b = (0, _.cloneDeep)(bounds);
  b.north = Math.min(90, Math.max(-90, b.north));
  b.south = Math.min(90, Math.max(-90, b.south));

  if (b.west < -180 || b.west > 180) {
    b.west -= 360 * Math.floor(b.west / 360);
  }

  if (b.east < -180 || b.east > 180) {
    b.east -= 360 * Math.ceil(b.east / 360);
  }

  return `${b.north.toFixed(places)},${b.west.toFixed(places)},${b.south.toFixed(places)},${b.east.toFixed(places)}`;
};
/**
 * Returns a new string by formatting the specified string as a place name.
 *
 * @param {string} str
 * @returns {string}
 */


exports.toBounds = toBounds;

const toName = str => {
  let result = ucwords(str).split('-').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('-').split('.').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join('.').split(',').map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(', ').replace(/\s+/, ' ');
  result = result.replace(/^\s+/, '').replace(/\s+$/, ''); // capitalize states and countries found in the name

  Object.keys(_countries).forEach(code => {
    const regex = new RegExp(` ${code}$`, 'i');
    result = result.replace(regex, $1 => $1.toUpperCase());
  });
  Object.keys(_states).forEach(country => {
    Object.keys(_states[country]).forEach(code => {
      const regex = new RegExp(` ${code}(,|$)`, 'i');
      result = result.replace(regex, $1 => $1.toUpperCase());
    });
  });
  return result;
};

exports.toName = toName;

const toDirectionLong = dir => {
  let result = dir;

  switch (result.toUpperCase()) {
    case 'N':
      result = 'north';
      break;

    case 'NNE':
      result = 'north-northeast';
      break;

    case 'NE':
      result = 'northeast';
      break;

    case 'ENE':
      result = 'east-northeast';
      break;

    case 'E':
      result = 'east';
      break;

    case 'ESE':
      result = 'east-southeast';
      break;

    case 'SE':
      result = 'southeast';
      break;

    case 'SSE':
      result = 'south-southeast';
      break;

    case 'S':
      result = 'south';
      break;

    case 'SSW':
      result = 'south-southwest';
      break;

    case 'SW':
      result = 'southwest';
      break;

    case 'WSW':
      result = 'west-southwest';
      break;

    case 'W':
      result = 'west';
      break;

    case 'WNW':
      result = 'west-northwest';
      break;

    case 'NW':
      result = 'northwest';
      break;

    case 'NNW':
      result = 'north-northwest';
      break;

    default:
  }

  return result;
};

exports.toDirectionLong = toDirectionLong;

const formatDirections = str => {
  const regex = new RegExp(/\b(N|NNE|NE|ENE|E|ESE|SE|SSE|S|SSW|SW|WSW|W|WNW|NW|NNW)\b/g);
  return str.replace(regex, toDirectionLong);
};

exports.formatDirections = formatDirections;

const prefixCSSClassName = className => className.split(' ').map(c => {
  const re = new RegExp(`^${_globals.Globals.cssPrefix}`);

  if (re.test(c) === false) {
    c = `${_globals.Globals.cssPrefix}${c}`;
  }

  return c;
}).join(' ');

exports.prefixCSSClassName = prefixCSSClassName;

const toDate = str => {
  const m = (str || '').match(/^(\d{1,2})(\/|-)(\d{1,2})(\/|-)(\d{4})/);

  if (!m || m.length < 6) {
    return null;
  }

  return new Date(parseInt(m[5], 10), parseInt(m[1], 10) - 1, parseInt(m[3], 10));
};

exports.toDate = toDate;

const isPercentage = str => (0, _.isString)(str) && str.indexOf('%') !== -1;

exports.isPercentage = isPercentage;

const parse = (str, vars) => {
  if ((0, _.isString)(str) && (0, _.isset)(vars)) {
    Object.keys(vars).forEach(key => {
      str = str.replace(new RegExp(`{${key}}`), vars[key]);
    });
  }

  return str;
};

exports.parse = parse;

/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.servers = exports.Globals = void 0;
var Globals;
exports.Globals = Globals;

(function (Globals) {
  Globals.cssPrefix = 'awxjs__';
})(Globals || (exports.Globals = Globals = {}));

const servers = {
  api: 'https://api.aerisapi.com',
  maps: 'https://maps.aerisapi.com'
};
exports.servers = servers;

/***/ }),
/* 135 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Http = _interopRequireDefault(__webpack_require__(101));

var _MapResult = _interopRequireDefault(__webpack_require__(136));

var _Layer = _interopRequireDefault(__webpack_require__(138));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const toArray = str => (str || '').replace(/\s/, '').split(',');

const toCodeArray = value => {
  if ((0, _utils.isEmpty)(value)) {
    return [];
  }

  if (!(0, _utils.isArray)(value)) {
    return toArray(value);
  }

  const result = value.map(v => {
    if (v instanceof _Layer.default) {
      return v.toString();
    }

    return v;
  });
  return result;
};

const normalize = params => {
  Object.keys(params).forEach(key => {
    const val = params[key];

    if (key === 'layers') {
      if ((0, _utils.isPlainObject)(val)) {
        Object.keys(val).forEach(k => {
          val[k] = toCodeArray(val[k]);
        });
      } else {
        params[key] = toCodeArray(val);
      }
    } else if (key === 'p') {
      if ((0, _utils.isObject)(params[key])) {
        const {
          lat,
          lon
        } = params[key];

        if (lat && lon) {
          params[key] = `${lat},${lon}`;
        }
      }
    }
  });
  return params;
};
/**
 * An object that is responsible for configuring and performing a single request to the Aeris Weather API.
 *
 * @export
 * @class MapRequest
 */


class MapRequest {
  /**
   * Initializes a new request instance configured with the specified client access keys.
   *
   * @param config
   */
  constructor(config, opts) {
    /**
     * Base configuration for the request.
     *
     * @type {ApiConfig}
     * @memberof MapRequest
     */
    this.config = {
      server: 'https://maps.aerisapi.com',
      client: {
        id: undefined,
        secret: undefined
      }
    };
    /**
     * Parameters associated with the request.
     *
     * @private
     * @type {IMapOptions}
     * @memberof MapRequest
     */

    this._params = {
      type: "image"
      /* IMAGE */
      ,
      layers: {
        base: undefined,
        data: undefined,
        overlays: undefined,
        text: undefined
      },
      p: undefined,
      zoom: 3,
      bounds: undefined,
      size: {
        width: undefined,
        height: undefined
      },
      offset: '0',
      metric: false,
      format: 'png'
    };
    this._serverRange = [1, 2, 3, 4];
    this._paramKeys = ['type', 'layers', 'layers.base', 'layers.data', 'layers.overlays', 'layers.text', 'p', 'center', 'zoom', 'bounds', 'size', 'size.width', 'size.height', 'offset', 'metric', 'format'];
    this.config = (0, _utils.merge)(this.config, config);
    this._http = new _Http.default(this.config.server, {
      'Content-Type': null
    });

    if (opts) {
      this.setParams(opts);
    }
  }
  /**
   * Sets or returns the specified parameter.
   *
   * @param key
   * @param value
   */


  param(key, value) {
    if (value) {
      if (this._paramKeys.indexOf(key) !== -1) {
        (0, _utils.set)(this._params, key, value);

        if (/^layers/.test(key)) {
          this._params = normalize(this._params);
        }
      }

      return this;
    }

    return (0, _utils.get)(this._params, key);
  }
  /**
   * Sets multiple request parameters.
   *
   * @param params
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  setParams(params) {
    this._params = normalize((0, _utils.merge)(this._params, params));
    return this;
  }
  /**
   * Sets the type of map image to request, either `image` (default) or `tile`.
   *
   * @param {MapRequestType} type
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  type(type) {
    this.param('type', type);
    return this;
  }
  /**
   * Sets the base layers, which will be rendered at the bottom of the layer stack.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  base(value) {
    this.param('layers.base', toCodeArray(value));
    return this;
  }
  /**
   * Sets the weather data layers, which will be rendered above the base layers but below overlays and text.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  data(value) {
    this.param('layers.data', toCodeArray(value));
    return this;
  }
  /**
   * Sets the overlay layers, which will be rendered above weather data layers but below text layers.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  overlays(value) {
    this.param('layers.overlays', toCodeArray(value));
    return this;
  }
  /**
   * Sets the text layers, which will be rendered at the top of the layer stack.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  text(value) {
    this.param('layers.text', toCodeArray(value));
    return this;
  }
  /**
   * Sets all layers, which will be rendered in the order in which they are provided by `value`.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  layers(value) {
    this.param('layers', toCodeArray(value));
    return this;
  }
  /**
   * Sets the location the map will be centered on.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  place(value) {
    this.param('p', value);
    return this;
  }
  /**
   * Sets the center for the map request. The center can be a place name or a geographical
   * coordinate value.
   *
   * @param {(string | Coordinate)} [value]
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  center(value) {
    if ((0, _utils.isObject)(value)) {
      const {
        lat,
        lon
      } = value;

      if (lat && lon) {
        value = `${lat},${lon}`;
      }
    }

    this.param('p', value);
    return this;
  }
  /**
   * Sets the zoom level.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  zoom(value) {
    this.param('zoom', value);
    return this;
  }
  /**
   * Sets the bounding box coordinates for the rendered map region.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  bounds(value) {
    this.param('bounds', value);
    return this;
  }
  /**
   * Sets the map width and height.
   *
   * @param w
   * @param h
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  size(w, h) {
    this.param('size', {
      width: w,
      height: h
    });
    return this;
  }
  /**
   * Sets the time offset value.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  offset(value) {
    this.param('offset', `${value}`);
    return this;
  }
  /**
   * Sets the time offset value using the specified date.
   *
   * @param {Date} value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  date(value) {
    // eliminate seconds and milliseconds from date
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // time string must be in GMT

    const date = new Date(value.getTime() + value.getTimezoneOffset() * 60 * 1000);
    return this.offset((0, _utils.formatDate)(date, 'yyyyMMddHHmm00'));
  }
  /**
   * Sets whether text data should be rendered as Metric units.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  metric(value) {
    if (value) {
      this.param('metric', value);
      return this;
    }

    return this.param('metric');
  }
  /**
   * Sets the server subdomain range for the request, e.g. `[1, 2, 3, 4]`.
   *
   * @param {number[]} [value]
   * @returns {(MapRequest | number[])}
   * @memberof MapRequest
   */


  range(value) {
    if (value) {
      this._serverRange = [...value];
      return this;
    }

    return this._serverRange;
  }
  /**
   * Perform the request.
   */


  get(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const url = this.url();

        if (!url) {
          const result = new _MapResult.default(null, null, new Error('Invalid map url'), this._params);

          if (callback) {
            callback(result);
          }

          return result;
        }

        const res = yield this._http.get(url);
        let image;
        let error;

        if (res.status >= 400) {
          const json = yield res.data;
          error = json.error;

          if (error && (error.code === 'warn_no_data' || error.code === 'warn_invalid_param' || error.code === 'invalid_location')) {
            error = null;
          }
        } else {
          image = new Image();
          image.src = url.indexOf(this.config.server) >= 0 ? url : `${this.config.server}/${url}`;
        }

        const result = new _MapResult.default(res, image, error, this._params);

        if (callback) {
          callback(result);
        }

        return result;
      } catch (e) {
        console.error('MapRequest Error', e);
      }

      return null;
    });
  }
  /**
   * Returns the url string for the request based on the configured parameters and options.
   *
   * @param {string[]} [groups=[]]
   * @returns {string}
   * @memberof MapRequest
   */


  url(groups = []) {
    let url = this.config.server;
    const params = (0, _utils.merge)({}, (0, _utils.pickBy)(this._params, o => !(0, _utils.isEmpty)(o)), {
      layers: []
    });

    if ((0, _utils.isString)(params.p)) {
      params.p = params.p.replace(/\+/, '%20');
    }

    const layers = this._params.layers;

    if ((0, _utils.isPlainObject)(layers)) {
      const layerGroups = layers;
      groups = !(0, _utils.isEmpty)(groups) ? groups : Object.keys(layerGroups); // console.log(groups, layers);

      if (!(0, _utils.isEmpty)(groups)) {
        groups.forEach(group => {
          let glayers = layerGroups[group];

          if (!(0, _utils.isEmpty)(glayers)) {
            if (!(0, _utils.isArray)(glayers)) {
              glayers = toArray(glayers);
            }

            params.layers = params.layers.concat(glayers);
          }
        });
      }
    } else if ((0, _utils.isArray)(layers)) {
      params.layers = layers;
    }

    if ((0, _utils.isEmpty)(params.layers)) {
      if (groups.length > 1) {
        console.warn(`No map layers specified - layers: ${params.layers}; groups: ${groups.join(',')}`);
      }

      return undefined;
    }

    if (params.type === "tile"
    /* TILE */
    ) {
        // handle server subdomain range if defined
        if (!(0, _utils.isEmpty)(this._serverRange)) {
          url = url.replace(/maps\./, 'maps{s}.');
        }

        url += `/${this.config.client.id}_${this.config.client.secret}/${params.layers}/{z}/{x}/{y}/${params.offset}.${params.format}`;
      } else {
      // exit if no valid location or bounds defined
      if (((0, _utils.isEmpty)(params.p) || params.p === ':auto') && (0, _utils.isEmpty)(params.bounds)) {
        console.warn(`No valid location or bounds provided for the map - p: ${params.p}; bounds: ${params.bounds}`);
        return undefined;
      }

      const b = params.bounds;
      params.loc = !(0, _utils.isEmpty)(b) ? `${b.south},${b.west},${b.north},${b.east}` : `${params.p},${params.zoom}`;
      url += `/${this.config.client.id}_${this.config.client.secret}/${params.layers}/${params.size.width}x${params.size.height}/${params.loc}/${params.offset}.${params.format}`;
    }

    return url;
  }
  /**
   * Returns a copy of the request.
   *
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  clone() {
    const request = new MapRequest(this.config);
    request.setParams(this._params);
    return request;
  }

}

var _default = MapRequest;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 136 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapMetadata = _interopRequireDefault(__webpack_require__(137));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `MapResult` object contains response information about an AMP request.
 */
class MapResult {
  /**
   * Initializes a result instance with the necessary response information.
   *
   * @param response
   * @param image
   * @param error
   * @param params
   */
  constructor(response, image, error, params = null) {
    this.response = response;
    this.image = image;
    this.error = error;
    this.params = params;

    if (response && response.headers) {
      this.metadata = new _MapMetadata.default(response.headers);
    }
  }
  /**
   * Returns the headers returned by the response, if any.
   */


  headers() {
    return this.response ? this.response.headers : undefined;
  }

}

var _default = MapResult;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 137 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

/**
 * An object that contains valid times and dates represented by a map request.
 */
class MapMetadata {
  /**
   * Creates and returns a MapMetadata instance initialized with the specified headers.
   *
   * @param {(Headers | any)} headers
   * @memberof MapMetadata
   */
  constructor(headers) {
    let valid;
    let minValid;
    let maxValid;
    let run;

    if ((0, _utils.isPlainObject)(headers)) {
      valid = headers['x-aeris-valid-date'];
      minValid = headers['x-aeris-min-valid-date'];
      maxValid = headers['x-aeris-max-valid-date'];
      run = headers['x-aeris-run-date'];
    }

    if (valid) {
      this.validDate = new Date(valid);
    }

    if (minValid) {
      this.minValidDate = new Date(minValid);
    }

    if (maxValid) {
      this.maxValidDate = new Date(maxValid);
    }

    if (run) {
      this.runDate = new Date(run);
    }
  }

}

var _default = MapMetadata;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 138 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

/**
 * A `Layer` object used to configure a single Aeris Maps layer.
 */
class Layer {
  /**
   * Initializes a layer instance with the specified AMP layer code.
   *
   * @param {string} code
   * @memberof Layer
   */
  constructor(code) {
    this._opts = {
      alpha: 100,
      darkStyle: false,
      text: false,
      largeText: false,
      metric: false,
      blendMode: undefined,
      blur: 0,
      filters: [],
      mask: undefined,
      includeText: false
    };
    this._opts.darkStyle = /-dk/.test(code);
    this._opts.text = /-text/.test(code);
    this._opts.largeText = /-lg/.test(code);
    this.code = code.replace(/-(dk|text|lg)/, '').replace(/:.+$/, '');
  }
  /**
   * Sets or returns an option value.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {(Layer|any)}
   * @memberof Layer
   */


  opt(key, value) {
    if (value) {
      (0, _utils.set)(this._opts, key, value);
      return this;
    }

    return (0, _utils.get)(this._opts, key);
  }
  /**
   * The layer configuration object.
   *
   * @param {LayerOptions} [value]
   * @returns {(Layer|LayerOptions)}
   * @memberof Layer
   */


  options(value) {
    if (value) {
      this._opts = value;
    }

    return this._opts;
  }
  /**
   * The alpha (opacity) of the layer.
   *
   * @param {number} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  alpha(value) {
    this.opt('alpha', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer should use the dark style.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  darkStyle(value) {
    this.opt('darkStyle', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer is a text layer.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  text(value) {
    this.opt('text', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer should also include its associated text layer.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  includeText(value) {
    this.opt('includeText', value);
    return this;
  }
  /**
   * A Boolean indicating whether the text layer should use large text.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  largeText(value) {
    this.opt('largeText', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer should display text values in Metric units.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  metric(value) {
    this.opt('metric', value);
    return this;
  }
  /**
   * The blend mode to apply to the layer.
   *
   * @param {string} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  blendMode(value) {
    this.opt('blendMode', value);
    return this;
  }
  /**
   * The amount to blur the layer, which is a value from `0` meaning no blur (default) to `10`.
   * The higher the value, the greater the blur effect.
   *
   * @param {number} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  blur(value) {
    this.opt('blur', value);
    return this;
  }
  /**
   * The mask layer to apply to the layer.
   *
   * @param {string} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  mask(value) {
    this.opt('mask', value);
    return this;
  }
  /**
   * Adds a filter to the layer.
   *
   * @param {string} filter
   * @returns {Layer}
   * @memberof Layer
   */


  addFilter(filter) {
    this._opts.filters.push(filter);

    return this;
  }
  /**
   * Removes a filter from the layer.
   *
   * @param {string} filter
   * @returns {Layer}
   * @memberof Layer
   */


  removeFilter(filter) {
    const index = this._opts.filters.indexOf(filter);

    if (index !== -1) {
      this._opts.filters.splice(index, 1);
    }

    return this;
  }
  /**
   * Removes all filters from the layer.
   *
   * @returns {Layer}
   * @memberof Layer
   */


  removeAllFilters() {
    this._opts.filters = [];
    return this;
  }
  /**
   * Returns the layer string based on the layer configuration.
   *
   * @returns {string}
   * @memberof Layer
   */


  toString() {
    const opts = this._opts;
    let val = this.code;
    let text;

    if (opts.includeText || opts.text) {
      text = `${val}-text`;

      if (opts.metric) {
        text = `${text}-metric`;
      }

      if (opts.largeText) {
        text = `${text}-lg`;
      }

      if (opts.text) {
        val = text;
      }
    }

    if (opts.darkStyle) {
      val = `${val}-dk`;
    }

    if (opts.alpha < 100) {
      val = `${val}:${opts.alpha}`;
    }

    if (opts.blur > 0) {
      val = `${val}:blur(${opts.blur})`;
    }

    if (opts.blendMode) {
      val = `${val}:blend(${opts.blendMode})`;
    }

    if (opts.filters.length > 0) {
      val = `${val}:${opts.filters.join(':')})`;
    }

    if (opts.includeText && text) {
      val = `${val},${text}`;
    }

    return val;
  }

}

var _default = Layer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Color = exports.colorScale = exports.mix = exports.randomColor = exports.isLight = exports.readability = exports.luminance = exports.brightness = exports.toRGB = exports.rgbToHsv = exports.rgbToHsl = exports.rgbToHex = exports.hsvToRgb = exports.hslToRgb = exports.hexToRgb = exports.isValidHex = exports.isHSV = exports.isHSL = exports.isRGB = void 0;

var _ = __webpack_require__(17);

var _math = __webpack_require__(140);

var _strings = __webpack_require__(133);

/* eslint-disable no-case-declarations */

/* eslint-disable no-multi-assign */

/**
 * Several color utility functions here are pulled from https://github.com/bgrins/TinyColor
 */
const isRGB = value => (0, _.hasKeys)(value, ['r', 'g', 'b']);

exports.isRGB = isRGB;

const isHSL = value => (0, _.hasKeys)(value, ['h', 's', 'l']);

exports.isHSL = isHSL;

const isHSV = value => (0, _.hasKeys)(value, ['h', 's', 'v']);

exports.isHSV = isHSV;

const isValidHex = hex => {
  // disable hex4 and hex8
  const lh = String(hex).charAt(0) === '#' ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh;
};
/**
 * Converts the specified hex color string to an RGB object.
 *
 * Returns `{ r, g, b }` in the set `[0, 255]`.
 *
 * @param {string} hex
 * @returns {RGB}
 */


exports.isValidHex = isValidHex;

const hexToRgb = hex => {
  hex = hex.replace(/^#/, '');
  if (!(0, _.isString)(hex) || hex.length === 0) return null;
  const color = {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  }; // eslint-disable-line object-curly-newline

  if (hex.length === 6) {
    color.r = parseInt(hex.substring(0, 2), 16);
    color.g = parseInt(hex.substring(2, 4), 16);
    color.b = parseInt(hex.substring(4), 16);
  }

  return color;
};
/**
 * Converts an HSL color value to RGB.
 *
 * Assumes `h` is contained in the set `[0, 360]` or `[0, 1]` and `s` and `l` are contained in the
 * set `[0, 100]` or `[0, 1]`.
 * Returns `{ r, g, b }` in the set `[0, 255]`.
 *
 * @param {HSL} hsl
 * @returns {RGB}
 */


exports.hexToRgb = hexToRgb;

const hslToRgb = hsl => {
  if (!isHSL(hsl)) return null;
  let r;
  let g;
  let b;
  let {
    h,
    s,
    l
  } = hsl; // eslint-disable-line object-curly-newline

  h = (0, _math.fraction)(h, 0, 360);
  s = (0, _math.fraction)(s, 0, 100);
  l = (0, _math.fraction)(l, 0, 100);

  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  };

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a: hsl.a || 1
  };
};
/**
 * Converts an HSV color value to RGB.
 *
 * Assumes `h` is contained in the set `[0, 360]` or `[0, 1]` and `s` and `v` are contained in the
 * set `[0, 100]` or `[0, 1]`.
 * Returns `{ r, g, b }` in the set `[0, 255]`.
 *
 * @param {HSV} hsv
 * @returns {RGB}
 */


exports.hslToRgb = hslToRgb;

const hsvToRgb = hsv => {
  if (!isHSV(hsv)) return null;
  let {
    h,
    s,
    v
  } = hsv; // eslint-disable-line object-curly-newline

  h = (0, _math.fraction)(h, 0, 360) * 6;
  s = (0, _math.fraction)(s, 0, 100);
  v = (0, _math.fraction)(v, 0, 100);
  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a: hsv.a || 1
  };
};
/**
 * Converts an RGB color to a hex string.
 *
 * Assumes `r`, `g`, and `b` are contained in the set `[0, 255]`.
 *
 * @param {RGB} rgb
 * @returns {string}
 */


exports.hsvToRgb = hsvToRgb;

const rgbToHex = rgb => {
  if (!isRGB(rgb)) return null;
  const parts = [rgb.r, rgb.g, rgb.b].map(x => {
    const hex = x.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  });
  return `#${parts.join('')}`;
};
/**
 * Converts an RGB color value to HSL.
 *
 * Assumes `r`, `g`, and `b` are contained in the set `[0, 255]` or `[0, 1]`.
 * Returns `{ h, s, l }` in the set `[0, 1]`.
 *
 * @param {RGB} rgb
 * @returns {HSL}
 */


exports.rgbToHex = rgbToHex;

const rgbToHsl = rgb => {
  if (!isRGB(rgb)) return null;
  let {
    r,
    g,
    b
  } = rgb; // eslint-disable-line object-curly-newline

  r = (0, _math.fraction)(r, 0, 255);
  g = (0, _math.fraction)(g, 0, 255);
  b = (0, _math.fraction)(b, 0, 255);
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  let h;
  let s;
  const l = (max + min) / 2;

  if (max === min) {
    // achromatic
    h = 0;
    s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;

      default:
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    l
  }; // eslint-disable-line object-curly-newline
};
/**
 * Converts an RGB color value to HSV.
 *
 * Assumes `r`, `g`, and `b` are contained in the set `[0, 255]` or `[0, 1]`.
 * Returns `{ h, s, v }` in the set `[0, 1]`.
 *
 * @param {RGB} rgb
 * @returns {HSV}
 */


exports.rgbToHsl = rgbToHsl;

const rgbToHsv = rgb => {
  if (!isRGB(rgb)) return null;
  let {
    r,
    g,
    b
  } = rgb; // eslint-disable-line object-curly-newline

  r = (0, _math.fraction)(r, 0, 255);
  g = (0, _math.fraction)(g, 0, 255);
  b = (0, _math.fraction)(b, 0, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h;
  const v = max;
  const d = max - min;
  const s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;

      default:
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    v
  }; // eslint-disable-line object-curly-newline
};
/**
 * Given a string or object, convert that input to RGB.
 *
 * @param {*} value
 * @returns {RGB}
 */


exports.rgbToHsv = rgbToHsv;

const toRGB = value => {
  if (isRGB(value)) {
    return value;
  }

  if (isHSL(value)) {
    return hslToRgb(value);
  }

  if (isHSV(value)) {
    return hsvToRgb(value);
  }

  if ((0, _.isString)(value)) {
    const m = /^(rgb|hsl|hsv)a?\((\d+),\s*([\d%]+),\s*([\d%]+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.exec(`${value}`);

    if (m && m.length >= 5) {
      const type = m[1];
      const alpha = (0, _.isset)(m[5]) ? parseFloat(m[5]) : 1;
      const p = m.slice(2, 5).map(v => (0, _strings.isPercentage)(v) ? v : parseInt(v, 10));

      if (type === 'rgb' || type === 'rgba') {
        return {
          r: (0, _math.clamp)(p[0], 0, 255),
          g: (0, _math.clamp)(p[1], 0, 255),
          b: (0, _math.clamp)(p[2], 0, 255),
          a: alpha
        };
      }

      if (type === 'hsl') {
        const hsl = {
          h: p[0],
          s: p[1],
          l: p[2],
          a: alpha
        };
        return hslToRgb(hsl);
      }

      if (type === 'hsv') {
        const hsv = {
          h: p[0],
          s: p[1],
          v: p[2],
          a: alpha
        };
        return hsvToRgb(hsv);
      }
    } else {
      return hexToRgb(value);
    }
  }

  return null;
};
/**
 * Returns the brightness of the specified color value.
 *
 * The value for `color` can either be a color string or an RGB, HSV or HSL object.
 *
 * @param {*} color
 * @returns {number}
 */


exports.toRGB = toRGB;

const brightness = color => {
  const rgb = toRGB(color);
  return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
};
/**
 * Returns the luminance of the specified color value.
 *
 * The value for `color` can either be a color string or an RGB, HSV or HSL object.
 *
 * @param {string | RGB} color
 * @returns {number}
 */


exports.brightness = brightness;

const luminance = color => {
  const rgb = toRGB(color);
  if (!rgb) return null;
  return 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;
};
/**
 * Analyze the two colors and return the color contrast defined by WCAG version 2.
 *
 * @param {*} color1
 * @param {*} color2
 * @returns {number}
 */


exports.luminance = luminance;

const readability = (color1, color2) => {
  const c1 = toRGB(color1);
  const c2 = toRGB(color2);
  return (Math.max(luminance(c1), luminance(c2)) + 0.05) / (Math.min(luminance(c1), luminance(c2)) + 0.05);
};
/**
 * Returns whether the specified color is light based on its luminance.
 *
 * The value for `color` can either be a color string or an RGB, HSV or HSL object.
 *
 * @param {string | Color} color
 * @returns {boolean}
 */


exports.readability = readability;

const isLight = color => {
  const lum = luminance(color);
  return lum && lum >= 140;
};
/**
 * Returns a random color as RGB.
 *
 * @returns {RGB}
 */


exports.isLight = isLight;

const randomColor = () => ({
  r: (0, _math.random)(0, 255),
  g: (0, _math.random)(0, 255),
  b: (0, _math.random)(0, 255),
  a: 1
});
/**
 * Returns a new color as RGB by linearly interpolating between two color values.
 *
 * @param {*} start	Starting color value
 * @param {*} end Ending color value
 * @param {number} ratio Value to use to interpolate between in the set `[0, 1]`
 * @returns {RGB}
 */


exports.randomColor = randomColor;

const mix = (start, end, ratio) => {
  start = toRGB(start);
  end = toRGB(end);
  if (!(0, _.isset)(start) || !(0, _.isset)(end)) return null;
  const sc = start;
  const ec = end;
  const r = (0, _math.lerp)(sc.r, ec.r, ratio);
  const g = (0, _math.lerp)(sc.g, ec.g, ratio);
  const b = (0, _math.lerp)(sc.b, ec.b, ratio);
  const a = (0, _math.lerp)(sc.a, ec.a, ratio);
  return {
    r: Math.round(r),
    g: Math.round(g),
    b: Math.round(b),
    a
  };
};
/**
 * Generates an array of linearly interpolated color values defined by starting and ending color
 * values and the total number of color stops, or steps, in the scale.
 *
 * @param {(RGB | string)} start
 * @param {(RGB | string)} end
 * @param {number} steps
 * @returns {RGB[]}
 */


exports.mix = mix;

const colorScale = (start, end, steps) => {
  const delta = 1 / (steps - 1);
  const scale = [];

  for (let i = 0; i < steps; i += 1) {
    const color = mix(start, end, delta * i);
    scale.push(color);
  }

  return scale;
};
/**
 * A convenience class for working with and manipulating colors.
 *
 * @export
 * @class Color
 */


exports.colorScale = colorScale;

class Color {
  constructor(value) {
    this._rgb = toRGB(value);
  }
  /**
   * Returns the color's red value in the set `[0, 255]`.
   *
   * @type {number}
   * @memberof Color
   */


  get red() {
    return this._rgb.r;
  }
  /**
   * Sets the color's red value, which must be in the set `[0, 255]`.
   *
   * @memberof Color
   */


  set red(value) {
    this._rgb.r = value;
  }
  /**
   * Returns the color's green value in the set `[0, 255]`.
   *
   * @type {number}
   * @memberof Color
   */


  get green() {
    return this._rgb.g;
  }
  /**
   * Sets the color's green value, which must be in the set `[0, 255]`.
   *
   * @memberof Color
   */


  set green(value) {
    this._rgb.g = value;
  }
  /**
   * Returns the color's blue value in the set `[0, 255]`.
   *
   * @type {number}
   * @memberof Color
   */


  get blue() {
    return this._rgb.b;
  }
  /**
   * Sets the color's blue value, which must be in the set `[0, 255]`.
   *
   * @memberof Color
   */


  set blue(value) {
    this._rgb.b = value;
  }
  /**
   * Returns the color's alpha value in the set `[0, 1]`.
   *
   * @type {number}
   * @memberof Color
   */


  get alpha() {
    return this._rgb.a;
  }
  /**
   * Sets the color's alpha value, which must be in the set `[0, 1]`.
   *
   * @memberof Color
   */


  set alpha(value) {
    this._rgb.a = (0, _math.clamp)(value, 0, 1);
  }
  /**
   * Returns whether the color is light based on its luminance.
   *
   * @returns {boolean}
   * @memberof Color
   */


  isLight() {
    return isLight(this._rgb);
  }
  /**
   * Returns whether the color is dark based on its luminance.
   *
   * @returns {boolean}
   * @memberof Color
   */


  isDark() {
    return !this.isLight();
  }
  /**
   * Returns the brightness of the color.
   *
   * @returns {number}
   * @memberof Color
   */


  brightness() {
    return brightness(this._rgb);
  }
  /**
   * Returns the luminance of the color.
   *
   * @returns {number}
   * @memberof Color
   */


  luminance() {
    return luminance(this._rgb);
  }
  /**
   * Increases the lightness of the color by a specified percentage.
   *
   * @param {number} amount
   * @memberof Color
   */


  lighten(percent = 10) {
    percent = (0, _math.clamp)(percent, 0, 100);
    const hsl = this.toHsl();
    let lightness = parseFloat(`${hsl.l}`);
    lightness += percent;
    hsl.l = (0, _math.clamp)(lightness, 0, 1);
    return toRGB(hsl);
  }
  /**
   * Brightens the color by a specified percentage.
   *
   * @param {number} percent
   * @memberof Color
   */


  brighten(percent = 10) {
    percent = (0, _math.clamp)(percent, 0, 100);
    const rgb = this._rgb;
    this.red = (0, _math.clamp)(rgb.r - Math.round(255 * -percent), 0, 255);
    this.green = (0, _math.clamp)(rgb.g - Math.round(255 * -percent), 0, 255);
    this.blue = (0, _math.clamp)(rgb.b - Math.round(255 * -percent), 0, 255);
  }
  /**
   * Darkens the color by a specified percentage.
   *
   * @param {number} percent
   * @memberof Color
   */


  darken(percent = 10) {
    percent = (0, _math.clamp)(percent, 0, 100);
    const hsl = this.toHsl();
    let lightness = parseFloat(`${hsl.l}`);
    lightness -= percent;
    hsl.l = (0, _math.clamp)(lightness, 0, 1);
    return toRGB(hsl);
  }
  /**
   * Returns the hex value for the color.
   *
   * @returns {string}
   * @memberof Color
   */


  toHex() {
    return rgbToHex(this._rgb);
  }
  /**
   * Returns the HSL (hue, saturation, lightness) for the color.
   *
   * @returns {HSL}
   * @memberof Color
   */


  toHsl() {
    return rgbToHsl(this._rgb);
  }
  /**
   * Returns the HSV (hue, saturation, value) for the color.
   *
   * @returns {HSV}
   * @memberof Color
   */


  toHsv() {
    return rgbToHsv(this._rgb);
  }
  /**
   * Returns a string representation of the color in the specified format.
   *
   * @param {string} [format]
   * @returns {string}
   * @memberof Color
   */


  toString(format) {
    format = format || 'hex';
    const rgb = this._rgb;
    let formatted = null;

    switch (format) {
      case 'rgb':
        if (rgb.a === 1) {
          formatted = `rgb("${rgb.r}", "${rgb.g}", "${rgb.b}")`;
        } else {
          formatted = `rgba("${rgb.r}", "${rgb.g}", "${rgb.b}", "${rgb.a}")`;
        }

        break;

      case 'hex':
        formatted = rgbToHex(rgb);
        break;

      case 'hsl':
        const hsl = rgbToHsl(rgb);

        if (hsl) {
          if (rgb.a === 1) {
            formatted = `hsl(
							"${Math.round(hsl.h * 360)}",
							"${(0, _strings.isPercentage)(hsl.s) ? hsl.s : Math.round(hsl.s * 100)}%",
							"${(0, _strings.isPercentage)(hsl.l) ? hsl.l : Math.round(hsl.l * 100)}%"
						)`;
          } else {
            formatted = `hsla(
							"${Math.round(hsl.h * 360)}",
							"${(0, _strings.isPercentage)(hsl.s) ? hsl.s : Math.round(hsl.s * 100)}%",
							"${(0, _strings.isPercentage)(hsl.l) ? hsl.l : Math.round(hsl.l * 100)}%",
							"${this.alpha}"
						)`;
          }
        }

        break;

      case 'hsv':
        const hsv = rgbToHsv(rgb);

        if (hsv) {
          if (rgb.a === 1) {
            formatted = `hsv(
							"${Math.round(hsv.h * 360)}",
							"${(0, _strings.isPercentage)(hsv.s) ? hsv.s : Math.round(hsv.s * 100)}%",
							"${(0, _strings.isPercentage)(hsv.v) ? hsv.v : Math.round(hsv.v * 100)}%"
						)`;
          } else {
            formatted = `hsva(
							"${Math.round(hsv.h * 360)}",
							"${(0, _strings.isPercentage)(hsv.s) ? hsv.s : Math.round(hsv.s * 100)}%",
							"${(0, _strings.isPercentage)(hsv.v) ? hsv.v : Math.round(hsv.v * 100)}%",
							"${this.alpha}"
						)`;
          }
        }

        break;

      default:
        break;
    }

    return formatted.replace(/"/g, '').replace(/[\s\n]/g, '').split(',').join(', ');
  }

}

exports.Color = Color;

/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.geoDistance = exports.radToDeg = exports.degToRad = exports.random = exports.fraction = exports.wrap = exports.clamp = exports.lerp = void 0;

var _strings = __webpack_require__(133);

/**
 * Linearly interpolate between two values.
 *
 * @param {number} a Start value of the range
 * @param {number} b End value of the range
 * @param {number} fraction Weight value used to interpolate between `a` and `b`.
 * @returns {number}
 */
const lerp = (a, b, fraction) => (b - a) * fraction + a;
/**
 * Constrain a value to lie between two values.
 *
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */


exports.lerp = lerp;

const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
/**
 * Wraps a value so that it's within the specified range.
 *
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */


exports.clamp = clamp;

const wrap = (value, min, max) => {
  const range = max - min;
  return min + ((value - min) % range + range) % range;
};
/**
 * Takes a value from `[min, max]` and returns it as `[0, 1]`.
 *
 * @param {(number | string)} value
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */


exports.wrap = wrap;

const fraction = (value, min, max) => {
  const isPercent = (0, _strings.isPercentage)(value);
  const delta = max - min;
  value = clamp(parseFloat(`${value}`), min, max); // process percentage value

  if (isPercent) {
    value = parseInt(`${value * max}`, 10) / 100;
  } // handle floating point rounding errors


  if (Math.abs(value - max) < 0.000001) {
    return 1;
  } // convert into [0, 1] range if it isn't already


  return value % delta / delta;
};

exports.fraction = fraction;

const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

exports.random = random;

const degToRad = degrees => degrees * Math.PI / 180;

exports.degToRad = degToRad;

const radToDeg = radians => radians * 180 / Math.PI;

exports.radToDeg = radToDeg;

const geoDistance = (coord1, coord2) => {
  if (coord1.lat === coord2.lat && coord1.lon === coord2.lon) {
    return 0;
  } // const radlat1 = (Math.PI * coord1.lat) / 180;
  // const radlat2 = (Math.PI * coord2.lat) / 180;
  // const theta = coord1.lon - coord2.lon;
  // const radtheta = (Math.PI * theta) / 180;
  // let dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
  // if (dist > 1) {
  // 	dist = 1;
  // }
  // dist = Math.acos(dist);
  // dist = (dist * 180) / Math.PI;
  // dist = dist * 60 * 1.1515;
  // dist *= 1.609344; // convert miles to km


  const R = 6371e3; // R is earths radius
  // const lat1 = 23.18489670753479; // starting point lat
  // const lat2 = 32.726601;         // ending point lat
  // const lon1 = 72.62524545192719; // starting point lon
  // const lon2 = 74.857025;         // ending point lon
  // const lat1radians = toRadians(lat1);
  // const lat2radians = toRadians(lat2);
  // const latRadians = toRadians(lat2-lat1);
  // const lonRadians = toRadians(lon2-lon1);

  const radlat1 = degToRad(coord1.lat);
  const radlat2 = degToRad(coord2.lat);
  const latRadians = degToRad(coord2.lat - coord1.lat);
  const lonRadians = degToRad(coord2.lon - coord1.lon);
  const a = Math.sin(latRadians / 2) * Math.sin(latRadians / 2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.sin(lonRadians / 2) * Math.sin(lonRadians / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const dist = R * c;
  return dist;
};

exports.geoDistance = geoDistance;

/***/ }),
/* 141 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _domtastic = _interopRequireDefault(__webpack_require__(142));

var _strings = __webpack_require__(133);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// / <reference path="./domtastic.d.ts" />
function _getStyle(target, prop) {
  let value;
  const defaultView = target.ownerDocument.defaultView; // W3C standard method

  if (defaultView && defaultView.getComputedStyle) {
    // sanitize property name to css notation (hyphen separate words)
    prop = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
    return defaultView.getComputedStyle(target, null).getPropertyValue(prop);
  } // IE method


  if (target.currentStyle) {
    // sanitize property name to camelCase
    prop = prop.replace(/\-(\w)/g, (str, letter) => letter.toUpperCase());
    value = target.currentStyle[prop]; // convert other units to pixels in IE

    if (/^\d+(em|pt|%|ex)?$/i.test(value)) {
      return (value => {
        const oldLeft = target.style.left;
        const oldRsLeft = target.runtimeStyle.left;
        target.runtimeStyle.left = target.currentStyle.left;
        target.style.left = value || 0;
        value = `${target.style.pixelLeft}px`;
        target.style.left = oldLeft;
        target.runtimeStyle.left = oldRsLeft;
        return value;
      })(value);
    }
  }

  return value;
}

function _toNumber(str) {
  return parseFloat((str || '').replace(/[^0-9\.-]/, ''));
}

const _defaultDisplayMap = {};
const _elementDisplayMap = {};

function _storeDisplay(element) {
  const display = _getStyle(element, 'display');

  if (display && display !== 'none') {
    _elementDisplayMap[element] = display;
  }
}

function _getDefaultDisplay(element) {
  const nodeName = element.nodeName;
  let display = _elementDisplayMap[element];

  if (!display) {
    display = _defaultDisplayMap[nodeName];
  }

  if (display) {
    return display;
  }

  const doc = element.ownerDocument;
  const temp = doc.body.appendChild(doc.createElement(nodeName));
  display = _getStyle(temp, 'display');
  temp.parentNode.removeChild(temp);

  if (display === 'none') {
    display = 'block';
  }

  _defaultDisplayMap[nodeName] = display || 'block';
  return display;
}

function _matches(el, selector) {
  const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

  if (matchesSelector) {
    return matchesSelector.call(el, selector);
  }

  return false;
}

function _clone(fn) {
  const temp = function temporary(...args) {
    return fn.apply(this, args);
  };

  for (const key in this) {
    if (fn.hasOwnProperty(key)) {
      temp[key] = fn[key];
    }
  }

  return temp;
}

;

const dataClone = _clone(_domtastic.default.fn.data); // extend DOMtastic API


_domtastic.default.fn.show = function () {
  this.each((el, i) => {
    el.style.display = _getDefaultDisplay(el);
  });
};

_domtastic.default.fn.hide = function () {
  this.each((el, i) => {
    _storeDisplay(el);

    el.style.display = 'none';
  });
};

_domtastic.default.fn.prev = function (selector) {
  let node = this[0]; // eslint-disable-line react/no-this-in-sfc

  while (node = node.previousSibling) {
    const el = node;

    if (node.nodeType === 1 && _matches(el, selector)) {
      return (0, _domtastic.default)(el);
    }
  }

  return null;
};

_domtastic.default.fn.next = function (selector) {
  let node = this[0];

  while (node = node.nextSibling) {
    const el = node;

    if (node.nodeType === 1 && _matches(el, selector)) {
      return (0, _domtastic.default)(el);
    }
  }

  return null;
};

_domtastic.default.fn.last = function () {
  const len = this.length;

  if (len > 0) {
    return (0, _domtastic.default)(this[len - 1]);
  } // return this.slice.call(len - 1, 1);


  return (0, _domtastic.default)([]);
};

_domtastic.default.fn.parents = function (selector) {
  const nodes = [];
  this.each(el => {
    while (el) {
      if (_matches(el, selector)) {
        nodes.push(el);
        break;
      } else {
        el = el.parentNode;
      }
    }
  });
  return (0, _domtastic.default)(nodes);
};

_domtastic.default.fn.replace = function (element) {
  if (typeof element === 'string') {
    const content = element.replace(/^[^<]+/, '').replace(/[\n\r\t.]+$/, '');
    element = (0, _domtastic.default)(content)[0];
  }

  if (element instanceof Node) {
    if (this instanceof Node) {
      this.replaceWith(element);
      return (0, _domtastic.default)(element);
    }

    const collection = [];
    this.each(el => {
      el.replaceWith(element);
      collection.push(element);
    });
    return (0, _domtastic.default)(collection);
  }

  return (0, _domtastic.default)([]);
};

_domtastic.default.fn.contains = function (element) {
  const node = this[0]; // eslint-disable-line react/no-this-in-sfc

  if (typeof element === 'string') {
    element = document.querySelector(element);
  } else if (element[0]) {
    element = element[0];
  }

  return node.contains(element);
};

_domtastic.default.fn.width = function (value) {
  if (value === undefined) {
    const el = this[0];
    if (!el) return null;
    return el.offsetWidth;
  }

  return this.each(el => {
    el.style.width = `${value}px`;
  });
};

_domtastic.default.fn.outerWidth = function (margins = false) {
  const el = this[0];
  if (!el) return null;
  let value = el.offsetWidth; // borders

  value += _toNumber(_getStyle(el, 'border-left-width')) + _toNumber(_getStyle(el, 'border-right-width')); // margins

  if (margins) {
    value += _toNumber(_getStyle(el, 'margin-left')) + _toNumber(_getStyle(el, 'margin-right'));
  }

  return value;
};

_domtastic.default.fn.height = function (value) {
  if (value === undefined) {
    const el = this[0];
    if (!el) return null;
    return el.offsetHeight;
  }

  return this.each(el => {
    el.style.height = `${value}px`;
  });
};

_domtastic.default.fn.outerHeight = function (margins = false) {
  const el = this[0];
  if (!el) return null;
  let value = el.offsetHeight; // borders

  value += _toNumber(_getStyle(el, 'border-top-width')) + _toNumber(_getStyle(el, 'border-bottom-width')); // margins

  if (margins) {
    value += _toNumber(_getStyle(el, 'margin-top')) + _toNumber(_getStyle(el, 'margin-bottom'));
  }

  return value;
};

_domtastic.default.fn.padding = function () {
  const el = this[0];
  return {
    top: _toNumber(_getStyle(el, 'padding-top')),
    right: _toNumber(_getStyle(el, 'padding-right')),
    bottom: _toNumber(_getStyle(el, 'padding-bottom')),
    left: _toNumber(_getStyle(el, 'padding-left'))
  };
};

_domtastic.default.fn.margins = function () {
  const el = this[0];
  return {
    top: _toNumber(_getStyle(el, 'margin-top')),
    right: _toNumber(_getStyle(el, 'margin-right')),
    bottom: _toNumber(_getStyle(el, 'margin-bottom')),
    left: _toNumber(_getStyle(el, 'margin-left'))
  };
};

_domtastic.default.fn.borders = function () {
  const el = this[0];
  return {
    top: _toNumber(_getStyle(el, 'border-top-width')),
    right: _toNumber(_getStyle(el, 'border-right-width')),
    bottom: _toNumber(_getStyle(el, 'border-bottom-width')),
    left: _toNumber(_getStyle(el, 'border-left-width'))
  };
};

_domtastic.default.fn.bounds = function (absolute = false, relative = null) {
  const el = this[0];
  const b = {};
  const rect = el.getBoundingClientRect();

  if (rect) {
    b.x = rect.x;
    b.y = rect.y;
    b.width = rect.width;
    b.height = rect.height;
    b.top = rect.top;
    b.left = rect.left;
    b.right = rect.right;
    b.bottom = rect.bottom;
  }

  if (absolute) {
    const scrollX = window.scrollX || window.pageXOffset;
    const scrollY = window.scrollY || window.pageYOffset;
    if (b.left) b.left += scrollX;
    if (b.top) b.top += scrollY;
    if (b.right) b.right += scrollX;
    if (b.bottom) b.bottom += scrollY;
    if (b.x) b.x += scrollX;
    if (b.y) b.y += scrollY;
  }

  if (relative) {
    const rb = (0, _domtastic.default)(relative).bounds(absolute);
    if (b.left) b.left -= rb.left;
    if (b.top) b.top -= rb.top;
    if (b.right) b.right = b.left + b.width;
    if (b.bottom) b.bottom = b.top + b.height;
    if (b.x) b.x -= rb.x;
    if (b.y) b.y -= rb.y;
  }

  return b;
};

_domtastic.default.fn.scroll = function () {
  const el = this[0];
  const pos = {
    top: 0,
    left: 0
  };

  if (el === window) {
    pos.top = window.pageYOffset || document.documentElement.scrollTop;
    pos.left = window.pageXOffset || document.documentElement.scrollLeft;
  } else {
    pos.top = el.scrollTop;
    pos.left = el.scrollLeft;
  }

  return pos;
};

_domtastic.default.fn.allData = function (key, value) {
  if (!key) return;
  if (this.length === 0) return;

  if (typeof key === 'string' && typeof value === 'undefined') {
    let val = this.data(key, value);

    if (!val && /-/.test(key)) {
      val = this.data((0, _strings.camelcase)(key), value);
    }

    if (!val) {
      const name = `data-${key.replace(/[A-Z]/g, '-$&').toLowerCase()}`;
      val = this[0].getAttribute(name); // set data value so it isn't changed later

      if (val) {
        if (val === 'true') {
          val = true;
        } else if (val === 'false') {
          val = false;
        } else if (val === 'null') {
          val = null;
        } // try to convert to a number if string doesn't change


        if (val === `${+val}`) {
          val = +val;
        } // convert to an object if needed


        if (/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/.test(val)) {
          try {
            val = JSON.parse(val);
          } catch (e) {
            console.error('[Aeris] Failed parsing JSON string to object', e);
          }
        }

        key = (0, _strings.camelcase)(key);
        this.data(key, val);
      }
    }

    return val;
  }

  if (/-/.test(key)) {
    key = (0, _strings.camelcase)(key);
  }

  this.data(key, value);
};

_domtastic.default.fn.click = function () {
  this.each(el => {
    el.click();
  });
};

_domtastic.default.fn.focus = function () {
  this.each(el => {
    if (el instanceof HTMLInputElement) {
      el.focus();
    }
  });
};

_domtastic.default.fn.blur = function () {
  this.each(el => {
    if (el instanceof HTMLInputElement) {
      el.blur();
    }
  });
};

var _default = _domtastic.default;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(144);
/* harmony import */ var _baseClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(146);
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(147);
/* harmony import */ var _dom_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(148);
/* harmony import */ var _dom_attr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(149);
/* harmony import */ var _dom_class__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(150);
/* harmony import */ var _dom_contains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(151);
/* harmony import */ var _dom_data__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(152);
/* harmony import */ var _dom_extra__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(153);
/* harmony import */ var _dom_html__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(154);
/* harmony import */ var _event_index__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(155);
/* harmony import */ var _event_trigger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(157);
/* harmony import */ var _event_ready__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(158);
/* harmony import */ var _noconflict__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(159);
/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(145);
/* harmony import */ var _selector_closest__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(156);
/* harmony import */ var _selector_extra__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(160);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(161);
/**
 * @module API
 */



const api = {};
let $ = {};

// Import modules to build up the API




















if(typeof _selector_index__WEBPACK_IMPORTED_MODULE_15__ !== 'undefined') {
  $ = _selector_index__WEBPACK_IMPORTED_MODULE_15__.$;
  $.matches = _selector_index__WEBPACK_IMPORTED_MODULE_15__.matches;
  api.find = _selector_index__WEBPACK_IMPORTED_MODULE_15__.find;
}

(0,_util__WEBPACK_IMPORTED_MODULE_0__.extend)($, _dom_contains__WEBPACK_IMPORTED_MODULE_7__, _noconflict__WEBPACK_IMPORTED_MODULE_14__, _type__WEBPACK_IMPORTED_MODULE_18__);
(0,_util__WEBPACK_IMPORTED_MODULE_0__.extend)(api, _array__WEBPACK_IMPORTED_MODULE_1__, _css__WEBPACK_IMPORTED_MODULE_3__, _dom_attr__WEBPACK_IMPORTED_MODULE_5__, _dom_index__WEBPACK_IMPORTED_MODULE_4__, _dom_class__WEBPACK_IMPORTED_MODULE_6__, _dom_data__WEBPACK_IMPORTED_MODULE_8__, _dom_extra__WEBPACK_IMPORTED_MODULE_9__, _dom_html__WEBPACK_IMPORTED_MODULE_10__, _event_index__WEBPACK_IMPORTED_MODULE_11__, _event_trigger__WEBPACK_IMPORTED_MODULE_12__, _event_ready__WEBPACK_IMPORTED_MODULE_13__, _selector_closest__WEBPACK_IMPORTED_MODULE_16__, _selector_extra__WEBPACK_IMPORTED_MODULE_17__);

$.fn = api;

// Version

$.version = '__VERSION__';

// Util

$.extend = _util__WEBPACK_IMPORTED_MODULE_0__.extend;

// Provide base class to extend from

if(typeof _baseClass__WEBPACK_IMPORTED_MODULE_2__["default"] !== 'undefined') {
  $.BaseClass = (0,_baseClass__WEBPACK_IMPORTED_MODULE_2__["default"])($.fn);
}

// Export interface

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($);


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "each": () => (/* binding */ each),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "uniq": () => (/* binding */ uniq),
/* harmony export */   "win": () => (/* binding */ win)
/* harmony export */ });
/*
 * @module Util
 */

/*
 * Reference to the window object
 * @private
 */

const win = typeof window !== 'undefined' ? window : {};

/**
 * Convert `NodeList` to `Array`.
 *
 * @param {NodeList|Array} collection
 * @return {Array}
 * @private
 */

const toArray = collection => {
  const length = collection.length;
  const result = new Array(length);
  for(let i = 0; i < length; i++) {
    result[i] = collection[i];
  }
  return result;
};

/**
 * Faster alternative to [].forEach method
 *
 * @param {Node|NodeList|Array} collection
 * @param {Function} callback
 * @return {Node|NodeList|Array}
 * @private
 */

const each = (collection, callback, thisArg) => {
  const length = collection.length;
  if(length !== undefined && collection.nodeType === undefined) {
    for(let i = 0; i < length; i++) {
      callback.call(thisArg, collection[i], i, collection);
    }
  } else {
    callback.call(thisArg, collection, 0, collection);
  }
  return collection;
};

/**
 * Assign enumerable properties from source object(s) to target object
 *
 * @method extend
 * @param {Object} target Object to extend
 * @param {Object} [source] Object to extend from
 * @return {Object} Extended object
 * @example
 *     $.extend({a: 1}, {b: 2}); // {a: 1, b: 2}
 * @example
 *     $.extend({a: 1}, {b: 2}, {a: 3}); // {a: 3, b: 2}
 */

const extend = (target, ...sources) => {
  sources.forEach(src => {
    for(let prop in src) {
      target[prop] = src[prop];
    }
  });
  return target;
};

/**
 * Return the collection without duplicates
 *
 * @param collection Collection to remove duplicates from
 * @return {Node|NodeList|Array}
 * @private
 */

const uniq = collection => collection.filter((item, index) => collection.indexOf(item) === index);


/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "each": () => (/* binding */ each),
/* harmony export */   "every": () => (/* binding */ every),
/* harmony export */   "filter": () => (/* binding */ filter),
/* harmony export */   "forEach": () => (/* binding */ forEach),
/* harmony export */   "indexOf": () => (/* binding */ indexOf),
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "pop": () => (/* binding */ pop),
/* harmony export */   "push": () => (/* binding */ push),
/* harmony export */   "reduce": () => (/* binding */ reduce),
/* harmony export */   "reduceRight": () => (/* binding */ reduceRight),
/* harmony export */   "reverse": () => (/* binding */ reverse),
/* harmony export */   "shift": () => (/* binding */ shift),
/* harmony export */   "some": () => (/* binding */ some),
/* harmony export */   "unshift": () => (/* binding */ unshift)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(145);
/**
 * @module Array
 */




const ArrayProto = Array.prototype;

/**
 * Checks if the given callback returns a true(-ish) value for each element in the collection.
 *
 * @param {Function} callback Function to execute for each element, invoked with `element` as argument.
 * @param {Object} [thisArg] Value to use as `this` when executing `callback`.
 * @return {Boolean} Whether each element passed the callback check.
 * @example
 *     // Test whether every element in the collection has the "active" attribute
 *     $('.items').every(function(element) {
 *         return element.hasAttribute('active')
 *     });
 */

const every = ArrayProto.every;

/**
 * Filter the collection by selector or function, and return a new collection with the result.
 *
 * @param {String|Function} selector Selector or function to filter the collection.
 * @param {Object} [thisArg] Value to use as `this` when executing `callback`.
 * @return {Object} A new wrapped collection
 * @chainable
 * @example
 *     $('.items').filter('.active');
 * @example
 *     $('.items').filter(function(element) {
 *         return element.hasAttribute('active')
 *     });
 */

const filter = function(selector, thisArg) {
  const callback = typeof selector === 'function' ? selector : element => (0,_selector_index__WEBPACK_IMPORTED_MODULE_1__.matches)(element, selector);
  return (0,_selector_index__WEBPACK_IMPORTED_MODULE_1__.$)(ArrayProto.filter.call(this, callback, thisArg));
};

/**
 * Execute a function for each element in the collection.
 *
 * @param {Function} callback Function to execute for each element, invoked with `element` as argument.
 * @param {Object} [thisArg] Value to use as `this` when executing `callback`.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.items').forEach(function(element) {
 *         element.style.color = 'evergreen';
 *     );
 */

const forEach = function(callback, thisArg) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, callback, thisArg);
};

const each = forEach;

/**
 * Returns the index of an element in the collection.
 *
 * @param {Node} element
 * @return {Number} The zero-based index, -1 if not found.
 * @example
 *     $('.items').indexOf(element); // 2
 */

const indexOf = ArrayProto.indexOf;

/**
 * Create a new collection by executing the callback for each element in the collection.
 *
 * @param {Function} callback Function to execute for each element, invoked with `element` as argument.
 * @param {Object} [thisArg] Value to use as `this` when executing `callback`.
 * @return {Array} Collection with the return value of the executed callback for each element.
 * @example
 *     // Create a new array with the attribute value of each element:
 *     $('.items').map(function(element) {
 *         return element.getAttribute('name')
 */

const map = ArrayProto.map;

/**
 * Removes the last element from the collection, and returns that element.
 *
 * @return {Object} The last element from the collection.
 * @example
 *     var lastElement = $('.items').pop();
 */

const pop = ArrayProto.pop;

/**
 * Adds one or more elements to the end of the collection, and returns the new length of the collection.
 *
 * @param {Object} element Element(s) to add to the collection
 * @return {Number} The new length of the collection
 * @example
 *     $('.items').push(element);
 */

const push = ArrayProto.push;

/**
 * Apply a function against each element in the collection, and this accumulator function has to reduce it
 * to a single value.
 *
 * @param {Function} callback Function to execute on each value in the array, taking four arguments (see example).
 * @param {Mixed} initialValue Object to use as the first argument to the first call of the callback.
 * @example
 *     // Calculate the combined height of elements:
 *     $('.items').reduce(function(previousValue, element, index, collection) {
 *         return previousValue + element.clientHeight;
 *     }, 0);
 */

const reduce = ArrayProto.reduce;

/**
 * Apply a function against each element in the collection (from right-to-left), and this accumulator function has
 * to reduce it to a single value.
 *
 * @param {Function} callback Function to execute on each value in the array, taking four arguments (see example).
 * @param {Mixed} initialValue Object to use as the first argument to the first call of the callback.
 * @example
 *     // Concatenate the text of elements in reversed order:
 *     $('.items').reduceRight(function(previousValue, element, index, collection) {
 *         return previousValue + element.textContent;
 *     }, '');
 */

const reduceRight = ArrayProto.reduceRight;

/**
 * Reverses an array in place. The first array element becomes the last and the last becomes the first.
 *
 * @return {Object} The wrapped collection, reversed
 * @chainable
 * @example
 *     $('.items').reverse();
 */

const reverse = function() {
  return (0,_selector_index__WEBPACK_IMPORTED_MODULE_1__.$)((0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(this).reverse());
};

/**
 * Removes the first element from the collection, and returns that element.
 *
 * @return {Object} The first element from the collection.
 * @example
 *     var firstElement = $('.items').shift();
 */

const shift = ArrayProto.shift;

/**
 * Checks if the given callback returns a true(-ish) value for any of the elements in the collection.
 *
 * @param {Function} callback Function to execute for each element, invoked with `element` as argument.
 * @return {Boolean} Whether any element passed the callback check.
 * @example
 *     $('.items').some(function(element) {
 *         return element.hasAttribute('active')
 *     }); // true/false
 */

const some = ArrayProto.some;

/**
 * Adds one or more elements to the beginning of the collection, and returns the new length of the collection.
 *
 * @param {Object} element Element(s) to add to the collection
 * @return {Number} The new length of the collection
 * @example
 *     $('.items').unshift(element);
 */

const unshift = ArrayProto.unshift;


/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ $),
/* harmony export */   "DOMtastic": () => (/* binding */ DOMtastic),
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "matches": () => (/* binding */ matches)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module Selector
 */



let isPrototypeSet = false;

const reFragment = /^\s*<(\w+|!)[^>]*>/;
const reSingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
const reSimpleSelector = /^[.#]?[\w-]*$/;

/*
 * Versatile wrapper for `querySelectorAll`.
 *
 * @param {String|Node|NodeList|Array} selector Query selector, `Node`, `NodeList`, array of elements, or HTML fragment string.
 * @param {String|Node|NodeList} context=document The context for the selector to query elements.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     var $items = $(.items');
 * @example
 *     var $element = $(domElement);
 * @example
 *     var $list = $(nodeList, document.body);
 * @example
 *     var $element = $('<p>evergreen</p>');
 */

const domtastic = function domtastic(selector, context = document) {

  let collection;

  if(!selector) {

    collection = document.querySelectorAll(null);

  } else if(selector instanceof DOMtastic) {

    return selector;

  } else if(typeof selector !== 'string') {

    collection = selector.nodeType || selector === window ? [selector] : selector;

  } else if(reFragment.test(selector)) {

    collection = createFragment(selector);

  } else {

    context = typeof context === 'string' ? document.querySelector(context) : context.length ? context[0] : context;

    collection = querySelector(selector, context);

  }

  return wrap(collection);

};

const $ = domtastic;

/*
 * Find descendants matching the provided `selector` for each element in the collection.
 *
 * @param {String|Node|NodeList|Array} selector Query selector, `Node`, `NodeList`, array of elements, or HTML fragment string.
 * @return {Object} The wrapped collection
 * @example
 *     $('.selector').find('.deep').$('.deepest');
 */

const find = function(selector) {
  const nodes = [];
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, node => (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(querySelector(selector, node), child => {
    if(nodes.indexOf(child) === -1) {
      nodes.push(child);
    }
  }));
  return $(nodes);
};

/*
 * Returns `true` if the element would be selected by the specified selector string; otherwise, returns `false`.
 *
 * @param {Node} element Element to test
 * @param {String} selector Selector to match against element
 * @return {Boolean}
 *
 * @example
 *     $.matches(element, '.match');
 */

const matches = (() => {
  const context = typeof Element !== 'undefined' ? Element.prototype : _util__WEBPACK_IMPORTED_MODULE_0__.win;
  const _matches = context.matches || context.matchesSelector || context.mozMatchesSelector || context.msMatchesSelector || context.oMatchesSelector || context.webkitMatchesSelector;
  return (element, selector) => _matches.call(element, selector);
})();

/*
 * Use the faster `getElementById`, `getElementsByClassName` or `getElementsByTagName` over `querySelectorAll` if possible.
 *
 * @private
 * @param {String} selector Query selector.
 * @param {Node} context The context for the selector to query elements.
 * @return {Object} NodeList, HTMLCollection, or Array of matching elements (depending on method used).
 */

const querySelector = (selector, context) => {

  const isSimpleSelector = reSimpleSelector.test(selector);

  if(isSimpleSelector) {
    if(selector[0] === '#') {
      const element = (context.getElementById ? context : document).getElementById(selector.slice(1));
      return element ? [element] : [];
    }
    if(selector[0] === '.') {
      return context.getElementsByClassName(selector.slice(1));
    }
    return context.getElementsByTagName(selector);
  }

  return context.querySelectorAll(selector);

};

/*
 * Create DOM fragment from an HTML string
 *
 * @private
 * @param {String} html String representing HTML.
 * @return {NodeList}
 */

const createFragment = html => {

  if(reSingleTag.test(html)) {
    return [document.createElement(RegExp.$1)];
  }

  const elements = [];
  const container = document.createElement('div');
  const children = container.childNodes;

  container.innerHTML = html;

  for(let i = 0, l = children.length; i < l; i++) {
    elements.push(children[i]);
  }

  return elements;
};

/*
 * Calling `$(selector)` returns a wrapped collection of elements.
 *
 * @private
 * @param {NodeList|Array} collection Element(s) to wrap.
 * @return Object) The wrapped collection
 */

const wrap = collection => {

  if(!isPrototypeSet) {
    DOMtastic.prototype = $.fn;
    DOMtastic.prototype.constructor = DOMtastic;
    isPrototypeSet = true;
  }

  return new DOMtastic(collection);
};

/*
 * Constructor for the Object.prototype strategy
 *
 * @constructor
 * @private
 * @param {NodeList|Array} collection Element(s) to wrap.
 */

const DOMtastic = function DOMtastic(collection) {
  let i = 0;
  const length = collection.length;
  for(; i < length;) {
    this[i] = collection[i++];
  }
  this.length = length;
};


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(143);
/**
 * @module BaseClass
 */




/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(api) {

  /**
   * Provide subclass for classes or components to extend from.
   * The opposite and successor of plugins (no need to extend `$.fn` anymore, complete control).
   *
   * @return {Class} The class to extend from, including all `$.fn` methods.
   * @example
   *     import { BaseClass } from  'domtastic';
   *
   *     class MyComponent extends BaseClass {
   *         doSomething() {
   *             return this.addClass('.foo');
   *         }
   *     }
   *
   *     let component = new MyComponent('body');
   *     component.doSomething();
   *
   * @example
   *     import $ from  'domtastic';
   *
   *     class MyComponent extends $.BaseClass {
   *         progress(value) {
   *             return this.attr('data-progress', value);
   *         }
   *     }
   *
   *     let component = new MyComponent(document.body);
   *     component.progress('ive').append('<p>enhancement</p>');
   */

  class BaseClass {
    constructor() {
      _selector_index__WEBPACK_IMPORTED_MODULE_0__.DOMtastic.call(this, (0,_selector_index__WEBPACK_IMPORTED_MODULE_0__.$)(...arguments));
    }
  }
  (0,_util__WEBPACK_IMPORTED_MODULE_1__.extend)(BaseClass.prototype, api);
  return BaseClass;
}


/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "css": () => (/* binding */ css)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module CSS
 */



const isNumeric = value => !isNaN(parseFloat(value)) && isFinite(value);

const camelize = value => value.replace(/-([\da-z])/gi, (matches, letter) => letter.toUpperCase());

const dasherize = value => value.replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();

/**
 * Get the value of a style property for the first element, or set one or more style properties for each element in the collection.
 *
 * @param {String|Object} key The name of the style property to get or set. Or an object containing key-value pairs to set as style properties.
 * @param {String} [value] The value of the style property to set.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').css('padding-left'); // get
 *     $('.item').css('color', '#f00'); // set
 *     $('.item').css({'border-width': '1px', display: 'inline-block'}); // set multiple
 */

const css = function(key, value) {

  let styleProps, prop, val;

  if(typeof key === 'string') {
    key = camelize(key);

    if(typeof value === 'undefined') {
      let element = this.nodeType ? this : this[0];
      if(element) {
        val = element.style[key];
        return isNumeric(val) ? parseFloat(val) : val;
      }
      return undefined;
    }

    styleProps = {};
    styleProps[key] = value;
  } else {
    styleProps = key;
    for(prop in styleProps) {
      val = styleProps[prop];
      delete styleProps[prop];
      styleProps[camelize(prop)] = val;
    }
  }

  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    for(prop in styleProps) {
      if(styleProps[prop] || styleProps[prop] === 0) {
        element.style[prop] = styleProps[prop];
      } else {
        element.style.removeProperty(dasherize(prop));
      }
    }
  });

  return this;
};


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_clone": () => (/* binding */ _clone),
/* harmony export */   "_each": () => (/* binding */ _each),
/* harmony export */   "after": () => (/* binding */ after),
/* harmony export */   "append": () => (/* binding */ append),
/* harmony export */   "before": () => (/* binding */ before),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "prepend": () => (/* binding */ prepend)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(145);
/**
 * @module DOM
 */




const forEach = Array.prototype.forEach;

/**
 * Append element(s) to each element in the collection.
 *
 * @param {String|Node|NodeList|Object} element What to append to the element(s).
 * Clones elements as necessary.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').append('<p>more</p>');
 */

const append = function(element) {
  if(this instanceof Node) {
    if(typeof element === 'string') {
      this.insertAdjacentHTML('beforeend', element);
    } else {
      if(element instanceof Node) {
        this.appendChild(element);
      } else {
        const elements = element instanceof NodeList ? (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(element) : element;
        forEach.call(elements, this.appendChild.bind(this));
      }
    }
  } else {
    _each(this, append, element);
  }
  return this;
};

/**
 * Place element(s) at the beginning of each element in the collection.
 *
 * @param {String|Node|NodeList|Object} element What to place at the beginning of the element(s).
 * Clones elements as necessary.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').prepend('<span>start</span>');
 */

const prepend = function(element) {
  if(this instanceof Node) {
    if(typeof element === 'string') {
      this.insertAdjacentHTML('afterbegin', element);
    } else {
      if(element instanceof Node) {
        this.insertBefore(element, this.firstChild);
      } else {
        let elements = element instanceof NodeList ? (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(element) : element;
        forEach.call(elements.reverse(), prepend.bind(this));
      }
    }
  } else {
    _each(this, prepend, element);
  }
  return this;
};

/**
 * Place element(s) before each element in the collection.
 *
 * @param {String|Node|NodeList|Object} element What to place as sibling(s) before to the element(s).
 * Clones elements as necessary.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.items').before('<p>prefix</p>');
 */

const before = function(element) {
  if(this instanceof Node) {
    if(typeof element === 'string') {
      this.insertAdjacentHTML('beforebegin', element);
    } else {
      if(element instanceof Node) {
        this.parentNode.insertBefore(element, this);
      } else {
        const elements = element instanceof NodeList ? (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(element) : element;
        forEach.call(elements, before.bind(this));
      }
    }
  } else {
    _each(this, before, element);
  }
  return this;
};

/**
 * Place element(s) after each element in the collection.
 *
 * @param {String|Node|NodeList|Object} element What to place as sibling(s) after to the element(s). Clones elements as necessary.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.items').after('<span>suf</span><span>fix</span>');
 */

const after = function(element) {
  if(this instanceof Node) {
    if(typeof element === 'string') {
      this.insertAdjacentHTML('afterend', element);
    } else {
      if(element instanceof Node) {
        this.parentNode.insertBefore(element, this.nextSibling);
      } else {
        const elements = element instanceof NodeList ? (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(element) : element;
        forEach.call(elements.reverse(), after.bind(this));
      }
    }
  } else {
    _each(this, after, element);
  }
  return this;
};

/**
 * Clone a wrapped object.
 *
 * @return {Object} Wrapped collection of cloned nodes.
 * @example
 *     $(element).clone();
 */

const clone = function() {
  return (0,_selector_index__WEBPACK_IMPORTED_MODULE_1__.$)(_clone(this));
};

/**
 * Clone an object
 *
 * @param {String|Node|NodeList|Array} element The element(s) to clone.
 * @return {String|Node|NodeList|Array} The cloned element(s)
 * @private
 */

const _clone = element => {
  if(typeof element === 'string') {
    return element;
  } else if(element instanceof Node) {
    return element.cloneNode(true);
  } else if('length' in element) {
    return [].map.call(element, el => el.cloneNode(true));
  }
  return element;
};

/**
 * Specialized iteration, applying `fn` in reversed manner to a clone of each element, but the provided one.
 *
 * @param {NodeList|Array} collection
 * @param {Function} fn
 * @param {Node} element
 * @private
 */

const _each = (collection, fn, element) => {
  let l = collection.length;
  while(l--) {
    const elm = l === 0 ? element : _clone(element);
    fn.call(collection[l], elm);
  }
};


/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "attr": () => (/* binding */ attr),
/* harmony export */   "removeAttr": () => (/* binding */ removeAttr)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module Attr
 */



/**
 * Get the value of an attribute for the first element, or set one or more attributes for each element in the collection.
 *
 * @param {String|Object} key The name of the attribute to get or set. Or an object containing key-value pairs to set as attributes.
 * @param {String} [value] The value of the attribute to set.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').attr('attrName'); // get
 *     $('.item').attr('attrName', 'attrValue'); // set
 *     $('.item').attr({attr1: 'value1', 'attr-2': 'value2'}); // set multiple
 */

const attr = function(key, value) {

  if(typeof key === 'string' && typeof value === 'undefined') {
    const element = this.nodeType ? this : this[0];
    return element ? element.getAttribute(key) : undefined;
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    if(typeof key === 'object') {
      for(let attr in key) {
        element.setAttribute(attr, key[attr]);
      }
    } else {
      element.setAttribute(key, value);
    }
  });
};

/**
 * Remove attribute from each element in the collection.
 *
 * @param {String} key Attribute name
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.items').removeAttr('attrName');
 */

const removeAttr = function(key) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element.removeAttribute(key));
};


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addClass": () => (/* binding */ addClass),
/* harmony export */   "hasClass": () => (/* binding */ hasClass),
/* harmony export */   "removeClass": () => (/* binding */ removeClass),
/* harmony export */   "toggleClass": () => (/* binding */ toggleClass)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module Class
 */



/**
 * Add a class to the element(s)
 *
 * @param {String} value Space-separated class name(s) to add to the element(s).
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').addClass('bar');
 *     $('.item').addClass('bar foo');
 */

const addClass = function(value) {
  if(value && value.length) {
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(value.split(' '), _each.bind(this, 'add'));
  }
  return this;
};

/**
 * Remove a class from the element(s)
 *
 * @param {String} value Space-separated class name(s) to remove from the element(s).
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.items').removeClass('bar');
 *     $('.items').removeClass('bar foo');
 */

const removeClass = function(value) {
  if(value && value.length) {
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(value.split(' '), _each.bind(this, 'remove'));
  }
  return this;
};

/**
 * Toggle a class at the element(s)
 *
 * @param {String} value Space-separated class name(s) to toggle at the element(s).
 * @param {Boolean} [state] A Boolean value to determine whether the class should be added or removed.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').toggleClass('bar');
 *     $('.item').toggleClass('bar foo');
 *     $('.item').toggleClass('bar', true);
 */

const toggleClass = function(value, state) {
  if(value && value.length) {
    const action = typeof state === 'boolean' ? state ? 'add' : 'remove' : 'toggle';
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(value.split(' '), _each.bind(this, action));
  }
  return this;
};

/**
 * Check if the element(s) have a class.
 *
 * @param {String} value Check if the DOM element contains the class name. When applied to multiple elements,
 * returns `true` if _any_ of them contains the class name.
 * @return {Boolean} Whether the element's class attribute contains the class name.
 * @example
 *     $('.item').hasClass('bar');
 */

const hasClass = function(value) {
  return (this.nodeType ? [this] : this).some(element => element.classList.contains(value));
};

/**
 * Specialized iteration, applying `fn` of the classList API to each element.
 *
 * @param {String} fnName
 * @param {String} className
 * @private
 */

const _each = function(fnName, className) {
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element.classList[fnName](className));
};


/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "contains": () => (/* binding */ contains)
/* harmony export */ });
/**
 * @module contains
 */

/**
 * Test whether an element contains another element in the DOM.
 *
 * @param {Element} container The element that may contain the other element.
 * @param {Element} element The element that may be a descendant of the other element.
 * @return {Boolean} Whether the `container` element contains the `element`.
 * @example
 *     $.contains(parentElement, childElement); // true/false
 */

const contains = (container, element) => {
  if(!container || !element || container === element) {
    return false;
  } else if(container.contains) {
    return container.contains(element);
  } else if(container.compareDocumentPosition) {
    return !(container.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_DISCONNECTED);
  }
  return false;
};


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "data": () => (/* binding */ data),
/* harmony export */   "prop": () => (/* binding */ prop)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module Data
 */



const isSupportsDataSet = typeof document !== 'undefined' && 'dataset' in document.documentElement;
const DATAKEYPROP = isSupportsDataSet ? 'dataset' : '__DOMTASTIC_DATA__';

const camelize = str => str.replace(/-+(.)?/g, (match, char) => char ? char.toUpperCase() : '');

/**
 * Get data from first element, or set data for each element in the collection.
 *
 * @param {String} key The key for the data to get or set.
 * @param {String} [value] The data to set.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').data('attrName'); // get
 *     $('.item').data('attrName', {any: 'data'}); // set
 */

const data = function(key, value) {

  if(typeof key === 'string' && typeof value === 'undefined') {
    const element = this.nodeType ? this : this[0];
    return element && DATAKEYPROP in element ? element[DATAKEYPROP][camelize(key)] : undefined;
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    if(!isSupportsDataSet) {
      element[DATAKEYPROP] = element[DATAKEYPROP] || {};
    }

    element[DATAKEYPROP][camelize(key)] = value;
  });
};

/**
 * Get property from first element, or set property on each element in the collection.
 *
 * @param {String} key The name of the property to get or set.
 * @param {String} [value] The value of the property to set.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').prop('attrName'); // get
 *     $('.item').prop('attrName', 'attrValue'); // set
 */

const prop = function(key, value) {

  if(typeof key === 'string' && typeof value === 'undefined') {
    const element = this.nodeType ? this : this[0];
    return element && element ? element[key] : undefined;
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element[key] = value);
};


/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appendTo": () => (/* binding */ appendTo),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "replaceWith": () => (/* binding */ replaceWith),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "val": () => (/* binding */ val)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(148);
/* harmony import */ var _selector_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(145);
/**
 * @module DOM (extra)
 */





/**
 * Append each element in the collection to the specified element(s).
 *
 * @param {Node|NodeList|Object} element What to append the element(s) to. Clones elements as necessary.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').appendTo(container);
 */

const appendTo = function(element) {
  const context = typeof element === 'string' ? (0,_selector_index__WEBPACK_IMPORTED_MODULE_2__.$)(element) : element;
  _index__WEBPACK_IMPORTED_MODULE_1__.append.call(context, this);
  return this;
};

/*
 * Empty each element in the collection.
 *
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').empty();
 */

const empty = function() {
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element.innerHTML = '');
};

/**
 * Remove the collection from the DOM.
 *
 * @return {Array} Array containing the removed elements
 * @example
 *     $('.item').remove();
 */

const remove = function() {
  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    if(element.parentNode) {
      element.parentNode.removeChild(element);
    }
  });
};

/**
 * Replace each element in the collection with the provided new content, and return the array of elements that were replaced.
 *
 * @return {Array} Array containing the replaced elements
 */

const replaceWith = function() {
  return _index__WEBPACK_IMPORTED_MODULE_1__.before.apply(this, arguments).remove();
};

/**
 * Get the `textContent` from the first, or set the `textContent` of each element in the collection.
 *
 * @param {String} [value]
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').text('New content');
 */

const text = function(value) {

  if(value === undefined) {
    return this[0].textContent;
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element.textContent = '' + value);
};

/**
 * Get the `value` from the first, or set the `value` of each element in the collection.
 *
 * @param {String} [value]
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('input.firstName').val('New value');
 */

const val = function(value) {

  if(value === undefined) {
    return this.length > 0 ? this[0].value : undefined;
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element.value = value);
};


/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "html": () => (/* binding */ html)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module HTML
 */



/*
 * Get the HTML contents of the first element, or set the HTML contents for each element in the collection.
 *
 * @param {String} [fragment] HTML fragment to set for the element. If this argument is omitted, the HTML contents are returned.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').html();
 *     $('.item').html('<span>more</span>');
 */

const html = function(fragment) {

  if(fragment === undefined) {
    const element = this.nodeType ? this : this[0];
    return element ? element.innerHTML : undefined;
  }

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => element.innerHTML = fragment);
};


/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bind": () => (/* binding */ bind),
/* harmony export */   "clearHandlers": () => (/* binding */ clearHandlers),
/* harmony export */   "delegateHandler": () => (/* binding */ delegateHandler),
/* harmony export */   "getHandlers": () => (/* binding */ getHandlers),
/* harmony export */   "off": () => (/* binding */ off),
/* harmony export */   "on": () => (/* binding */ on),
/* harmony export */   "one": () => (/* binding */ one),
/* harmony export */   "proxyHandler": () => (/* binding */ proxyHandler),
/* harmony export */   "unbind": () => (/* binding */ unbind)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _selector_closest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(156);
/**
 * @module Events
 */




/**
 * Shorthand for `addEventListener`. Supports event delegation if a filter (`selector`) is provided.
 *
 * @param {String} eventNames List of space-separated event types to be added to the element(s)
 * @param {String} [selector] Selector to filter descendants that delegate the event to this element.
 * @param {Function} handler Event handler
 * @param {Boolean} useCapture=false
 * @param {Boolean} once=false
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').on('click', callback);
 *     $('.container').on('click focus', '.item', handler);
 */

const on = function(eventNames, selector, handler, useCapture, once) {

  if(typeof selector === 'function') {
    handler = selector;
    selector = null;
  }

  let parts,
    namespace,
    eventListener;

  eventNames.split(' ').forEach(eventName => {

    parts = eventName.split('.');
    eventName = parts[0] || null;
    namespace = parts[1] || null;

    eventListener = proxyHandler(handler);

    (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {

      if(selector) {
        eventListener = delegateHandler.bind(element, selector, eventListener);
      }

      if(once) {
        const listener = eventListener;
        eventListener = event => {
          off.call(element, eventNames, selector, handler, useCapture);
          listener.call(element, event);
        };
      }

      element.addEventListener(eventName, eventListener, useCapture || false);

      getHandlers(element).push({
        eventName,
        handler,
        eventListener,
        selector,
        namespace
      });
    });

  }, this);

  return this;
};

/**
 * Shorthand for `removeEventListener`.
 *
 * @param {String} eventNames List of space-separated event types to be removed from the element(s)
 * @param {String} [selector] Selector to filter descendants that undelegate the event to this element.
 * @param {Function} handler Event handler
 * @param {Boolean} useCapture=false
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').off('click', callback);
 *     $('#my-element').off('myEvent myOtherEvent');
 *     $('.item').off();
 */

const off = function(eventNames = '', selector, handler, useCapture) {

  if(typeof selector === 'function') {
    handler = selector;
    selector = null;
  }

  let parts,
    namespace,
    handlers;

  eventNames.split(' ').forEach(eventName => {

    parts = eventName.split('.');
    eventName = parts[0] || null;
    namespace = parts[1] || null;

    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {

      handlers = getHandlers(element);

      (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(handlers.filter(item => {
        return (
          (!eventName || item.eventName === eventName) &&
          (!namespace || item.namespace === namespace) &&
          (!handler || item.handler === handler) &&
          (!selector || item.selector === selector)
        );
      }), item => {
        element.removeEventListener(item.eventName, item.eventListener, useCapture || false);
        handlers.splice(handlers.indexOf(item), 1);
      });

      if(!eventName && !namespace && !selector && !handler) {
        clearHandlers(element);
      } else if(handlers.length === 0) {
        clearHandlers(element);
      }

    });

  }, this);

  return this;
};

/**
 * Add event listener and execute the handler at most once per element.
 *
 * @param eventNames
 * @param selector
 * @param handler
 * @param useCapture
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').one('click', callback);
 */

const one = function(eventNames, selector, handler, useCapture) {
  return on.call(this, eventNames, selector, handler, useCapture, 1);
};

/**
 * Get event handlers from an element
 *
 * @private
 * @param {Node} element
 * @return {Array}
 */

const eventKeyProp = '__domtastic_event__';
let id = 1;
let handlers = {};
let unusedKeys = [];

const getHandlers = element => {
  if(!element[eventKeyProp]) {
    element[eventKeyProp] = unusedKeys.length === 0 ? ++id : unusedKeys.pop();
  }
  const key = element[eventKeyProp];
  return handlers[key] || (handlers[key] = []);
};

/**
 * Clear event handlers for an element
 *
 * @private
 * @param {Node} element
 */

const clearHandlers = element => {
  const key = element[eventKeyProp];
  if(handlers[key]) {
    handlers[key] = null;
    element[eventKeyProp] = null;
    unusedKeys.push(key);
  }
};

/**
 * Function to create a handler that augments the event object with some extra methods,
 * and executes the callback with the event and the event data (i.e. `event.detail`).
 *
 * @private
 * @param handler Callback to execute as `handler(event, data)`
 * @return {Function}
 */

const proxyHandler = handler => function(event) {
  return handler.call(this, augmentEvent(event));
};

const eventMethods = {
  preventDefault: 'isDefaultPrevented',
  stopImmediatePropagation: 'isImmediatePropagationStopped',
  stopPropagation: 'isPropagationStopped'
};
const returnTrue = () => true;
const returnFalse = () => false;

/**
 * Attempt to augment events and implement something closer to DOM Level 3 Events.
 *
 * @private
 * @param {Object} event
 * @return {Function}
 */

const augmentEvent = event => {
  if(!event.isDefaultPrevented || event.stopImmediatePropagation || event.stopPropagation) {
    for(const methodName in eventMethods) {
      (function(methodName, testMethodName, originalMethod) {
        event[methodName] = function() {
          this[testMethodName] = returnTrue;
          return originalMethod && originalMethod.apply(this, arguments);
        };
        event[testMethodName] = returnFalse;
      }(methodName, eventMethods[methodName], event[methodName]));
    }
    if(event._preventDefault) {
      event.preventDefault();
    }
  }
  return event;
};

/**
 * Function to test whether delegated events match the provided `selector` (filter),
 * if the event propagation was stopped, and then actually call the provided event handler.
 * Use `this` instead of `event.currentTarget` on the event object.
 *
 * @private
 * @param {String} selector Selector to filter descendants that undelegate the event to this element.
 * @param {Function} handler Event handler
 * @param {Event} event
 */

const delegateHandler = function(selector, handler, event) {
  const eventTarget = event._target || event.target;
  const currentTarget = _selector_closest__WEBPACK_IMPORTED_MODULE_1__.closest.call([eventTarget], selector, this)[0];
  if(currentTarget && currentTarget !== this) {
    if(currentTarget === eventTarget || !(event.isPropagationStopped && event.isPropagationStopped())) {
      handler.call(currentTarget, event);
    }
  }
};

const bind = on;
const unbind = off;


/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "closest": () => (/* binding */ closest)
/* harmony export */ });
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(143);
/**
 * @module closest
 */




/**
 * Return the closest element matching the selector (starting by itself) for each element in the collection.
 *
 * @param {String} selector Filter
 * @param {Object} [context] If provided, matching elements must be a descendant of this element
 * @return {Object} New wrapped collection (containing zero or one element)
 * @chainable
 * @example
 *     $('.selector').closest('.container');
 */

const closest = (() => {

  const closest = function(selector, context) {
    const nodes = [];
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.each)(this, node => {
      while(node && node !== context) {
        if((0,_index__WEBPACK_IMPORTED_MODULE_0__.matches)(node, selector)) {
          nodes.push(node);
          break;
        }
        node = node.parentElement;
      }
    });
    return (0,_index__WEBPACK_IMPORTED_MODULE_0__.$)((0,_util__WEBPACK_IMPORTED_MODULE_1__.uniq)(nodes));
  };

  return typeof Element === 'undefined' || !Element.prototype.closest ? closest : function(selector, context) {
    if(!context) {
      const nodes = [];
      (0,_util__WEBPACK_IMPORTED_MODULE_1__.each)(this, node => {
        const n = node.closest(selector);
        if(n) {
          nodes.push(n);
        }
      });
      return (0,_index__WEBPACK_IMPORTED_MODULE_0__.$)((0,_util__WEBPACK_IMPORTED_MODULE_1__.uniq)(nodes));
    } else {
      return closest.call(this, selector, context);
    }
  };
})();


/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trigger": () => (/* binding */ trigger),
/* harmony export */   "triggerHandler": () => (/* binding */ triggerHandler)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _dom_contains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(151);
/**
 * @module trigger
 */




const reMouseEvent = /^(mouse(down|up|over|out|enter|leave|move)|contextmenu|(dbl)?click)$/;
const reKeyEvent = /^key(down|press|up)$/;

/**
 * Trigger event at element(s)
 *
 * @param {String} type Type of the event
 * @param {Object} data Data to be sent with the event (`params.detail` will be set to this).
 * @param {Object} [params] Event parameters (optional)
 * @param {Boolean} params.bubbles=true Does the event bubble up through the DOM or not.
 * @param {Boolean} params.cancelable=true Is the event cancelable or not.
 * @param {Mixed} params.detail=undefined Additional information about the event.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $('.item').trigger('anyEventType');
 */

const trigger = function(type, data, {bubbles = true, cancelable = true, preventDefault = false} = {}) {

  const EventConstructor = getEventConstructor(type);
  const event = new EventConstructor(type, {
    bubbles,
    cancelable,
    preventDefault,
    detail: data
  });

  event._preventDefault = preventDefault;

  return (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    if(!bubbles || isEventBubblingInDetachedTree || isAttachedToDocument(element)) {
      dispatchEvent(element, event);
    } else {
      triggerForPath(element, type, {
        bubbles,
        cancelable,
        preventDefault,
        detail: data
      });
    }
  });
};

const getEventConstructor = type => isSupportsOtherEventConstructors ? (reMouseEvent.test(type) ? MouseEvent : (reKeyEvent.test(type) ? KeyboardEvent : CustomEvent)) : CustomEvent;

/**
 * Trigger event at first element in the collection. Similar to `trigger()`, except:
 *
 * - Event does not bubble
 * - Default event behavior is prevented
 * - Only triggers handler for first matching element
 *
 * @param {String} type Type of the event
 * @param {Object} data Data to be sent with the event
 * @example
 *     $('form').triggerHandler('submit');
 */

const triggerHandler = function(type, data) {
  if(this[0]) {
    trigger.call(this[0], type, data, {
      bubbles: false,
      preventDefault: true
    });
  }
};

/**
 * Check whether the element is attached to or detached from) the document
 *
 * @private
 * @param {Node} element Element to test
 * @return {Boolean}
 */

const isAttachedToDocument = element => {
  if(element === window || element === document) {
    return true;
  }
  return (0,_dom_contains__WEBPACK_IMPORTED_MODULE_1__.contains)(element.ownerDocument.documentElement, element);
};

/**
 * Dispatch the event at the element and its ancestors.
 * Required to support delegated events in browsers that don't bubble events in detached DOM trees.
 *
 * @private
 * @param {Node} element First element to dispatch the event at
 * @param {String} type Type of the event
 * @param {Object} [params] Event parameters (optional)
 * @param {Boolean} params.bubbles=true Does the event bubble up through the DOM or not.
 * Will be set to false (but shouldn't matter since events don't bubble anyway).
 * @param {Boolean} params.cancelable=true Is the event cancelable or not.
 * @param {Mixed} params.detail=undefined Additional information about the event.
 */

const triggerForPath = (element, type, params = {}) => {
  params.bubbles = false;
  const event = new CustomEvent(type, params);
  event._target = element;
  do {
    dispatchEvent(element, event);
  } while(element = element.parentNode); // eslint-disable-line no-cond-assign
};

/**
 * Dispatch event to element, but call direct event methods instead if available
 * (e.g. "blur()", "submit()") and if the event is non-cancelable.
 *
 * @private
 * @param {Node} element Element to dispatch the event at
 * @param {Object} event Event to dispatch
 */

const directEventMethods = ['blur', 'focus', 'select', 'submit'];

const dispatchEvent = (element, event) => {
  if(directEventMethods.indexOf(event.type) !== -1 && typeof element[event.type] === 'function' && !event._preventDefault && !event.cancelable) {
    element[event.type]();
  } else {
    element.dispatchEvent(event);
  }
};

/**
 * Polyfill for CustomEvent, borrowed from [MDN](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill).
 * Needed to support IE (9, 10, 11) & PhantomJS
 */

(() => {
  const CustomEvent = function(event, params = {
    bubbles: false,
    cancelable: false,
    detail: undefined
  }) {
    let customEvent = document.createEvent('CustomEvent');
    customEvent.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return customEvent;
  };

  CustomEvent.prototype = _util__WEBPACK_IMPORTED_MODULE_0__.win.CustomEvent && _util__WEBPACK_IMPORTED_MODULE_0__.win.CustomEvent.prototype;
  _util__WEBPACK_IMPORTED_MODULE_0__.win.CustomEvent = CustomEvent;

})();

/*
 * Are events bubbling in detached DOM trees?
 * @private
 */

const isEventBubblingInDetachedTree = (() =>{
  let isBubbling = false;
  const doc = _util__WEBPACK_IMPORTED_MODULE_0__.win.document;
  if(doc) {
    const parent = doc.createElement('div');
    const child = parent.cloneNode();
    parent.appendChild(child);
    parent.addEventListener('e', function() {
      isBubbling = true;
    });
    child.dispatchEvent(new CustomEvent('e', {bubbles: true}));
  }
  return isBubbling;
})();

const isSupportsOtherEventConstructors = (() => {
  try {
    new MouseEvent('click');
  } catch(e) {
    return false;
  }
  return true;
})();


/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ready": () => (/* binding */ ready)
/* harmony export */ });
/**
 * @module Ready
 */

/**
 * Execute callback when `DOMContentLoaded` fires for `document`, or immediately if called afterwards.
 *
 * @param handler Callback to execute when initial DOM content is loaded.
 * @return {Object} The wrapped collection
 * @chainable
 * @example
 *     $(document).ready(callback);
 */

const ready = function(handler) {
  if(/complete|loaded|interactive/.test(document.readyState) && document.body) {
    handler();
  } else {
    document.addEventListener('DOMContentLoaded', handler, false);
  }
  return this;
};


/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "noConflict": () => (/* binding */ noConflict)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/**
 * @module noConflict
 */



/*
 * Save the previous value of the global `$` variable, so that it can be restored later on.
 * @private
 */

const previousLib = _util__WEBPACK_IMPORTED_MODULE_0__.win.$;

/**
 * In case another library sets the global `$` variable before DOMtastic does,
 * this method can be used to return the global `$` to that other library.
 *
 * @return {Object} Reference to DOMtastic.
 * @example
 *     var domtastic = $.noConflict();
 */

const noConflict = function() {
  _util__WEBPACK_IMPORTED_MODULE_0__.win.$ = previousLib;
  return this;
};


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "children": () => (/* binding */ children),
/* harmony export */   "concat": () => (/* binding */ concat),
/* harmony export */   "contents": () => (/* binding */ contents),
/* harmony export */   "eq": () => (/* binding */ eq),
/* harmony export */   "first": () => (/* binding */ first),
/* harmony export */   "get": () => (/* binding */ get),
/* harmony export */   "parent": () => (/* binding */ parent),
/* harmony export */   "siblings": () => (/* binding */ siblings),
/* harmony export */   "slice": () => (/* binding */ slice)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(145);
/**
 * @module Selector (extra)
 */




/**
 * Return children of each element in the collection, optionally filtered by a selector.
 *
 * @param {String} [selector] Filter
 * @return {Object} New wrapped collection
 * @chainable
 * @example
 *     $('.selector').children();
 *     $('.selector').children('.filter');
 */

const children = function(selector) {
  const nodes = [];
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    if(element.children) {
      (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(element.children, child => {
        if(!selector || (selector && (0,_index__WEBPACK_IMPORTED_MODULE_1__.matches)(child, selector))) {
          nodes.push(child);
        }
      });
    }
  });
  return (0,_index__WEBPACK_IMPORTED_MODULE_1__.$)(nodes);
};

/**
 * Add the elements of a wrapped collection to another.
 *
 * @param {String|Node|NodeList|Array} selector Query selector, `Node`, `NodeList`, array of elements, or HTML fragment string.
 * @return {Object} The extended wrapped collection
 * @example
 *     $('.items').concat($('.more-items));
 *     $('.items').concat('.more-items);
 *     $('.items').concat('<div>more</div>');
 */

const concat = function(selector) {
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)((0,_index__WEBPACK_IMPORTED_MODULE_1__.$)(selector), element => {
    if([].indexOf.call(this, element) === -1) {
      [].push.call(this, element);
    }
  });
  return this;
};

/**
 * Return child nodes of each element in the collection, including text and comment nodes.
 *
 * @return {Object} New wrapped collection
 * @example
 *     $('.selector').contents();
 */

const contents = function() {
  const nodes = [];
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => nodes.push.apply(nodes, (0,_util__WEBPACK_IMPORTED_MODULE_0__.toArray)(element.childNodes)));
  return (0,_index__WEBPACK_IMPORTED_MODULE_1__.$)(nodes);
};

/**
 * Return a collection containing only the one at the specified index.
 *
 * @param {Number} index
 * @return {Object} New wrapped collection
 * @chainable
 * @example
 *     $('.items').eq(1)
 *     // The second item; result is the same as doing $($('.items')[1]);
 */

const eq = function(index) {
  return slice.call(this, index, index + 1);
};

/**
 * Return a collection containing only the first item.
 *
 * @return {Object} New wrapped collection
 * @chainable
 * @example
 *     $('.items').first()
 *     // The first item; result is the same as doing $($('.items')[0]);
 */

const first = function() {
  return slice.call(this, 0, 1);
};

/**
 * Return the DOM element at the specified index.
 *
 * @param {Number} index
 * @return {Node} Element at the specified index
 * @example
 *     $('.items').get(1)
 *     // The second element; result is the same as doing $('.items')[1];
 */

const get = function(index) {
  return this[index];
};

/**
 * Return the parent elements of each element in the collection, optionally filtered by a selector.
 *
 * @param {String} [selector] Filter
 * @return {Object} New wrapped collection
 * @chainable
 * @example
 *     $('.selector').parent();
 *     $('.selector').parent('.filter');
 */

const parent = function(selector) {
  const nodes = [];
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => {
    if(!selector || (selector && (0,_index__WEBPACK_IMPORTED_MODULE_1__.matches)(element.parentNode, selector))) {
      nodes.push(element.parentNode);
    }
  });
  return (0,_index__WEBPACK_IMPORTED_MODULE_1__.$)(nodes);
};

/**
 * Return the sibling elements of each element in the collection, optionally filtered by a selector.
 *
 * @param {String} [selector] Filter
 * @return {Object} New wrapped collection
 * @chainable
 * @example
 *     $('.selector').siblings();
 *     $('.selector').siblings('.filter');
 */

const siblings = function(selector) {
  const nodes = [];
  (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(this, element => (0,_util__WEBPACK_IMPORTED_MODULE_0__.each)(element.parentNode.children, sibling => {
    if(sibling !== element && (!selector || (selector && (0,_index__WEBPACK_IMPORTED_MODULE_1__.matches)(sibling, selector)))) {
      nodes.push(sibling);
    }
  }));
  return (0,_index__WEBPACK_IMPORTED_MODULE_1__.$)(nodes);
};

/**
 * Create a new, sliced collection.
 *
 * @param {Number} start
 * @param {Number} end
 * @return {Object} New wrapped collection
 * @example
 *     $('.items').slice(1, 3)
 *     // New wrapped collection containing the second, third, and fourth element.
 */

const slice = function(start, end) { // eslint-disable-line no-unused-vars
  return (0,_index__WEBPACK_IMPORTED_MODULE_1__.$)([].slice.apply(this, arguments));
};


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isFunction": () => (/* binding */ isFunction)
/* harmony export */ });
/**
 * @module Type
 */

/*
 * Determine if the argument passed is a Javascript function object.
 *
 * @param {Object} [obj] Object to test whether or not it is a function.
 * @return {boolean}
 * @example
 *     $.isFunction(function(){}); // true
 * @example
 *     $.isFunction({}); // false
 */

const isFunction = obj => typeof obj === 'function';

/*
 * Determine whether the argument is an array.
 *
 * @param {Object} [obj] Object to test whether or not it is an array.
 * @return {boolean}
 * @example
 *     $.isArray([]); // true
 * @example
 *     $.isArray({}); // false
 */

const isArray = Array.isArray;


/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setupMapsGL = void 0;

var _utils = __webpack_require__(17);

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const SUPPORTED_STRATEGIES = ['mapbox', 'maplibre', 'google', 'leaflet'];

const addWeatherLayer = (controller, code, _a = {}) => {
  var {
    beforeId
  } = _a,
      options = __rest(_a, ["beforeId"]);

  const wxcode = code.replace(/^mapsgl___/, '');

  if (!controller.hasWeatherLayer(wxcode)) {
    controller.addWeatherLayer(wxcode, (0, _utils.extend)({
      id: wxcode,
      animation: {
        interval: 8
      }
    }, options), beforeId);
  }
};

const removeWeatherLayer = (controller, code) => {
  const wxcode = code.replace(/^mapsgl___/, '');

  if (controller.hasWeatherLayer(wxcode)) {
    controller.removeWeatherLayer(wxcode);
  }
};

const createButton = (controller, config) => {
  const {
    id,
    title,
    value,
    controls,
    options
  } = config;
  return {
    id: id || value,
    title,
    value,
    controls,
    options: Object.assign(Object.assign({}, options), {
      validate: false,
      mapsgl: true
    }),
    onSelect: button => {
      addWeatherLayer(controller, button.value, Object.assign({
        id
      }, options));
    },
    onDeselect: button => {
      removeWeatherLayer(controller, button.value);
    }
  };
};

const createSegmentedButton = (controller, config) => {
  const {
    id,
    title,
    segments,
    controls,
    options
  } = config;
  return {
    id,
    title,
    segments: segments.map(segment => ({
      title: segment.title,
      id: segment.id || segment.value,
      value: segment.value,
      options: {
        validate: false,
        mapsgl: true
      }
    })),
    controls,
    onChange: button => {// console.log(button.value);
    },
    onSelectSegment: segment => {
      if (!segment.value) {
        throw new Error(`[Aeris] Cannot add layer, invalid layer value '${segment.value}`);
      }

      addWeatherLayer(controller, segment.value, options);
    },
    onDeselectSegment: segment => {
      removeWeatherLayer(controller, segment.value);
    },
    onSelect: button => {
      var _a;

      (_a = button.value) === null || _a === void 0 ? void 0 : _a.forEach(code => {
        addWeatherLayer(controller, code, options);
      });
    },
    onDeselect: button => {
      var _a;

      (_a = button.value) === null || _a === void 0 ? void 0 : _a.forEach(code => {
        removeWeatherLayer(controller, code);
      });
    }
  };
};

const createButtonGroup = (controller, config) => {
  const {
    id,
    title,
    buttons
  } = config;
  return {
    id,
    title,
    multiselect: true,
    buttons: buttons.map(btn => btn.segments ? createSegmentedButton(controller, btn) : createButton(controller, btn))
  };
};

const addLayerButton = (config, controller, panel) => {
  let button;

  if (config.buttons) {
    button = createButtonGroup(controller, config);
  } else if (config.segments) {
    button = createSegmentedButton(controller, config);
  } else {
    button = createButton(controller, config);
  }

  if (config.index >= 0) {
    panel.insertAt(config.index, button);
  } else {
    panel.add(button);
  }

  return button;
};

const setupMapsGL = (mapsgl, app, options = {}, callback) => {
  const map = app.map.map;
  const timeline = app.map.timeline;
  const target = app.$el;

  if (SUPPORTED_STRATEGIES.includes(app.map.strategy.strategy) === false) {
    throw new Error(`[Aeris] MapsGL does not currently support the '${app.map.strategy.strategy}' map strategy. MapsGL only supports the following map strategies: ${SUPPORTED_STRATEGIES.join(', ')}`);
  }

  const timelinePanel = app.getPanel('timeline');
  let controller;
  const controllerOptions = {
    account: app.account,
    animation: {
      // duration: timeline.duration,
      // endDelay: timeline.endDelay,
      repeat: true,
      manualAdvance: true
    }
  };
  app.mapsgl = {
    controller,
    addLayerPanelItems: configs => {
      const layersPanel = app.getPanel('layers');
      configs.forEach(config => {
        addLayerButton(config, controller, layersPanel);
      });
    }
  };

  if (app.map.strategy.strategy === 'mapbox') {
    controller = new mapsgl.MapboxMapController(map, controllerOptions);
  } else if (app.map.strategy.strategy === 'maplibre') {
    controller = new mapsgl.MaplibreMapController(map, controllerOptions);
  } else if (app.map.strategy.strategy === 'google') {
    controller = new mapsgl.GoogleMapController(map, controllerOptions);
  } else if (app.map.strategy.strategy === 'leaflet') {
    controller = new mapsgl.LeafletMapController(map, controllerOptions);
  }

  if (!controller) {
    throw new Error('[Aeris] Could not initialize MapsGL, no valid strategy or map controller found.');
  }

  app.on("layer:change:control"
  /* LAYER_CONTROL_CHANGE */
  , e => {
    const {
      id,
      control
    } = e.data || {};

    if (control.id === 'opacity') {
      const layer = controller.getLayer(id);

      if (layer) {
        layer.setPaintProperty('sample.opacity', 0);
      }
    }
  });

  if (timeline) {
    controller.timeline.startDate = timeline.startDate();
    controller.timeline.endDate = timeline.endDate(); // sync timeline date ranges

    timeline.on('start:change end:change', () => {
      controller.timeline.startDate = timeline.startDate();
      controller.timeline.endDate = timeline.endDate();
    }); // sync timeline playback control

    timeline.on('play', () => {
      controller.timeline.play();
    }).on('stop', () => {
      controller.timeline.stop();
    }); // handle timeline scrubbing

    timeline.on('advance', e => {
      controller.timeline.goTo(e.data.position, false);
    });

    if (timelinePanel) {
      controller.on('load:start', () => {
        timelinePanel.showLoading(true);
      }).on('load:complete', () => {
        timelinePanel.showLoading(false);
      });
    }
  } // set up layers in button panel


  const layersPanel = app.getPanel('layers');

  if (layersPanel && (0, _utils.isArray)(options.layers)) {
    options.layers.forEach(config => {
      addLayerButton(config, controller, layersPanel);
    });
  }

  callback(controller);
};

exports.setupMapsGL = setupMapsGL;

/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Modules = void 0;

var _modules = _interopRequireWildcard(__webpack_require__(164));

var _MapSourceModule2 = _interopRequireDefault(__webpack_require__(167));

var _ModuleGroup2 = _interopRequireDefault(__webpack_require__(216));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Modules;
exports.Modules = Modules;

(function (Modules) {
  Modules.MapSourceModule = _MapSourceModule2.default;
  Modules.ModuleGroup = _ModuleGroup2.default; // modules

  Modules.aviation = {
    FlightRules: _modules.FlightRules,
    Sigmets: _modules.Sigmets,
    StationPlots: _modules.StationPlots
  };
  Modules.tropical = {
    Systems: _modules.Systems,
    Invests: _modules.Invests,
    Windfields: _modules.Windfields,
    Breakpoints: _modules.Breakpoints,
    utils: _modules.TropicalUtils
  };
  Modules.Routing = _modules.Routing; // groups

  Modules.groups = {
    Aviation: _modules.Aviation,
    Tropical: _modules.Tropical
  };
})(Modules || (exports.Modules = Modules = {}));

/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "FlightRules", ({
  enumerable: true,
  get: function () {
    return _flightrules.loader;
  }
}));
Object.defineProperty(exports, "Sigmets", ({
  enumerable: true,
  get: function () {
    return _sigmets.loader;
  }
}));
Object.defineProperty(exports, "StationPlots", ({
  enumerable: true,
  get: function () {
    return _stationplots.loader;
  }
}));
Object.defineProperty(exports, "Systems", ({
  enumerable: true,
  get: function () {
    return _systems.loader;
  }
}));
Object.defineProperty(exports, "Invests", ({
  enumerable: true,
  get: function () {
    return _invests.loader;
  }
}));
Object.defineProperty(exports, "Windfields", ({
  enumerable: true,
  get: function () {
    return _windfields.loader;
  }
}));
Object.defineProperty(exports, "Breakpoints", ({
  enumerable: true,
  get: function () {
    return _breakpoints.loader;
  }
}));
Object.defineProperty(exports, "Routing", ({
  enumerable: true,
  get: function () {
    return _routing.loader;
  }
}));
Object.defineProperty(exports, "Aviation", ({
  enumerable: true,
  get: function () {
    return _aviation.loader;
  }
}));
Object.defineProperty(exports, "Tropical", ({
  enumerable: true,
  get: function () {
    return _tropical.loader;
  }
}));
Object.defineProperty(exports, "TropicalUtils", ({
  enumerable: true,
  get: function () {
    return _tropical.utils;
  }
}));

var _flightrules = __webpack_require__(165);

var _sigmets = __webpack_require__(168);

var _stationplots = __webpack_require__(170);

var _systems = __webpack_require__(179);

var _invests = __webpack_require__(186);

var _windfields = __webpack_require__(188);

var _breakpoints = __webpack_require__(190);

var _routing = __webpack_require__(192);

var _aviation = __webpack_require__(214);

var _tropical = __webpack_require__(217);

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(166)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 166 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = __webpack_require__(167);

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

const colors = {
  VFR: '#1bbe08',
  MVFR: '#1c56cf',
  IFR: '#fa0708',
  LIFR: '#fb06ff'
};

const getColor = code => {
  code = (code || 'none').toUpperCase();
  return colors[code] || '#999999';
};

const formatName = str => {
  const replacements = [{
    regex: '\\sAfb$',
    replace: ' Air Force Base'
  }, {
    regex: '\\sAr?p?$',
    replace: ' Airport'
  }];
  str = (0, _strings.toName)(str);
  replacements.forEach(item => {
    const re = new RegExp(item.regex);
    str = str.replace(re, item.replace);
  });
  return str;
};

class FlightRules extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'aviation-flightrules';
  }

  source() {
    const ids = `id:AYPY;id:BIKF;id:BKPR;id:CYEG;id:CYHZ;id:CYOW;id:CYQB;id:CYUL;id:CYVR;id:CYWG;id:CYXU;id:CYYC;
			id:CYYJ;id:CYYT;id:CYYZ;id:DAAG;id:DGAA;id:DNAA;id:DNMM;id:DTTA;id:EBBR;id:EBLG;id:EDDB;id:EDDC;id:EDDF;
			id:EDDG;id:EDDH;id:EDDK;id:EDDL;id:EDDM;id:EDDN;id:EDDP;id:EDDS;id:EDDT;id:EDDV;id:EDDW;id:EDLW;id:EDSB;
			id:EETN;id:EFHK;id:EGAA;id:EGAC;id:EGBB;id:EGCC;id:EGCN;id:EGFF;id:EGGD;id:EGGP;id:EGGW;id:EGHH;id:EGHI;
			id:EGKK;id:EGLC;id:EGLL;id:EGNM;id:EGNT;id:EGNX;id:EGPD;id:EGPF;id:EGPH;id:EGSH;id:EGSS;id:EGTE;id:EGUL;
			id:EGUN;id:EGVA;id:EGVN;id:EHAM;id:EHBK;id:EHEH;id:EICK;id:EIDW;id:EINN;id:EKBI;id:EKCH;id:EKYT;id:ELLX;
			id:ENBO;id:ENBR;id:ENGM;id:ENTC;id:ENVA;id:ENZV;id:EPGD;id:EPKK;id:EPKT;id:EPMO;id:EPPO;id:EPWA;id:EPWR;
			id:ESGG;id:ESMS;id:ESPA;id:ESSA;id:ETAR;id:EVRA;id:EYVI;id:FACT;id:FAGG;id:FAJS;id:FALE;id:GCLP;id:GCTS;
			id:GCXO;id:GMMN;id:GOOY;id:HAAB;id:HECA;id:HEGN;id:HKJK;id:HKMO;id:HLLT;id:HSSS;id:KABQ;id:KADW;id:KAFW;
			id:KAGS;id:KAMA;id:KATL;id:KAUS;id:KAVL;id:KBAB;id:KBAD;id:KBDL;id:KBFI;id:KBGR;id:KBHM;id:KBIL;id:KBLV;
			id:KBMI;id:KBNA;id:KBOI;id:KBOS;id:KBTR;id:KBUF;id:KBWI;id:KCAE;id:KCBM;id:KCHA;id:KCHS;id:KCID;id:KCLE;
			id:KCLT;id:KCMH;id:KCOF;id:KCOS;id:KCPR;id:KCRP;id:KCRW;id:KCVG;id:KCVS;id:KDAL;id:KDAY;id:KDBQ;id:KDCA;
			id:KDEN;id:KDFW;id:KDLF;id:KDLH;id:KDOV;id:KDSM;id:KDTW;id:KDYS;id:KEDW;id:KEND;id:KERI;id:KEWR;id:KFFO;
			id:KFLL;id:KFSM;id:KFTW;id:KFWA;id:KGEG;id:KGPT;id:KGRB;id:KGSB;id:KGSO;id:KGSP;id:KGUS;id:KHIB;id:KHMN;
			id:KHOU;id:KHSV;id:KHTS;id:KIAD;id:KIAH;id:KICT;id:KIND;id:KJAN;id:KJAX;id:KJFK;id:KJLN;id:KLAS;id:KLAX;
			id:KLBB;id:KLCK;id:KLEX;id:KLFI;id:KLFT;id:KLGA;id:KLIT;id:KLTS;id:KLUF;id:KMBS;id:KMCF;id:KMCI;id:KMCO;
			id:KMDW;id:KMEM;id:KMGE;id:KMGM;id:KMHT;id:KMIA;id:KMKE;id:KMLI;id:KMLU;id:KMOB;id:KMSN;id:KMSP;id:KMSY;
			id:KMUO;id:KMYR;id:KOAK;id:KOKC;id:KONT;id:KORD;id:KORF;id:KPAM;id:KPBI;id:KPDX;id:KPHF;id:KPHL;id:KPHX;
			id:KPIA;id:KPIT;id:KPWM;id:KRDU;id:KRFD;id:KRIC;id:KRND;id:KRNO;id:KROA;id:KROC;id:KRST;id:KRSW;id:KSAN;
			id:KSAT;id:KSAV;id:KSBN;id:KSDF;id:KSEA;id:KSFB;id:KSFO;id:KSGF;id:KSHV;id:KSJC;id:KSKA;id:KSLC;id:KSMF;
			id:KSNA;id:KSPI;id:KSPS;id:KSRQ;id:KSSC;id:KSTL;id:KSUS;id:KSUU;id:KSUX;id:KSYR;id:KSZL;id:KTCM;id:KTIK;
			id:KTLH;id:KTOL;id:KTPA;id:KTRI;id:KTUL;id:KTUS;id:KTYS;id:KVBG;id:KVPS;id:KWRB;id:LATI;id:LBBG;id:LBPD;
			id:LBSF;id:LBWN;id:LCLK;id:LCPH;id:LDZA;id:LEAL;id:LEBL;id:LEMD;id:LEMG;id:LEPA;id:LEST;id:LFBD;id:LFBO;
			id:LFBV;id:LFML;id:LFMN;id:LFOA;id:LFOT;id:LFPG;id:LFPO;id:LGAV;id:LGIR;id:LGTS;id:LHBP;id:LIBD;id:LICC;
			id:LICJ;id:LIEE;id:LIMC;id:LIME;id:LIMF;id:LIMJ;id:LIML;id:LIMZ;id:LIPE;id:LIPH;id:LIPX;id:LIPZ;id:LIRA;
			id:LIRF;id:LIRN;id:LIRP;id:LJLJ;id:LKPR;id:LLBG;id:LLOV;id:LMML;id:LOWW;id:LPFR;id:LPLA;id:LPPD;id:LPPR;
			id:LPPT;id:LQSA;id:LROP;id:LSGG;id:LSZH;id:LTAC;id:LTAF;id:LTAI;id:LTAJ;id:LTAZ;id:LTBA;id:LTBJ;id:LTBS;
			id:LTCE;id:LTCG;id:LTFC;id:LTFE;id:LTFJ;id:LXGB;id:LYBE;id:LYPG;id:LZIB;id:MDPC;id:MDSD;id:MKJP;id:MMAA;
			id:MMGL;id:MMHO;id:MMMX;id:MMMY;id:MMPR;id:MMSD;id:MMTJ;id:MMUN;id:MPTO;id:MUHA;id:MUVR;id:MWCR;id:MYNN;
			id:MZBZ;id:NCRG;id:NZAA;id:NZCH;id:NZWN;id:OBBI;id:OEDF;id:OEDR;id:OEJN;id:OEMA;id:OERK;id:OIIE;id:OIII;
			id:OIMM;id:OISS;id:OITT;id:OJAI;id:OKBK;id:OLBA;id:OMAA;id:OMDB;id:OMDW;id:OMSJ;id:OOMS;id:OPRN;id:OPST;
			id:ORBI;id:ORMM;id:OSAP;id:OSDI;id:OSLK;id:OTBD;id:PAFA;id:PANC;id:PGUM;id:PHNL;id:PR20;id:RCBS;id:RCKH;
			id:RCTP;id:RJAA;id:RJBB;id:RJCC;id:RJFF;id:RJFK;id:RJGG;id:RJNS;id:RJOO;id:RJTT;id:RJTY;id:RKJB;id:RKJK;
			id:RKPC;id:RKPK;id:RKSI;id:RKSO;id:RKSS;id:RKTU;id:ROAH;id:RODN;id:RPLC;id:RPLL;id:RPMD;id:RPVM;id:SAEZ;
			id:SBBE;id:SBBR;id:SBCF;id:SBCT;id:SBFL;id:SBGL;id:SBGR;id:SBSP;id:SBSV;id:SCEL;id:SELT;id:SEQM;id:SKBO;
			id:SPIM;id:SPZO;id:SUMU;id:TJSJ;id:TMJG;id:TNCM;id:UAAA;id:UACC;id:UAFM;id:UAKK;id:UBBB;id:UDYZ;id:UGTB;
			id:UKBB;id:UKCC;id:UKFF;id:UKHH;id:UKOO;id:ULLI;id:UMMS;id:UNKL;id:URSS;id:USSS;id:UTTT;id:UUBW;id:UUDD;
			id:UUEE;id:UUMU;id:UWUU;id:UWWW;id:VABB;id:VAGO;id:VCBI;id:VDPP;id:VDSR;id:VECC;id:VHHH;id:VIAR;id:VIDP;
			id:VISM;id:VMMC;id:VOBL;id:VOCI;id:VOCL;id:VOHS;id:VOMM;id:VOPN;id:VOTV;id:VRMM;id:VTBD;id:VTBS;id:VTCC;
			id:VVDN;id:VVNB;id:VVTS;id:VYMD;id:VYYY;id:WAAA;id:WADD;id:WARR;id:WBSB;id:WIII;id:WMKK;id:WSSS;id:YBBN;
			id:YMML;id:YPPH;id:YSCB;id:YSSY;id:ZBAA;id:ZBNY;id:ZBTJ;id:ZBYN;id:ZGGG;id:ZGHA;id:ZGKL;id:ZGNN;id:ZGSZ;
			id:ZHCC;id:ZHHH;id:ZJHK;id:ZJSY;id:ZLXY;id:ZPPP;id:ZSAM;id:ZSFZ;id:ZSHC;id:ZSJN;id:ZSNB;id:ZSNJ;id:ZSPD;
			id:ZSSS;id:ZSWZ;id:ZUCK;id:ZUGY;id:ZUUU;id:ZWWW;id:ZYHB;id:ZYTL;id:ZYTX`;
    const request = this.account.api().endpoint('observations').action("search"
    /* SEARCH */
    ).query(ids).fields('id,loc,ob,place').from('-2hours').limit(1000);
    return {
      type: 'vector',
      refresh: 60,
      data: {
        service: request
      },
      style: {
        marker: data => ({
          svg: {
            shape: {
              type: 'circle',
              fill: {
                color: getColor((0, _utils.get)(data, 'ob.flightRule'))
              },
              stroke: {
                color: '#ffffff',
                width: 2
              }
            }
          },
          size: [16, 16]
        })
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Flight Rules'
    };
  }

  legend() {
    return null;
  }

  infopanel() {
    return {
      request: () => {
        const request = this.account.api();
        const forecastFields = 'timestamp,dateTimeISO,tempF,icon,weatherPrimary,windSpeedMPH,windSpeedMinMPH,windSpeedMaxMPH,windGustMPH,snowIN,precipIN'.split(',').map(key => `periods.${key}`);
        request.addRequest(this.account.api().endpoint('forecasts').fields(forecastFields.join(',')).filter('3hr').limit(7));
        request.addRequest(this.account.api().endpoint('convective/outlook').action("contains"
        /* CONTAINS */
        ));
        request.addRequest(this.account.api().endpoint('lightning').action("closest"
        /* CLOSEST */
        ).radius('60mi').limit(100));
        return request;
      },
      views: [{
        data: data => {
          if (!data) return null;
          data = data.observations || data;
          return data.ob;
        },
        renderer: data => {
          if (!data) return;
          return `
						<div class="flightrule">
							<div class="awxjs__ui-cols align-center">
								<div class="awxjs__ui-expand">Flight Rule</div>
								<div class="awxjs__ui-expand value">${data.flightRule} <div class="indicator" style="background:${getColor(data.flightRule)};"></div></div>
							</div>
						</div>
					`;
        }
      }, {
        title: 'Impacts',
        renderer: 'hazards'
      }, {
        title: 'Observations',
        renderer: 'obs'
      }, {
        title: 'Short-Term Forecast',
        renderer: 'forecast'
      }]
    };
  }

  onData(results) {
    // format data by station id so the loaded obs data can be used in the info panel
    if ((0, _utils.isArray)(results)) {
      this._data = results.reduce((prev, current) => {
        const {
          id
        } = current;

        if (id) {
          prev[id] = current;
        }

        return prev;
      }, {});
    }
  }

  onMarkerClick(marker, data) {
    const id = data.id;
    const place = data.place || {};
    const obs = this.data ? this.data[id] : {};
    this.showInfoPanel(`${id} - ${formatName(place.name)}`).load({
      p: id
    }, {
      observations: obs
    });
  }

}

var _default = FlightRules;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.BaseMapSourceModule = void 0;

var _utils = __webpack_require__(17);

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A map source module is a container for providing all of the required configuration and
 * functionality needed for rendering and controlling a map content source on an interactive map
 * application.
 *
 * A module can be a direct instance of `MapSourceModule`, in which case a configuration object
 * must be provided when instantiating the instance. Or, a module can be provided as a subclass
 * of `MapSourceModule`, in which case the subclass can override the necessary properties and
 * methods of the parent class to provide the necessary configuration and functionality.
 *
 * Regardless which implementation method is used, a module must return a valid map content
 * source from the `source()` method.
 *
 * @class MapSourceModule
 * @implements {IMapSourceModule}
 */
class MapSourceModule extends _EventDispatcher.default {
  /**
   * Initializes and returns a map source module instance configured with the specified options
   * if provided.
   *
   * @param {any} [opts=null]
   * @memberof MapSourceModule
   */
  constructor(opts = null) {
    super();
    this._opts = opts || {};
    this._account = (0, _utils.get)(opts, 'account');
  }
  /**
   * Module identifier.
   *
   * @readonly
   * @type {string}
   * @memberof MapSourceModule
   */


  get id() {
    return this._opts.id;
  }
  /**
   * Aeris account associated with the module.
   *
   * @readonly
   * @type {Account}
   * @memberof MapSourceModule
   */


  get account() {
    return this._account;
  }
  /**
   * Application the module was initialized with.
   *
   * @readonly
   * @type {InteractiveMapApp}
   * @memberof MapSourceModule
   */


  get app() {
    return this._app;
  }
  /**
   * Application map instance.
   *
   * @readonly
   * @type {InteractiveMap}
   * @memberof MapSourceModule
   */


  get map() {
    return (0, _utils.isset)(this._app) ? this._app.map : this._map;
  }
  /**
   * Map data source created for the module.
   *
   * @type {*}
   * @memberof MapSourceModule
   */


  get dataSource() {
    return this._source;
  }
  /**
   * Sets the module's map data source.
   *
   * @memberof MapSourceModule
   */


  set dataSource(value) {
    this._source = value;

    if (value) {
      value.on('data:load', e => {
        const {
          results
        } = e.data;

        if (results) {
          this.onData(results);
        }
      });
    }
  }
  /**
   * Data associated with the module.
   *
   * If the module loads remote data when added to a map, this value will return the data that
   * was last returned by the remote request.
   *
   * @readonly
   * @type {*}
   * @memberof MapSourceModule
   */


  get data() {
    return this._data;
  }
  /**
   * Returns the module's configuration options.
   */


  get opts() {
    return this._opts;
  }
  /**
   * Parent module group the module belongs to, if any.
   *
   * @type {ModuleGroup}
   * @memberof MapSourceModule
   */


  get group() {
    return this._group;
  }
  /**
   * Sets the parent module group.
   *
   * @memberof MapSourceModule
   */


  set group(group) {
    this._group = group;
    this._opts.controls = null;
  }
  /**
   * Initializes the module with the specified Aeris account and application.
   *
   * @param {Account} account
   * @param {InteractiveMapApp} app
   * @memberof MapSourceModule
   */


  initialize(account, app, map = null) {
    this._account = account;
    this._app = app;
    this._map = app ? app.map : map;
  }
  /**
   * Returns the map content source configuration.
   *
   * @see LayerOptions
   * @returns {*}
   * @memberof MapSourceModule
   */


  source() {
    return this._opts.source;
  }
  /**
   * Returns the application controls configuration.
   *
   * @see ButtonOptions
   * @see SegmentedButtonOptions
   * @see ButtonGroupOptions
   * @returns {*}
   * @memberof MapSourceModule
   */


  controls() {
    return this._opts.controls;
  }
  /**
   * Returns the legend configuration.
   *
   * @see LegendOptions
   * @returns {*}
   * @memberof MapSourceModule
   */


  legend() {
    return this._opts.legend;
  }
  /**
   * Returns the configuration for the info panel content view.
   *
   * @see InfoPanelContentViewOptions
   * @returns {*}
   * @memberof MapSourceModule
   */


  infopanel() {
    return this._opts.infopanel;
  }
  /**
   * Shows the map info panel using the specified title and data for the configured view
   * associated with the module.
   *
   * @param {string} title
   * @param {*} [data]
   * @returns {InfoPanel}
   * @memberof MapSourceModule
   */


  showInfoPanel(title, data) {
    return this.app.showInfo(this.id, title, data);
  }
  /**
   * Called when the module has been initialized with an application.
   *
   * @memberof MapSourceModule
   */


  onInit() {
    if (this._opts.onInit) {
      this._opts.onInit();
    }
  }
  /**
   * Called when the module's map content source has been added to the map.
   *
   * @memberof MapSourceModule
   */


  onAdd() {
    if (this._opts.onAdd) {
      this._opts.onAdd();
    }
  }
  /**
   * Called when the module's map content source is removed from the map.
   *
   * @memberof MapSourceModule
   */


  onRemove() {
    if (this._opts.onRemove) {
      this._opts.onRemove();
    }
  }
  /**
   * Called when the module's map content source has loaded data.
   *
   * @param {*} result
   * @memberof MapSourceModule
   */


  onData(result) {
    if (this._opts.onData) {
      this._opts.onData(result);
    }
  }
  /**
   * Called when a marker associated with the module's map content source is clicked on the map.
   *
   * @param {*} marker
   * @param {*} data
   * @memberof MapSourceModule
   */


  onMarkerClick(marker, data) {
    if (this._opts.onMarkerClick) {
      this._opts.onMarkerClick(marker, data);
    }
  }
  /**
   * Called when a polygon or polyline associated with the module's map content source is clicked
   * on the map.
   *
   * @param {*} shape
   * @param {*} data
   * @memberof MapSourceModule
   */


  onShapeClick(shape, data) {
    if (this._opts.onShapeClick) {
      this._opts.onShapeClick(shape, data);
    }
  }

}

class BaseMapSourceModule extends MapSourceModule {}

exports.BaseMapSourceModule = BaseMapSourceModule;
var _default = MapSourceModule;
exports["default"] = _default;

/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(169)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 169 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = __webpack_require__(167);

const colors = {
  TURB: '#e98e00',
  ICE: '#2452e9',
  CONVECTIVE: '#e90000',
  TS: '#ffe300'
};

const getColor = code => {
  code = (code || 'none').toUpperCase();
  return colors[code] || '#999999';
};

class Sigmets extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'aviation-sigmets';
  }

  source() {
    return {
      type: 'geojson',
      data: {
        url: '//uat.aerisweather.com/demos/data/sigmet.json',
        properties: {
          id: 'icaoId',
          category: 'hazard'
        }
      },
      style: {
        polygon: item => ({
          fill: {
            color: getColor(item.hazard),
            opacity: 0.4
          },
          stroke: {
            color: getColor(item.hazard),
            width: 2
          }
        })
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'SIGMETs'
    };
  }

  legend() {
    return null;
  }

  infopanel() {
    return {
      view: {
        views: [{
          data: data => data.sigmet,
          renderer: data => {
            if (!data) return null;
            return `<div class="sigmet">${(data.rawAirSigmet || '').replace(/\n/g, '<br>')}</div>`;
          }
        }]
      }
    };
  }

  onShapeClick(shape, data) {
    data = data || {}; // this.app.showInfo('sigmet', `${props.icaoId} - ${utils.strings.toName(props.hazard)} SIGMET`, { sigmet: props });

    this.showInfoPanel(`${data.icaoId} - ${data.hazard} SIGMET`, {
      sigmet: data
    });
  }

}

var _default = Sigmets;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(171)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 171 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = __webpack_require__(167);

var _StationPlotView = _interopRequireDefault(__webpack_require__(172));

var icons = _interopRequireWildcard(__webpack_require__(175));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buildRequestUrl = (account, bounds, params) => {
  let {
    filter
  } = params;

  if (filter && Array.isArray(filter)) {
    filter = filter.join();
  }

  let query;

  if (filter === 'large-airports') {
    query = 'id:AYPY;id:BIKF;id:BKPR;id:CYEG;id:CYHZ;id:CYOW;id:CYQB;id:CYUL;id:CYVR;id:CYWG;id:CYXU;id:CYYC;id:CYYJ;id:CYYT;id:CYYZ;id:DAAG;id:DGAA;id:DNAA;id:DNMM;id:DTTA;id:EBBR;id:EBLG;id:EDDB;id:EDDC;id:EDDF;id:EDDG;id:EDDH;id:EDDK;id:EDDL;id:EDDM;id:EDDN;id:EDDP;id:EDDS;id:EDDT;id:EDDV;id:EDDW;id:EDLW;id:EDSB;id:EETN;id:EFHK;id:EGAA;id:EGAC;id:EGBB;id:EGCC;id:EGCN;id:EGFF;id:EGGD;id:EGGP;id:EGGW;id:EGHH;id:EGHI;id:EGKK;id:EGLC;id:EGLL;id:EGNM;id:EGNT;id:EGNX;id:EGPD;id:EGPF;id:EGPH;id:EGSH;id:EGSS;id:EGTE;id:EGUL;id:EGUN;id:EGVA;id:EGVN;id:EHAM;id:EHBK;id:EHEH;id:EICK;id:EIDW;id:EINN;id:EKBI;id:EKCH;id:EKYT;id:ELLX;id:ENBO;id:ENBR;id:ENGM;id:ENTC;id:ENVA;id:ENZV;id:EPGD;id:EPKK;id:EPKT;id:EPMO;id:EPPO;id:EPWA;id:EPWR;id:ESGG;id:ESMS;id:ESPA;id:ESSA;id:ETAR;id:EVRA;id:EYVI;id:FACT;id:FAGG;id:FAJS;id:FALE;id:GCLP;id:GCTS;id:GCXO;id:GMMN;id:GOOY;id:HAAB;id:HECA;id:HEGN;id:HKJK;id:HKMO;id:HLLT;id:HSSS;id:KABQ;id:KADW;id:KAFW;id:KAGS;id:KAMA;id:KATL;id:KAUS;id:KAVL;id:KBAB;id:KBAD;id:KBDL;id:KBFI;id:KBGR;id:KBHM;id:KBIL;id:KBLV;id:KBMI;id:KBNA;id:KBOI;id:KBOS;id:KBTR;id:KBUF;id:KBWI;id:KCAE;id:KCBM;id:KCHA;id:KCHS;id:KCID;id:KCLE;id:KCLT;id:KCMH;id:KCOF;id:KCOS;id:KCPR;id:KCRP;id:KCRW;id:KCVG;id:KCVS;id:KDAL;id:KDAY;id:KDBQ;id:KDCA;id:KDEN;id:KDFW;id:KDLF;id:KDLH;id:KDOV;id:KDSM;id:KDTW;id:KDYS;id:KEDW;id:KEND;id:KERI;id:KEWR;id:KFFO;id:KFLL;id:KFSM;id:KFTW;id:KFWA;id:KGEG;id:KGPT;id:KGRB;id:KGSB;id:KGSO;id:KGSP;id:KGUS;id:KHIB;id:KHMN;id:KHOU;id:KHSV;id:KHTS;id:KIAD;id:KIAH;id:KICT;id:KIND;id:KJAN;id:KJAX;id:KJFK;id:KJLN;id:KLAS;id:KLAX;id:KLBB;id:KLCK;id:KLEX;id:KLFI;id:KLFT;id:KLGA;id:KLIT;id:KLTS;id:KLUF;id:KMBS;id:KMCF;id:KMCI;id:KMCO;id:KMDW;id:KMEM;id:KMGE;id:KMGM;id:KMHT;id:KMIA;id:KMKE;id:KMLI;id:KMLU;id:KMOB;id:KMSN;id:KMSP;id:KMSY;id:KMUO;id:KMYR;id:KOAK;id:KOKC;id:KONT;id:KORD;id:KORF;id:KPAM;id:KPBI;id:KPDX;id:KPHF;id:KPHL;id:KPHX;id:KPIA;id:KPIT;id:KPWM;id:KRDU;id:KRFD;id:KRIC;id:KRND;id:KRNO;id:KROA;id:KROC;id:KRST;id:KRSW;id:KSAN;id:KSAT;id:KSAV;id:KSBN;id:KSDF;id:KSEA;id:KSFB;id:KSFO;id:KSGF;id:KSHV;id:KSJC;id:KSKA;id:KSLC;id:KSMF;id:KSNA;id:KSPI;id:KSPS;id:KSRQ;id:KSSC;id:KSTL;id:KSUS;id:KSUU;id:KSUX;id:KSYR;id:KSZL;id:KTCM;id:KTIK;id:KTLH;id:KTOL;id:KTPA;id:KTRI;id:KTUL;id:KTUS;id:KTYS;id:KVBG;id:KVPS;id:KWRB;id:LATI;id:LBBG;id:LBPD;id:LBSF;id:LBWN;id:LCLK;id:LCPH;id:LDZA;id:LEAL;id:LEBL;id:LEMD;id:LEMG;id:LEPA;id:LEST;id:LFBD;id:LFBO;id:LFBV;id:LFML;id:LFMN;id:LFOA;id:LFOT;id:LFPG;id:LFPO;id:LGAV;id:LGIR;id:LGTS;id:LHBP;id:LIBD;id:LICC;id:LICJ;id:LIEE;id:LIMC;id:LIME;id:LIMF;id:LIMJ;id:LIML;id:LIMZ;id:LIPE;id:LIPH;id:LIPX;id:LIPZ;id:LIRA;id:LIRF;id:LIRN;id:LIRP;id:LJLJ;id:LKPR;id:LLBG;id:LLOV;id:LMML;id:LOWW;id:LPFR;id:LPLA;id:LPPD;id:LPPR;id:LPPT;id:LQSA;id:LROP;id:LSGG;id:LSZH;id:LTAC;id:LTAF;id:LTAI;id:LTAJ;id:LTAZ;id:LTBA;id:LTBJ;id:LTBS;id:LTCE;id:LTCG;id:LTFC;id:LTFE;id:LTFJ;id:LXGB;id:LYBE;id:LYPG;id:LZIB;id:MDPC;id:MDSD;id:MKJP;id:MMAA;id:MMGL;id:MMHO;id:MMMX;id:MMMY;id:MMPR;id:MMSD;id:MMTJ;id:MMUN;id:MPTO;id:MUHA;id:MUVR;id:MWCR;id:MYNN;id:MZBZ;id:NCRG;id:NZAA;id:NZCH;id:NZWN;id:OBBI;id:OEDF;id:OEDR;id:OEJN;id:OEMA;id:OERK;id:OIIE;id:OIII;id:OIMM;id:OISS;id:OITT;id:OJAI;id:OKBK;id:OLBA;id:OMAA;id:OMDB;id:OMDW;id:OMSJ;id:OOMS;id:OPRN;id:OPST;id:ORBI;id:ORMM;id:OSAP;id:OSDI;id:OSLK;id:OTBD;id:PAFA;id:PANC;id:PGUM;id:PHNL;id:PR20;id:RCBS;id:RCKH;id:RCTP;id:RJAA;id:RJBB;id:RJCC;id:RJFF;id:RJFK;id:RJGG;id:RJNS;id:RJOO;id:RJTT;id:RJTY;id:RKJB;id:RKJK;id:RKPC;id:RKPK;id:RKSI;id:RKSO;id:RKSS;id:RKTU;id:ROAH;id:RODN;id:RPLC;id:RPLL;id:RPMD;id:RPVM;id:SAEZ;id:SBBE;id:SBBR;id:SBCF;id:SBCT;id:SBFL;id:SBGL;id:SBGR;id:SBSP;id:SBSV;id:SCEL;id:SELT;id:SEQM;id:SKBO;id:SPIM;id:SPZO;id:SUMU;id:TJSJ;id:TMJG;id:TNCM;id:UAAA;id:UACC;id:UAFM;id:UAKK;id:UBBB;id:UDYZ;id:UGTB;id:UKBB;id:UKCC;id:UKFF;id:UKHH;id:UKOO;id:ULLI;id:UMMS;id:UNKL;id:URSS;id:USSS;id:UTTT;id:UUBW;id:UUDD;id:UUEE;id:UUMU;id:UWUU;id:UWWW;id:VABB;id:VAGO;id:VCBI;id:VDPP;id:VDSR;id:VECC;id:VHHH;id:VIAR;id:VIDP;id:VISM;id:VMMC;id:VOBL;id:VOCI;id:VOCL;id:VOHS;id:VOMM;id:VOPN;id:VOTV;id:VRMM;id:VTBD;id:VTBS;id:VTCC;id:VVDN;id:VVNB;id:VVTS;id:VYMD;id:VYYY;id:WAAA;id:WADD;id:WARR;id:WBSB;id:WIII;id:WMKK;id:WSSS;id:YBBN;id:YMML;id:YPPH;id:YSCB;id:YSSY;id:ZBAA;id:ZBNY;id:ZBTJ;id:ZBYN;id:ZGGG;id:ZGHA;id:ZGKL;id:ZGNN;id:ZGSZ;id:ZHCC;id:ZHHH;id:ZJHK;id:ZJSY;id:ZLXY;id:ZPPP;id:ZSAM;id:ZSFZ;id:ZSHC;id:ZSJN;id:ZSNB;id:ZSNJ;id:ZSPD;id:ZSSS;id:ZSWZ;id:ZUCK;id:ZUGY;id:ZUUU;id:ZWWW;id:ZYHB;id:ZYTL;id:ZYTX';
  }

  const request = account.api().endpoint('observations').action("within"
  /* WITHIN */
  ).bounds(bounds).filter(filter).query(query).limit(9999);
  const url = request.url();
  return url;
};

let _addedSvgDefs = false;

class StationPlots extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'aviation-stationplots';
  }

  source() {
    return {
      type: 'vector',
      refresh: 60,
      requiresBounds: true,
      data: {
        url: params => {
          const bounds = this.map.getBounds();
          return buildRequestUrl(this.account, bounds, params);
        },
        properties: {
          id: 'id',
          root: 'response'
        }
      },
      style: {
        marker: data => {
          const zoom = this.map.getZoom(); // Building the station plot  graphic is handled in its own
          // class.

          const graphic = new _StationPlotView.default(data);
          const html = graphic.render(zoom);
          const size = [160, 160]; // the markers change size and spacing based on the zoomlevel
          // of the map

          return {
            html,
            size: zoom > 6 ? size : 100,
            spacing: zoom > 6 ? size[0] * 0.8 : 60
          };
        }
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Station Plots'
    };
  }

  legend() {
    return null;
  }

  infopanel() {
    return {
      views: [{
        // data: (data: any) => {
        // 	return data.sigmet;
        // },
        renderer: data => {
          const graphic = new _StationPlotView.default(data);
          const html = graphic.render(7, true);
          return `
						<div class="awxjs-info-panel-legend legend-is-showing">
							<h3>Station Plot</h3>
							<div class="awxjs-info-panel-station-plot" style="position: relative">${html}</div>
						</div>
					`;
        }
      }, {
        renderer: data => `
					<h3>Raw METAR</h3>
					<p class="font-mono">${data.raw}</p>
				`
      }]
    };
  }

  onAdd() {
    if (!_addedSvgDefs) {
      const svgDefs = document.createElement('div');
      svgDefs.setAttribute('id', `awxjs-${this.id}-wxicons`);
      svgDefs.innerHTML = icons.defs;
      svgDefs.style.display = 'none';
      document.body.appendChild(svgDefs);
      _addedSvgDefs = true;
    }
  }

  onMarkerClick(marker, data) {
    const id = data.id;
    const place = data.place || {};
    const obs = this.data ? this.data[id] : {};
    this.showInfoPanel(`${id} - ${place.name}`).load({
      p: id
    }, data);
  }

}

var _default = StationPlots;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 172 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _StationPlotLegend = _interopRequireDefault(__webpack_require__(173));

var _WeatherCode = _interopRequireDefault(__webpack_require__(174));

var _skycover = __webpack_require__(177);

var _windbarb = __webpack_require__(178);

var _utils = __webpack_require__(176);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const flightRuleColors = {
  VFR: '#1bbe08',
  MVFR: '#1c56cf',
  IFR: '#fa0708',
  LIFR: '#fb06ff'
};

class StationPlotView {
  constructor(obs) {
    obs = obs || {};

    if (obs.ob) {
      const metar = obs.raw;
      const id = obs.id;
      obs = Object.assign(Object.assign({}, obs.ob), {
        id,
        raw: metar
      });
    }

    this._obs = obs;
    this._legend = new _StationPlotLegend.default();
  }

  render(zoom, legend = false) {
    return `
			<div class="station-plot-map-symbol">
				<svg viewbox="0 0 44 44" xmlns="http://www.w3.org/2000/svg" class="wind-barb">
					${this.symbol(this._obs)}
					${zoom >= 7 ? this.values(this._obs) : ''}
					${legend ? this.legend(this._obs) : ''}
				</svg>
			</div>
		`;
  }

  symbol(obs) {
    const {
      sky,
      windSpeedKTS: windSpeed,
      windGustKTS: windGust,
      windDirDEG: direction,
      flightRule
    } = obs;
    const skyColor = flightRuleColors[flightRule] || '#000';
    return `
			${(0, _windbarb.windbarb)(windSpeed, windGust, direction)}
			${(0, _skycover.skycover)((0, _utils.coverageCodeForPercent)(sky), skyColor)}
		`;
  }

  values(obs) {
    const props = {
      font: "'RobotoMono-bold',monospace",
      size: '3.5px',
      stroke: 0.75
    };
    const weather = new _WeatherCode.default(obs.weatherPrimaryCoded, obs);
    return `
			<g transform="translate(13.2, 18.4) scale(.16)">
				${weather.icon}
			</g>
			${(0, _utils.text)(obs.tempF, 19, 18, Object.assign(Object.assign({}, props), {
      fill: 'firebrick'
    }))}
			${(0, _utils.text)(obs.dewpointF, 19, 29, Object.assign(Object.assign({}, props), {
      fill: 'seagreen'
    }))}
			${(0, _utils.text)(obs.pressureMB, 25, 18, Object.assign(Object.assign({}, props), {
      anchor: 'start'
    }))}
			${(0, _utils.text)(obs.id, 25, 29, Object.assign(Object.assign({}, props), {
      anchor: 'start'
    }))}
		`;
  }

  legend(obs) {
    return this._legend.render(this._obs);
  }

}

var _default = StationPlotView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 173 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _WeatherCode = _interopRequireDefault(__webpack_require__(174));

var _utils = __webpack_require__(176);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class StationPlotLegend {
  render(obs) {
    const windSpeed = (0, _utils.roundToInterval)(obs.windSpeedKTS, 5);
    const windGust = (0, _utils.roundToInterval)(obs.windGustKTS, 5);
    const direction = obs.windDirDEG;
    const weather = new _WeatherCode.default(obs.weatherPrimaryCoded, obs);
    return `
			<g class="wind-barb-legend">
				${this.stationId()}
				${this.temp()}
				${this.pressure()}
				${this.dewpoint()}
				${this.skyCover()}
				${this.wind(windSpeed, windGust, direction)}
				${weather.icon && this.weatherCode()}
			</g>
		`;
  }

  stationId() {
    return `
			${(0, _utils.text)('Station ID', 35, 33)}
			${(0, _utils.line)(30.5, 31, 30, 30)}
		`;
  }

  temp() {
    return `
			${(0, _utils.text)('Temp (F)', 17, 13)}
			${(0, _utils.line)(14.5, 14, 15, 15)}
		`;
  }

  pressure() {
    return `
			${(0, _utils.text)('Sea Level Pressure (mB)', 35, 13)}
			${(0, _utils.line)(30, 14, 29.5, 15)}
		`;
  }

  dewpoint() {
    return `
			${(0, _utils.text)('Dew Point (F)', 17, 33)}
			${(0, _utils.line)(14.5, 31, 15, 30)}
		`;
  }

  wind(windSpeed, windGust, direction) {
    const rotation1 = direction > 90 && direction < 270 ? direction - 180 : direction;
    const rotation2 = direction > 90 && direction < 270 ? 180 - direction : 360 - direction;
    const translation = direction > 90 && direction < 270 ? 19 : -19;
    return `
			<g transform="rotate(${rotation1 || 0} 12 12) translate(0 ${translation}) rotate(${rotation2 || 0} 12 12)">
				${(0, _utils.text)('Wind', 23, 22.5, {
      anchor: 'middle'
    })}
				${windGust > windSpeed && (0, _utils.text)('(Gust)', 23, 24, {
      fill: 'red',
      anchor: 'middle'
    })}
			</g>
		`;
  }

  skyCover() {
    return `
			${(0, _utils.text)('Sky Cover', 22, 32, {
      anchor: 'middle'
    })}
			${(0, _utils.text)('&', 22, 33.5, {
      anchor: 'middle'
    })}
			${(0, _utils.text)('Flight Rule', 22, 35, {
      anchor: 'middle'
    })}
			${(0, _utils.line)(22, 30, 22, 26)}
		`;
  }

  weatherCode() {
    return `
			${(0, _utils.text)('Weather', 11, 22.5, {
      link: 'https://www.aviationweather.gov/metar/symbol'
    })}
			${(0, _utils.line)(11.5, 22, 13, 22)}
		`;
  }

}

var _default = StationPlotLegend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 174 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var Icons = _interopRequireWildcard(__webpack_require__(175));

var _utils = __webpack_require__(17);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const coverage = {
  intermittent: ['AR', 'BR', 'IN', 'IS', 'O', 'PA', 'PD', 'SC'],
  continuous: ['NM', 'FQ'],
  forecast: ['C', 'D', 'L', 'S', 'VC', 'WD']
};
const intensity = {
  slight: ['VL', 'L'],
  heavy: ['H', 'VH']
};
const weather = {
  hail: ['A'],
  rain: ['R'],
  drizzle: ['L'],
  rainShowers: ['RW'],
  snow: ['BS', 'S'],
  thunderstorms: ['T'],
  freezingRain: ['ZR'],
  freezingDrizzle: ['ZL'],
  rainAndSnow: ['RS', 'WM', 'SI'],
  iceCrystals: ['IC'],
  icePellets: ['IP'],
  fog: ['F'],
  smoke: ['K', 'VA'],
  haze: ['H'],
  mist: ['BR'],
  blowingDustOrSand: ['BD', 'BS']
};
const icons = {
  mist: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['mist'],
    icon: Icons.lightFog
  },
  lightFog: {
    coverage: [null, 'intermittent'],
    intensity: [null, 'slight', 'moderate'],
    weather: ['fog'],
    icon: Icons.lightFog
  },
  continuousFog: {
    coverage: ['continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['fog'],
    icon: Icons.continuousFog
  },
  drizzleSlightIntermittent: {
    coverage: [null, 'intermittent'],
    intensity: ['slight'],
    weather: ['drizzle'],
    icon: Icons.drizzleSlightIntermittent
  },
  drizzleSlightContinuous: {
    coverage: ['continuous'],
    intensity: ['slight'],
    weather: ['drizzle'],
    icon: Icons.drizzleSlightContinuous
  },
  drizzleModerateIntermittent: {
    coverage: [null, 'intermittent'],
    intensity: [null, 'moderate'],
    weather: ['drizzle'],
    icon: Icons.drizzleModerateIntermittent
  },
  drizzleModerateContinuous: {
    coverage: ['continuous'],
    intensity: [null, 'moderate'],
    weather: ['drizzle'],
    icon: Icons.drizzleModerateContinuous
  },
  drizzleHeavyIntermittent: {
    coverage: [null, 'intermittent'],
    intensity: [null, 'heavy'],
    weather: ['drizzle'],
    icon: Icons.drizzleHeavyIntermittent
  },
  drizzleHeavyContinuous: {
    coverage: ['continuous'],
    intensity: [null, 'heavy'],
    weather: ['drizzle'],
    icon: Icons.drizzleHeavyContinuous
  },
  drizzleFreezingSlight: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight'],
    weather: ['freezingDrizzle'],
    icon: Icons.drizzleFreezingSlight
  },
  drizzleFreezingHeavy: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: ['heavy'],
    weather: ['freezingDrizzle'],
    icon: Icons.drizzleFreezingHeavy
  },
  intermittentSlightRain: {
    coverage: ['intermittent'],
    intensity: ['slight'],
    weather: ['rain'],
    icon: Icons.rainSlightIntermittent
  },
  rainSlightContinuous: {
    coverage: [null, 'continuous'],
    intensity: [null, 'slight'],
    weather: ['rain'],
    icon: Icons.rainSlightContinuous
  },
  rainModerateIntermittent: {
    coverage: [null, 'intermittent'],
    intensity: ['moderate'],
    weather: ['rain'],
    icon: Icons.rainModerateIntermittent
  },
  rainModerateContinous: {
    coverage: ['continuous'],
    intensity: [null, 'moderate'],
    weather: ['rain'],
    icon: Icons.rainModerateContinuous
  },
  rainHeavyIntermittent: {
    coverage: [null, 'intermittent'],
    intensity: ['heavy'],
    weather: ['rain'],
    icon: Icons.rainHeavyIntermittent
  },
  rainHeavyContinuous: {
    coverage: ['continuous'],
    intensity: ['heavy'],
    weather: ['rain'],
    icon: Icons.rainHeavyContinuous
  },
  freezingRainSlight: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: ['slight'],
    weather: ['freezingRain'],
    icon: Icons.rainFreezingSlight
  },
  freezingRainModerateOrHeavy: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: ['moderate', 'heavy'],
    weather: ['freezingRain'],
    icon: Icons.rainFreezingModerateOrHeavy
  },
  rainOrDrizzleAndSnowSlight: {
    coverage: [null, 'intermittent'],
    intensity: ['slight'],
    weather: ['rainAndSnow'],
    icon: Icons.rainOrDrizzleAndSnowSlight
  },
  rainOrDrizzleAndSnowModerateOrHeavy: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: ['moderate', 'heavy'],
    weather: ['rainAndSnow'],
    icon: Icons.rainOrDrizzleAndSnowModerateOrHeavy
  },
  snowIntermittentSlight: {
    coverage: [null, 'intermittent'],
    intensity: ['slight'],
    weather: ['snow'],
    icon: Icons.snowIntermittentSlight
  },
  snowContinuousSlight: {
    coverage: [null, 'continuous'],
    intensity: [null, 'slight'],
    weather: ['snow'],
    icon: Icons.snowContinuousSlight
  },
  snowModerateContinuous: {
    coverage: ['continuous'],
    intensity: ['moderate'],
    weather: ['snow'],
    icon: Icons.snowModerateContinuous
  },
  snowHeavyIntermittents: {
    coverage: ['intermittent'],
    intensity: ['heavy'],
    weather: ['snow'],
    icon: Icons.snowHeavyIntermittent
  },
  snowHeavyContinuous: {
    coverage: [null, 'continuous'],
    intensity: ['heavy'],
    weather: ['snow'],
    icon: Icons.snowHeavyContinuous
  },
  iceCrystals: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['iceCrystals'],
    icon: Icons.iceCrystals
  },
  icePellets: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['icePellets'],
    icon: Icons.icePellets
  },
  rainShowersSlight: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: ['slight'],
    weather: ['rainShowers'],
    icon: Icons.rainShowersSlight
  },
  rainShowersModerateOrHeavy: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'moderate', 'heavy'],
    weather: ['rainShowers'],
    icon: Icons.rainShowersModerateOrHeavy
  },
  thunderstormsSlightOrModerate: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate'],
    weather: ['thunderstorms'],
    icon: Icons.slightThunderstormWithRain
  },
  thunderstormsHeavy: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: ['heavy'],
    weather: ['thunderstorms'],
    icon: Icons.heavyThunderstormWithRain
  },
  vicinityThunderstorm: {
    coverage: ['forecast'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['thunderstorms'],
    icon: Icons.distantLightning
  },
  distantLightning: {
    coverage: [null, 'forecast', 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['distantLightning'],
    icon: Icons.distantLightning
  },
  haze: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['haze'],
    icon: Icons.haze
  },
  smoke: {
    coverage: [null, 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['smoke'],
    icon: Icons.smoke
  },
  virga: {
    coverage: [null, 'forecast', 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['virga'],
    icon: Icons.virga
  },
  squalls: {
    coverage: [null, 'forecast', 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['squalls'],
    icon: Icons.squalls
  },
  tornado: {
    coverage: [null, 'forecast', 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['tornado'],
    icon: Icons.tornado
  },
  blowingDustOrSand: {
    coverage: [null, 'forecast', 'intermittent', 'continuous'],
    intensity: [null, 'slight', 'moderate', 'heavy'],
    weather: ['blowingDustOrSand'],
    icon: Icons.dustOrSand
  }
};

const findMatch = (code, collection, fallback = null) => {
  const result = Object.keys(collection).filter(key => {
    const codes = collection[key];
    return codes.indexOf(code) !== -1;
  });
  return result && result[0] ? result[0] : fallback;
};

class WeatherCode {
  constructor(code, obs) {
    this._code = code || '';
    this._obs = obs;

    this._process(code);
  }

  get coverage() {
    return this._coverage;
  }

  get intensity() {
    return this._intensity;
  }

  get weather() {
    return this._weather;
  }

  get icon() {
    const name = Object.keys(icons).filter(key => icons[key].coverage.includes(this.coverage)).filter(key => icons[key].intensity.includes(this.intensity)).filter(key => icons[key].weather.includes(this.weather));
    return icons[name[0]] ? icons[name[0]].icon : '';
  }

  toString() {
    return `${this.coverage} ${this.intensity} ${this._weather}`.trim();
  }

  _process(code) {
    if (!(0, _utils.isset)(code)) return;
    const parts = code.split(':').map(s => s.toUpperCase());

    if (parts.length === 3) {
      const [coverageCode, intensityCode, weatherCode] = parts;
      this._coverage = findMatch(coverageCode, coverage);
      this._intensity = findMatch(intensityCode, intensity, 'moderate');
      this._weather = findMatch(weatherCode, weather);
    }

    this._overrideWithSpecialCases();
  }

  _overrideWithSpecialCases() {
    const metar = this._obs.raw || ''; // set to a specific weather code because stations do not have this
    // weather code, but show the symbol for lightning in the area

    if (metar.includes(" LTG DSNT ") && !this._weather) {
      this._weather = 'distantLightning';
      return;
    } // set to continuous fog if it contains "CONS" in the remarks.  This
    // is due to this weather type having a certain symbol.


    if (this._weather === 'fog') {
      if (metar.includes(' CONS ')) {
        this._coverage = 'continuous';
      }
    }

    if (!this._weather) {
      if (metar.includes(' VIRGA ')) {
        this._weather = 'virga';
      }

      if (metar.includes(' SQ ')) {
        this._weather = 'squalls';
      }
    } // If it's not a distant funnel cloud, show it.


    if (metar.includes(' FC ') && !metar.includes(' DSNT FC ')) {
      this._weather = 'tornado';
    }
  }

}

var _default = WeatherCode;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.dustOrSand = exports.tornado = exports.squalls = exports.virga = exports.smoke = exports.distantLightning = exports.haze = exports.heavyThunderstormWithRain = exports.slightThunderstormWithRain = exports.rainShowersModerateOrHeavy = exports.rainShowersSlight = exports.icePellets = exports.iceCrystals = exports.snowHeavyContinuous = exports.snowHeavyIntermittent = exports.snowModerateContinuous = exports.snowContinuousSlight = exports.snowIntermittentSlight = exports.rainOrDrizzleAndSnowModerateOrHeavy = exports.rainOrDrizzleAndSnowSlight = exports.rainFreezingModerateOrHeavy = exports.rainFreezingSlight = exports.rainHeavyContinuous = exports.rainHeavyIntermittent = exports.rainModerateContinuous = exports.rainModerateIntermittent = exports.rainSlightContinuous = exports.rainSlightIntermittent = exports.drizzleFreezingHeavy = exports.drizzleFreezingSlight = exports.drizzleHeavyContinuous = exports.drizzleHeavyIntermittent = exports.drizzleModerateContinuous = exports.drizzleModerateIntermittent = exports.drizzleSlightContinuous = exports.drizzleSlightIntermittent = exports.continuousFog = exports.lightFog = exports.defs = void 0;
const defs = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<defs>
			<circle id="wx-symbol-raindrop" cx="12" cy="12" r="2.5" />
			<g id="wx-symbol-snowflake">
				<line x1="8" x2="16" y1="12" y2="12" stroke-linecap="round" />
				<line x1="10" x2="14" y1="9" y2="15" stroke-linecap="round" />
				<line x1="14" x2="10" y1="9" y2="15" stroke-linecap="round" />
			</g>
			<path id="wx-symbol-curve" d="M 12 12 C 12 6, 4 6, 4 12 C 4 14, 4 14, 6 16" fill="transparent" stroke-linecap="round" />
			<polygon id="wx-symbol-triangle-equilateral-up" points="4,20, 20,20, 12,4" fill="transparent"></polygon>
			<polygon id="wx-symbol-triangle-down" points="7,12, 17,12, 12,21" fill="transparent"></polygon>
			<g id="wx-symbol-triangle-down-with-stroke">
				<use xlink:href="#wx-symbol-triangle-down" fill="transparent" stroke-width="3" stroke="white" />
				<use xlink:href="#wx-symbol-triangle-down" fill="transparent" stroke-width="2" stroke="black" />
				<use xlink:href="#wx-symbol-triangle-down" fill="transparent" stroke-width="1" stroke="red" />
			</g>
			<text id="wx-symbol-comma" x="12" y="12" text-anchor="middle" font-family="Times New Roman, cursive, sans-serif">,</text>
			<g id="wx-symbol-comma-with-stroke">
				<use xlink:href="#wx-symbol-comma" stroke="white" stroke-width="2" />
				<use xlink:href="#wx-symbol-comma" fill="firebrick" />
			</g>
			<line id="wx-symbol-line" x1="8" x2="16" y1="12" y2="12" stroke-linecap="round" />
			<g id="wx-symbol-line-with-stroke">
				<use xlink:href="#wx-symbol-line" stroke="white" stroke-width="4" />
				<use xlink:href="#wx-symbol-line" stroke="black" stroke-width="2" />
				<use xlink:href="#wx-symbol-line" stroke="red" stroke-width="1.5" />
			</g>
			<g id="wx-symbol-line-dashed-with-stroke">
				<use xlink:href="#wx-symbol-line" stroke="white" stroke-width="4" stroke-dasharray="2 4" />
				<use xlink:href="#wx-symbol-line" stroke="black" stroke-width="2" stroke-dasharray="2 4" />
				<use xlink:href="#wx-symbol-line" stroke="red" stroke-width="1.5" stroke-dasharray="2 4" />
			</g>
			<g id="wx-symbol-light-fog">
				<use xlink:href="#wx-symbol-line-with-stroke" transform="translate(0, -2)" />
				<use xlink:href="#wx-symbol-line-with-stroke" transform="translate(0, 2)" />
			</g>
			<g id="continuous-dog">
				<use xlink:href="#wx-symbol-line-dashed-with-stroke" transform="translate(0, -2)" />
				<use xlink:href="#wx-symbol-line-with-stroke" transform="translate(0, 2)" />
			</g>
			<g id="wx-symbol-raindrop-with-stroke">
				<use xlink:href="#wx-symbol-raindrop" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-raindrop" fill="red" stroke="black" stroke-width="1.5" />
				<use xlink:href="#wx-symbol-raindrop" fill="red" />
			</g>
			<g id="wx-symbol-snowflake-with-stroke">
				<use xlink:href="#wx-symbol-snowflake" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-snowflake" stroke="black" stroke-width="1.5" />
				<use xlink:href="#wx-symbol-snowflake" stroke="red" stroke-width="1" />
			</g>
			<g id="wx-squiggle">
				<use xlink:href="#wx-symbol-curve" />
				<use xlink:href="#wx-symbol-curve" transform="rotate(180, 12, 12)" />
			</g>
			<g id="wx-symbol-squiggle-with-stroke">
				<use xlink:href="#wx-symbol-squiggle" stroke-width="6" stroke="white" />
				<use xlink:href="#wx-symbol-squiggle" stroke-width="2.25" stroke="black" />
				<use xlink:href="#wx-symbol-squiggle" stroke-width="1.25" stroke="red" />
			</g>
			<g id="wx-symbol-ice-crystal">
				<line x1="4" x2="20" y1="12" y2="12" stroke-linecap="round" />
				<line x1="10" x2="14" y1="9" y2="15" stroke-linecap="round" />
				<line x1="14" x2="10" y1="9" y2="15" stroke-linecap="round" />
			</g>
			<g id="wx-symbol-ice-crystal-with-stroke">
				<use xlink:href="#wx-symbol-ice-crystal" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-ice-crystal" stroke="black" stroke-width="1.5" />
				<use xlink:href="#wx-symbol-ice-crystal" stroke="red" stroke-width="1" />
			</g>
			<g id="wx-symbol-ice-pellet">
				<use xlink:href="#wx-symbol-triangle-equilateral-up" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-triangle-equilateral-up" stroke="black" stroke-width="1.5" />
				<use xlink:href="#wx-symbol-triangle-equilateral-up" stroke="red" stroke-width="1" />
				<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="scale(.75) translate(3.75, 6.75)" />
			</g>
			<g id="wx-symbol-lightning">
				<polyline points="16,6 10,12 16,18" fill="none" stroke-linejoin="round" stroke-linecap="round" />
				<use xlink:href="#wx-symbol-arrowhead" transform="translate(3.5, 5.5) rotate(135, 12, 12)" />
			</g>
			<g id="wx-symbol-lightning-with-stroke">
				<use xlink:href="#wx-symbol-lightning" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-lightning" stroke="black" stroke-width="2" />
				<use xlink:href="#wx-symbol-lightning" stroke="red" stroke-width="1" />
			</g>
			<g id="wx-symbol-triangle-down-with-wx-symbol-line-with-stroke">
				<line x1="10" x2="14" y1="15" y2="15" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-triangle-down-with-stroke" />
				<line x1="10" x2="14" y1="15" y2="15" stroke="black" stroke-width="1.5" />
				<line x1="10" x2="14" y1="15" y2="15" stroke="red" stroke-width="1" />
			</g>
			<path id="wx-symbol-s" d="M 16 10 C 16 6, 8 6, 8 10 L 16 14 C 16 18 8 18 8 14" fill="transparent" />
			<g id="wx-symbol-s-with-stroke">
				<use xlink:href="#wx-symbol-s" stroke="white" stroke-width="3" />
				<use xlink:href="#wx-symbol-s" stroke="black" stroke-width="2" />
				<use xlink:href="#wx-symbol-s" stroke="red" stroke-width="1" />
			</g>
			<path id="wx-symbol-curve2" d="M 6 14 C 6 20, 18 20, 18 14" fill="transparent" stroke-linecap="round" />
			<g id="wx-symbol-curve-with-stroke2">
				<use xlink:href="#wx-symbol-curve2" stroke="white" stroke-width="5" />
				<use xlink:href="#wx-symbol-curve2" stroke="black" stroke-width="3" />
				<use xlink:href="#wx-symbol-curve2" stroke="red" stroke-width="2" />
			</g>
			<path id="wx-symbol-squiggle" d="M 4 4 C 4 0 8 0 8 4 S 12 8, 12 4 S 16 0, 16 4" fill="transparent" stroke-linecap="round" />
			<g id="wx-symbol-smoke-with-stroke" transform="scale(.8, .8) translate(6, 6)">
				<line x1="4" x2="4" y1="18" y2="2" stroke="white" stroke-width="4" stroke-linecap="round" />
				<use xlink:href="#wx-symbol-squiggle" stroke="white" stroke-width="4" />
				<line x1="4" x2="4" y1="18" y2="2" stroke="black" stroke-width="2" stroke-linecap="round" />
				<use xlink:href="#wx-symbol-squiggle" stroke="black" stroke-width="2" />
				<line x1="4" x2="4" y1="18" y2="2" stroke="red" stroke-width="1" stroke-linecap="round" />
				<use xlink:href="#wx-symbol-squiggle" stroke="red" stroke-width="1" />
			</g>
			<polyline id="wx-symbol-arrowhead" points="9,13 12,10 15,13" fill="transparent" stroke-linecap="round" />
			<g id="wx-symbol-light-thunderstorm">
				<line x1="6" x2="8" y1="6" y2="6" stroke-linecap="round" />
				<polyline points="8,18 8,6 16,6 12,12 16,18" fill="none" stroke-linejoin="round" stroke-linecap="round" />
				<use xlink:href="#wx-symbol-arrowhead" transform="translate(3.75, 5.5) rotate(135, 12, 12)" />
			</g>
			<g id="wx-symbol-light-thunderstorm-with-stroke">
				<use xlink:href="#wx-symbol-light-thunderstorm" stroke="white" stroke-width="4" />
				<use xlink:href="#wx-symbol-light-thunderstorm" stroke="black" stroke-width="2" />
				<use xlink:href="#wx-symbol-light-thunderstorm" stroke="red" stroke-width="1" />
			</g>
			<g id="wx-symbol-heavy-thunderstorm">
				<line x1="6" x2="8" y1="6" y2="6" stroke-linecap="round" />
				<polyline points="8,18 8,6 16,6 12,10 16,14, 12,18" fill="none" stroke-linejoin="round" stroke-linecap="round" />
				<use xlink:href="#wx-symbol-arrowhead" transform="translate(0.4, 5.5) rotate(225, 12, 12)" />
			</g>
			<g id="wx-symbol-heavy-thunderstorm-with-stroke">
				<use xlink:href="#wx-symbol-heavy-thunderstorm" stroke="white" stroke-width="4" />
				<use xlink:href="#wx-symbol-heavy-thunderstorm" stroke="black" stroke-width="2" />
				<use xlink:href="#wx-symbol-heavy-thunderstorm" stroke="red" stroke-width="1" />
			</g>
			<g id="wx-symbol-haze">
				<path id="wx-symbol-oval" d="M 12 12 C 10 16, 4 16, 4 12 C 4 8, 10 8, 12 12" fill="transparent" />
				<use xlink:href="#wx-symbol-oval" transform="rotate(180 12 12)" />
			</g>
		</defs>
	</svg>
`;
exports.defs = defs;
const lightFog = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="wx-symbol-wx-symbol-light-fog"/>
	</svg>
`;
exports.lightFog = lightFog;
const continuousFog = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-wx-symbol-continuous-fog"/>
	</svg>
`;
exports.continuousFog = continuousFog;
const drizzleSlightIntermittent = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-comma-with-stroke"/>
	</svg>
`;
exports.drizzleSlightIntermittent = drizzleSlightIntermittent;
const drizzleSlightContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(-3, 0)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(3, 0)"/>
	</svg>
`;
exports.drizzleSlightContinuous = drizzleSlightContinuous;
const drizzleModerateIntermittent = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(-3, 0)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(3, 0)"/>
	</svg>
`;
exports.drizzleModerateIntermittent = drizzleModerateIntermittent;
const drizzleModerateContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(0, -3)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(-4, 3)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(4, 3)"/>
	</svg>
`;
exports.drizzleModerateContinuous = drizzleModerateContinuous;
const drizzleHeavyIntermittent = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(0, -6)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" />
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(0, 6)"/>
	</svg>
`;
exports.drizzleHeavyIntermittent = drizzleHeavyIntermittent;
const drizzleHeavyContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(0, -5)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(-4, 0)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(4, 0)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(0, 5)"/>
	</svg>
`;
exports.drizzleHeavyContinuous = drizzleHeavyContinuous;
const drizzleFreezingSlight = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-squiggle-with-stroke" />
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(-4, 0)"/>
	</svg>
`;
exports.drizzleFreezingSlight = drizzleFreezingSlight;
const drizzleFreezingHeavy = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-squiggle-with-stroke" />
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(-4, 0)"/>
		<use xlink:href="#wx-symbol-comma-with-stroke" transform="translate(4, 0)"/>
	</svg>
`;
exports.drizzleFreezingHeavy = drizzleFreezingHeavy;
const rainSlightIntermittent = `
	<svg id="rain-slight-intermittent" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
	// <use xlink:href="#wx-symbol-raindrop-with-stroke" />
	</svg>
`;
exports.rainSlightIntermittent = rainSlightIntermittent;
const rainSlightContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(-4, 0)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(4, 0)" />
	</svg>
`;
exports.rainSlightContinuous = rainSlightContinuous;
const rainModerateIntermittent = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -4)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, 4)" />
	</svg>
`;
exports.rainModerateIntermittent = rainModerateIntermittent;
const rainModerateContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -4)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(-4, 3)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(4, 3)" />
	</svg>
`;
exports.rainModerateContinuous = rainModerateContinuous;
const rainHeavyIntermittent = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -7)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, 7)" />
	</svg>
	`;
exports.rainHeavyIntermittent = rainHeavyIntermittent;
const rainHeavyContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -6)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(-4, 0)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(4, 0)" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, 6)" />
	</svg>
`;
exports.rainHeavyContinuous = rainHeavyContinuous;
const rainFreezingSlight = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-squiggle-with-stroke" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(-4, 0)"/>
	</svg>
`;
exports.rainFreezingSlight = rainFreezingSlight;
const rainFreezingModerateOrHeavy = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-squiggle-with-stroke" />
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(-4, 0)"/>
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(4, 0)"/>
	</svg>
`;
exports.rainFreezingModerateOrHeavy = rainFreezingModerateOrHeavy;
const rainOrDrizzleAndSnowSlight = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -4)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0, 4)"/>
	</svg>
`;
exports.rainOrDrizzleAndSnowSlight = rainOrDrizzleAndSnowSlight;
const rainOrDrizzleAndSnowModerateOrHeavy = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0, -8)"/>
		<use xlink:href="#wx-symbol-raindrop-with-stroke" />
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0, 8)"/>
	</svg>
`;
exports.rainOrDrizzleAndSnowModerateOrHeavy = rainOrDrizzleAndSnowModerateOrHeavy;
const snowIntermittentSlight = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-snowflake-with-stroke" />
	</svg>
`;
exports.snowIntermittentSlight = snowIntermittentSlight;
const snowContinuousSlight = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(-5,0)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(5,0)"/>
	</svg>
`;
exports.snowContinuousSlight = snowContinuousSlight;
const snowModerateContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0, -5)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(-5, 5)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(5, 5)"/>
	</svg>
`;
exports.snowModerateContinuous = snowModerateContinuous;
const snowHeavyIntermittent = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0,-8)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0,8)"/>
	</svg>
`;
exports.snowHeavyIntermittent = snowHeavyIntermittent;
const snowHeavyContinuous = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0,-7)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(-5, 0)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(5, 0)"/>
		<use xlink:href="#wx-symbol-snowflake-with-stroke" transform="translate(0,7)"/>
	</svg>
`;
exports.snowHeavyContinuous = snowHeavyContinuous;
const iceCrystals = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-ice-crystal-with-stroke" />
	</svg>
`;
exports.iceCrystals = iceCrystals;
const icePellets = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-ice-pellet" />
	</svg>
`;
exports.icePellets = icePellets;
const rainShowersSlight = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -5)" fill="red"/>
		<use xlink:href="#wx-symbol-triangle-down-with-stroke" transform="translate(0, 1)" />
	</svg>
`;
exports.rainShowersSlight = rainShowersSlight;
const rainShowersModerateOrHeavy = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0, -5)" fill="red"/>
		<use xlink:href="#wx-symbol-triangle-down-with-wx-symbol-line-with-stroke" transform="translate(0, 1)" />
	</svg>
`;
exports.rainShowersModerateOrHeavy = rainShowersModerateOrHeavy;
const slightThunderstormWithRain = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0,-8)"/>
		<use xlink:href="#wx-symbol-light-thunderstorm-with-stroke" transform="translate(0, 4)" />
	</svg>
`;
exports.slightThunderstormWithRain = slightThunderstormWithRain;
const heavyThunderstormWithRain = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" transform="translate(0,-8)" />
		<use xlink:href="#wx-symbol-heavy-thunderstorm-with-stroke" transform="translate(0, 4)" />
	</svg>
`;
exports.heavyThunderstormWithRain = heavyThunderstormWithRain;
const haze = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-haze" stroke-width="4" stroke="white" />
		<use xlink:href="#wx-symbol-haze" stroke-width="2" stroke="black"/>
		<use xlink:href="#wx-symbol-haze" stroke-width="1" stroke="red"/>
	</svg>
`;
exports.haze = haze;
const distantLightning = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-lightning-with-stroke" />
	</svg>
`;
exports.distantLightning = distantLightning;
const smoke = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-smoke-with-stroke" />
	</svg>yeahsup
`;
exports.smoke = smoke;
const virga = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<use xlink:href="#wx-symbol-raindrop-with-stroke" />
		<use xlink:href="#wx-symbol-curve-with-stroke2" stroke="red" stroke-width="2"/>
	</svg>
`;
exports.virga = virga;
const squalls = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<defs>
			<polygon id="wx-symbol-chevron" points="6,8 12,12 18,8 12,18" fill="transparent" stroke-linejoin="round"/>
		</defs>
		<use xlink:href="#wx-symbol-chevron" stroke="white" stroke-width="4" />
		<use xlink:href="#wx-symbol-chevron" stroke="black" stroke-width="2" />
		<use xlink:href="#wx-symbol-chevron" stroke="red" stroke-width="1" />
	</svg>
`;
exports.squalls = squalls;
const tornado = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<g id="wx-symbol-tornado-curve">
			<path d="M 4 20, C 8 20, 6 18, 8 16 L 8 8 C 6 4, 8 6, 4 4" fill="transparent" stroke-width="1" stroke="black"/>
		</g>
		<use xlink:href="#wx-symbol-tornado-curve" fill="transparent" stroke-width="1" stroke="black" />
		<path d="M 4 20, C 8 20, 6 18, 8 16 L 8 8 C 6 4, 8 6, 4 4" fill="transparent" stroke-width="1" stroke="black" transform="translate(2, 0)"/>
		<path d="M 4 20, C 8 20, 6 18, 8 16 L 8 8 C 6 4, 8 6, 4 4" fill="transparent" stroke-width="1" stroke="black" transform="rotate(180, 12, 12) translate(2, 0)"/>
	</svg>
`;
exports.tornado = tornado;
const dustOrSand = `
	<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
		<line x1="12" x2="12" y1="4" y2="20" stroke="white" stroke-width="3" />
		<use xlink:href="#wx-symbol-s-with-stroke"/>
		<line x1="12" x2="12" y1="4" y2="20" stroke="black" stroke-width="1.5" />
		<line x1="12" x2="12" y1="4" y2="20" stroke="red" stroke-width="1" />
	</svg>
`;
exports.dustOrSand = dustOrSand;

/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.line = exports.text = exports.coverageCodeForPercent = exports.roundToInterval = void 0;

var _utils = __webpack_require__(17);

const roundToInterval = (value, int) => Math.floor((value + int / 2) / int) * int;

exports.roundToInterval = roundToInterval;

const coverageCodeForPercent = percent => {
  if (!(0, _utils.isset)(percent)) {
    return null;
  }

  if (percent === 100) {
    return 8;
  }

  if (percent > 80) {
    return 7;
  }

  if (percent > 60) {
    return 6;
  }

  if (percent > 50) {
    return 5;
  }

  if (percent > 40) {
    return 4;
  }

  if (percent > 30) {
    return 3;
  }

  if (percent > 20) {
    return 2;
  }

  if (percent > 10) {
    return 1;
  }

  return 0;
};

exports.coverageCodeForPercent = coverageCodeForPercent;

const text = (value, x, y, opts) => {
  opts = (0, _utils.extend)({
    anchor: 'end',
    size: '1.5px',
    font: null,
    fill: 'black',
    stroke: 0.5,
    link: null
  }, opts);
  const style = {
    'font-size': opts.size
  };

  if (opts.font) {
    style['font-family'] = opts.font;
  }

  const styleStr = `${Object.keys(style).map(prop => `${prop}: ${style[prop]}`).join('; ')};`;

  if (opts.link) {
    return `
			<text x="${x}" y="${y}" text-anchor="${opts.anchor}" style="${styleStr}" stroke="white" stroke-width="${opts.stroke}">${value}</text>
			<a href="https://www.aviationweather.gov/metar/symbol" target="_blank">
				<text x="${x}" y="${y}" text-anchor="${opts.anchor}" style="${styleStr} text-decoration: underline; cursor: pointer;" fill="${opts.fill}">${value}</text>
			</a>
		`;
  }

  return `
		<text x="${x}" y="${y}" text-anchor="${opts.anchor}" style="${styleStr}" stroke="white" stroke-width="${opts.stroke}">${value}</text>
		<text x="${x}" y="${y}" text-anchor="${opts.anchor}" style="${styleStr}" fill="${opts.fill}">${value}</text>
	`;
};

exports.text = text;

const line = (x1, y1, x2, y2) => `
	<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="white" stroke-width=".5"></line>
	<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="black" stroke-width=".2"></line>
`;

exports.line = line;

/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.skycover = exports.circle = exports.pie = exports.DEFAULT_Y = exports.DEFAULT_X = exports.BASE_RADIUS = void 0;
const BASE_RADIUS = 0.9;
exports.BASE_RADIUS = BASE_RADIUS;
const DEFAULT_X = 22;
exports.DEFAULT_X = DEFAULT_X;
const DEFAULT_Y = 22;
/*
 * Builds the sky cover symbol for sky obscured
 */

exports.DEFAULT_Y = DEFAULT_Y;

const obscured = ({
  x = DEFAULT_X,
  y = DEFAULT_Y,
  radius = BASE_RADIUS * 2,
  fill = 'transparent',
  rotation = -90,
  strokeWidth = 0.5,
  strokeColor = 'black'
} = {}) => {
  const x1 = x - radius;
  const x2 = x + radius;
  return `<line
		x1="${x1}"
		x2="${x2}"
		y1="${y}"
		y2="${y}"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		transform="rotate(-45 ${x} ${y})"/>
		<line
		x1="${x1}"
		x2="${x2}"
		y1="${y}"
		y2="${y}"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		transform="rotate(45 ${x} ${y})"
	/>`;
};
/*
 * Builds the sky cover symbol for "missing"
 */


const missing = ({
  strokeWidth = 0.5,
  strokeColor = 'black'
} = {}) => `
	<line
		x1="11.25"
		x2="11"
		y1="10.5"
		y2="13.5"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		stroke-linecap="round"
	/>
	<line
		x1="11.25"
		x2="12"
		y1="10.5"
		y2="12.5"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		stroke-linecap="round"
	/>
	<line
		x1="12.75"
		x2="12"
		y1="10.5"
		y2="12.5"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		stroke-linecap="round"
	/>
	<line
		x1="12.75"
		x2="13"
		y1="10.5"
		y2="13.5"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		stroke-linecap="round"
	/>
`;
/*
 * Builds the pie symbol representing the amount of sky coverage there is.
 */


const pie = ({
  x = DEFAULT_X,
  y = DEFAULT_Y,
  radius = BASE_RADIUS,
  fill = 'transparent',
  rotation = -90,
  strokeWidth = BASE_RADIUS * 2,
  strokeColor = 'black',
  fillPercentage = 1
} = {}) => `
	<circle
		cx="${x}"
		cy="${y}"
		r="${radius}"
		fill="${fill}"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
		stroke-dasharray="${2 * Math.PI * radius * fillPercentage} ${2 * Math.PI * radius}"
		transform="rotate(${rotation} ${x} ${y})"
	/>
`;
/*
 * Builds the backing circle of the sky cover symbol
 */


exports.pie = pie;

const circle = ({
  x = DEFAULT_X,
  y = DEFAULT_Y,
  radius = BASE_RADIUS * 2,
  fill = 'white',
  strokeWidth = 0.5,
  strokeColor = 'black'
} = {}) => `
	<circle
		cx="${x}"
		cy="${y}"
		r="${radius}"
		fill="${fill}"
		stroke="#ffffff"
		stroke-width="${strokeWidth + 1.5}"
	/>
	<circle
		cx="${x}"
		cy="${y}"
		r="${radius}"
		fill="${fill}"
		stroke="#000000"
		stroke-width="${strokeWidth + 0.5}"
	/>
	<circle
		cx="${x}"
		cy="${y}"
		r="${radius}"
		fill="${fill}"
		stroke="${strokeColor}"
		stroke-width="${strokeWidth}"
	/>
`;
/*
 * Builds the hand of the wind barb.
 */


exports.circle = circle;

const hand = ({
  x1 = DEFAULT_X,
  y1 = DEFAULT_X - BASE_RADIUS * 2,
  x2 = DEFAULT_Y,
  y2 = DEFAULT_Y + BASE_RADIUS * 2,
  strokeColor = "black",
  strokeWidth = 0.75,
  rotation = 0
} = {}) => {
  const centerX = x2 - Math.abs((x2 - x1) / 2);
  const centerY = y2 - Math.abs((y2 - y1) / 2);
  return `
		<line
			x1="${x1}"
			y1="${y1}"
			x2="${x2}"
			y2="${y2}"
			stroke="${strokeColor}"
			stroke-width="${strokeWidth}"
			transform="rotate(${rotation} ${centerX} ${centerY})"
		/>
	`;
};

const symbols = {
  missing: color => `
		${circle({
    strokeColor: color
  })}
		${missing({
    strokeColor: color
  })}
	`,
  0: color => `
		${circle({
    strokeColor: color
  })}
	`,
  1: color => `
		${circle({
    strokeColor: color
  })}
		${hand({
    strokeColor: color
  })}
	`,
  2: color => `
		${circle({
    strokeColor: color
  })}
	`,
  3: color => `
		${circle({
    strokeColor: color
  })}
		${pie({
    strokeColor: color,
    fillPercentage: 0.25
  })}
		${hand({
    strokeColor: color
  })}
	`,
  4: color => `
		${circle({
    strokeColor: color
  })}
		${pie({
    strokeColor: color,
    fillPercentage: 0.5
  })}
	`,
  5: color => `
		${circle({
    strokeColor: color
  })}
		${pie({
    strokeColor: color,
    fillPercentage: 0.5
  })}
		${hand({
    strokeColor: color,
    rotation: 90
  })}
	`,
  6: color => `
		${circle({
    strokeColor: color
  })}
		${pie({
    strokeColor: color,
    fillPercentage: 0.75
  })}
	`,
  7: color => `
		${circle({
    strokeColor: color
  })}
		${pie({
    strokeColor: color
  })}
		${hand({
    strokeColor: '#ffffff'
  })}
	`,
  8: color => `
		${circle({
    strokeColor: color
  })}
		${pie({
    strokeColor: color
  })}
	`,
  9: color => `
		${circle({
    strokeColor: color
  })}
		${obscured({
    strokeColor: color
  })}
	`
};

const skycover = (code, color = '#000') => {
  if (symbols[code]) {
    return symbols[code](color);
  }

  return symbols.missing(color);
};

exports.skycover = skycover;

/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.windbarb = void 0;

var _skycover = __webpack_require__(177);

var _utils = __webpack_require__(176);

const build = (startY, windSpeed, strokeColor, strokeWidth, lineCap) => {
  let offset = startY;
  let result = '';

  if (windSpeed <= 5) {
    return `
			<line
				x1="${_skycover.DEFAULT_X}" y1="${4.5 + offset}"
				x2="${_skycover.DEFAULT_X + 2}" y2="${3.25 + offset}"
				stroke="white" stroke-width="1.5"
				stroke-linecap="round"
			/>
			<line
				x1="${_skycover.DEFAULT_X}" y1="${4.5 + offset}"
				x2="${_skycover.DEFAULT_X + 2}" y2="${3.25 + offset}"
				stroke="black"
				stroke-width=".5"
				stroke-linecap="round"
			/>
		`;
  }

  while (windSpeed >= 5) {
    if (windSpeed >= 50) {
      result += `
				<polygon
					points="${_skycover.DEFAULT_X},${2 + offset} ${_skycover.DEFAULT_X + 4},${2 + offset} ${_skycover.DEFAULT_X},${4.5 + offset}"
					fill="${strokeColor}"
					stroke-linejoin="round"
					stroke="${strokeColor}"
					stroke-width="${strokeWidth}"
				/>
			`;
      offset += 2.75;
      windSpeed -= 50;
    } else if (windSpeed >= 10) {
      result += `
				<line
					x1="${_skycover.DEFAULT_X}"
					y1="${3 + offset}"
					x2="${_skycover.DEFAULT_X + 4}"
					y2="${0.5 + offset}"
					stroke="${strokeColor}"
					stroke-width="${strokeWidth}"
					stroke-linecap="${lineCap}"
				/>
			`;
      offset += 1.5;
      windSpeed -= 10;
    } else if (windSpeed >= 5) {
      result += `
				<line
					x1="${_skycover.DEFAULT_X}" y1="${3 + offset}"
					x2="${_skycover.DEFAULT_X + 2}" y2="${1.75 + offset}"
					stroke="${strokeColor}"
					stroke-width="${strokeWidth}"
					stroke-linecap="${lineCap}"
				/>
			`;
      windSpeed -= 5;
    }
  }

  return result;
};

const calm = ({
  radius = _skycover.BASE_RADIUS,
  strokeColor = 'black'
} = {}) => `
	${(0, _skycover.circle)()}
	${(0, _skycover.circle)({
  radius,
  strokeColor
})}
`;

const flags = (startY, windSpeed, windGust) => {
  let result = '';
  const windSpeedInterval = (0, _utils.roundToInterval)(windSpeed, 5);
  const windGustInterval = (0, _utils.roundToInterval)(windGust, 5);
  result += build(startY, windGustInterval, 'white', 1.5, 'round');
  result += build(startY, windSpeedInterval, 'white', 1.5, 'round'); // TODO: wind gusts dont work for wind speeds <= 10. pass wind into
  // and color into function

  result += build(startY, windGustInterval, 'red', 0.5, 'round');
  result += build(startY, windSpeedInterval, 'black', 0.5, 'round');
  return result;
};

const windbarb = (windSpeed, windGust, direction = 0) => {
  const windSpeedInterval = (0, _utils.roundToInterval)(windSpeed, 5);
  const windGustInterval = (0, _utils.roundToInterval)(windGust, 5);

  if (!windSpeed || windSpeedInterval === 0) {
    return calm();
  }

  return `
		<g transform="${direction && `rotate(${direction || 0} ${_skycover.DEFAULT_X} ${_skycover.DEFAULT_Y})`}">
			<line class="barb2" x1="${_skycover.DEFAULT_X}" y1="${_skycover.DEFAULT_Y}" x2="${_skycover.DEFAULT_X}" y2="${_skycover.DEFAULT_Y - 16}" stroke="white" stroke-width="1.5" stroke-linecap="round"/>
			${flags(_skycover.DEFAULT_Y - 19, windSpeedInterval, windGustInterval)}
			<line class="barb" x1="${_skycover.DEFAULT_X}" y1="${_skycover.DEFAULT_Y}" x2="${_skycover.DEFAULT_X}" y2="${_skycover.DEFAULT_Y - 16}" stroke="black" stroke-width=".5" stroke-linecap="round" />
		</g>
	`;
};

exports.windbarb = windbarb;

/***/ }),
/* 179 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(180)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 180 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = __webpack_require__(167);

var _index = __webpack_require__(17);

var _utils = __webpack_require__(181);

var _units = __webpack_require__(182);

var _strings = __webpack_require__(133);

__webpack_require__(184);

class Systems extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'tropical-systems';
  }

  source() {
    const properties = {
      id: 'id',
      category: 'details.stormCat',
      timestamp: 'timestamp',
      points: ['track', 'forecast'],
      path: 'errorCone'
    };
    return {
      type: 'vector',
      data: {
        request: {
          endpoint: 'tropicalcyclones/archive',
          action: "search"
          /* SEARCH */
          ,
          parameters: {
            filter: 'active,geo',
            limit: 50
          }
        },
        properties,
        formatter: data => (0, _utils.formatStormData)(data)
      },
      style: {
        marker: data => (0, _utils.getStormMarkerConfig)(data),
        polygon: data => ({
          fill: {
            color: '#ffffff',
            opacity: 0.7
          }
        }),
        polyline: data => {
          const type = (0, _index.get)(data, 'details.stormCat');
          return {
            adjustOpacity: false,
            stroke: {
              color: (0, _utils.color)(type),
              width: 3
            }
          };
        }
      },
      animation: {
        enabled: true
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Cyclones',
      filter: true,
      multiselect: false,
      segments: [{
        title: 'Active Cyclones',
        value: 'active,geo'
      }, {
        title: 'All Cyclones',
        value: 'active;notactive,geo'
      }]
    };
  }

  legend() {
    return {
      title: 'Tropical Cyclones',
      code: 'tropical-cyclones'
    };
  }

  infopanel() {
    return {
      views: [{
        renderer: data => {
          if (!(0, _index.isset)(data) || (0, _index.isEmpty)(data)) return null;
          if ((0, _index.isEmpty)(data.details) || (0, _index.isEmpty)(data.profile)) return null;
          const category = (0, _index.get)(data, 'details.stormCat');
          const [lon, lat] = (0, _index.get)(data, 'location.coordinates');
          const startTime = (0, _index.get)(data, 'profile.lifespan.startTimestamp');
          const endTime = (0, _index.get)(data, 'profile.lifespan.endTimestamp');
          const metric = data.units === "metric"
          /* Metric */
          ;
          const advisoryInfo = [];
          const advisoryNumber = (0, _index.get)(data, 'details.advisoryNumber');
          const advisoryTimestamp = data.timestamp;

          if ((0, _index.isset)(advisoryNumber)) {
            advisoryInfo.push(`Advisory #${advisoryNumber}`);
          }

          if ((0, _index.isset)(data.timestamp)) {
            advisoryInfo.push((0, _index.formatDate)(new Date(advisoryTimestamp * 1000), 'h:mm a, MMM d, yyyy'));
          }

          return `
						<div class="awxjs__tropical-system awxjs__tropical-system-profile">
							<div class="awxjs__tropical-system-profile__header awxjs__ui-row">
								<div class="awxjs__tropical-system-profile__icon">
									<img src="${(0, _utils.icon)(category)}">
									${/^H/.test(category) ? `<div class="awxjs__tropical-system-profile__icon-label">${category.replace(/^H/, '')}</div>` : ''}
								</div>
								<div class="awxjs__tropical-system-profile__metadata">
									<div class="awxjs__tropical-system-profile__name">${(0, _index.get)(data, 'details.stormName')}</div>
									<div class="awxjs__tropical-system-profile__timestamp">
										<span class="timestamp">
											${data.isForecast ? 'Forecast' : advisoryInfo.join(' - ')}
										</span>
									</div>
								</div>
							</div>
							<div class="awxjs__tropical-system-profile__details">
								<div class="awxjs__ui-row">
									<div class="awxjs__ui-expand label">Basin</div>
									<div class="awxjs__ui-expand value">${(0, _index.get)(data, 'details.basin')}</div>
								</div>
								<div class="awxjs__ui-row">
									<div class="awxjs__ui-expand label">Location</div>
									<div class="awxjs__ui-expand value">${lat && lon ? (0, _strings.toCoord)(lat, lon, 1) : 'N/A'}</div>
								</div>
								<div class="awxjs__ui-row">
									<div class="awxjs__ui-expand label">Moving</div>
									<div class="awxjs__ui-expand value">
									${(0, _index.get)(data, 'details.movement.speedMPH') === 0 ? `Stationary` : `
										${(0, _index.get)(data, 'details.movement.direction') || ''}
										${(0, _units.formatDataValue)(data, 'details.movement.speedMPH', 'details.movement.speedKPH', metric)}
									`}
									</div>
								</div>
								<div class="awxjs__ui-row">
									<div class="awxjs__ui-expand label">Winds</div>
									<div class="awxjs__ui-expand value">${(0, _index.get)(data, 'details.windSpeedMPH') > 0 ? `
										${(0, _units.formatDataValue)(data, 'details.windSpeedMPH', 'details.windSpeedKPH', metric)}&nbsp;
										${(0, _index.get)(data, 'details.gustSpeedMPH') > 0 ? `(${(0, _units.formatDataValue)(data, 'details.gustSpeedMPH', 'details.gustSpeedKPH', metric)} gusts)` : ''}
									` : `Calm`}</div>
								</div>
								<div class="awxjs__ui-row">
									<div class="awxjs__ui-expand label">Pressure</div>
									<div class="awxjs__ui-expand value">${(0, _units.formatDataValue)(data, 'details.pressureIN', 'details.pressureMB', metric)}</div>
								</div>
							</div>
						</div>
					`;
        }
      }, {
        title: 'System Summary',
        renderer: data => {
          if (!(0, _index.isset)(data) || (0, _index.isEmpty)(data)) return null;
          if ((0, _index.isEmpty)(data.details) || (0, _index.isEmpty)(data.profile)) return null;
          const category = (0, _index.get)(data, 'details.stormCat');
          const [lon, lat] = (0, _index.get)(data, 'location.coordinates');
          const startTime = (0, _index.get)(data, 'profile.lifespan.startTimestamp');
          const endTime = (0, _index.get)(data, 'profile.lifespan.endTimestamp');
          const metric = data.units === "metric"
          /* Metric */
          ;
          const advisoryInfo = [];
          const advisoryNumber = (0, _index.get)(data, 'details.advisoryNumber');
          const advisoryTimestamp = data.timestamp;

          if ((0, _index.isset)(advisoryNumber)) {
            advisoryInfo.push(`Advisory #${advisoryNumber}`);
          }

          if ((0, _index.isset)(data.timestamp)) {
            advisoryInfo.push((0, _index.formatDate)(new Date(advisoryTimestamp * 1000), 'h:mm a, MMM d, yyyy'));
          }

          return `
						<div class="awxjs__tropical-system awxjs__tropical-system-profile">
							<div class="awxjs__tropical-system-profile__summary">
								${(0, _index.isset)(startTime) ? `
									<div class="awxjs__ui-row">
										<div class="awxjs__ui-expand label">Lifespan</div>
										<div class="awxjs__ui-expand value">
											${(0, _index.formatDate)(new Date(startTime * 1000), 'L/d/yyyy')}${' - '}
											${(0, _index.isset)(endTime) ? (0, _index.formatDate)(new Date(endTime * 1000), 'L/d/yyyy') : ''}
										</div>
									</div>
								` : ''}
								${(0, _index.get)(data, 'profile.windSpeed.maxMPH') > 0 ? `
									<div class="awxjs__ui-row">
										<div class="awxjs__ui-expand label">Max Winds</div>
										<div class="awxjs__ui-expand value">
											${(0, _units.formatDataValue)(data, 'profile.windSpeed.maxMPH', 'profile.windSpeed.maxKPH', metric)}
											on ${(0, _index.formatDate)(new Date((0, _index.get)(data, 'profile.windSpeed.maxTimestamp') * 1000), 'L/d/yyyy')}
										</div>
									</div>
								` : ''}
								${(0, _index.get)(data, 'profile.pressure.minIN') > 0 ? `
									<div class="awxjs__ui-row">
										<div class="awxjs__ui-expand label">Min Pressure</div>
										<div class="awxjs__ui-expand value">
											${(0, _units.formatDataValue)(data, 'profile.pressure.minIN', 'profile.pressure.minMB', metric)}
											on ${(0, _index.formatDate)(new Date((0, _index.get)(data, 'profile.pressure.minTimestamp') * 1000), 'L/d/yyyy')}
										</div>
									</div>
								` : ''}
							</div>
						</div>
					`;
        }
      }]
    };
  }

  onInit() {// Perform custom actions when the module has been initialized with a map application
    // instance.
  }

  onAdd() {// Perform custom actions when the module's map source has been added to the map and is
    // active.
  }

  onRemove() {// Perform custom actions when the module's map source has been removed from the map and
    // is no longer active.
  }

  onMarkerClick(marker, data) {
    this.showInfoPanel(data.profile.name, data);
  }

  onShapeClick(shape, data) {// Perform custom actions when a vector shape object associated with the module's map
    // source was clicked on the map. You can use this method to perform additional actions or
    // to display the info panel for the module with the shape's data, e.g.:
    //
    // this.showInfoPanel(`Outlook`, data);
  }

}

var _default = Systems;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getTropMarkerContent = exports.getStormMarkerConfig = exports.formatStormData = exports.getAlertTypeName = exports.getStormTypeName = exports.icon = exports.color = void 0;

var _index = __webpack_require__(17);

const flipForSouthernLat = code => {
  const skip = ['DB', 'WV', 'I', 'LO'];
  return skip.indexOf(code) === -1;
};

const color = (code = '') => {
  code = code.toUpperCase();

  switch (code) {
    case 'DB':
    case 'WV':
    case 'I':
    case 'LO':
    case 'EX':
      return '#4875fb';

    case 'TD':
      return '#FFFF00';

    case 'TS':
      return '#FFA801';

    case 'H':
      return '#DD0101';

    case 'H1':
      return '#DD0101';

    case 'H2':
      return '#FF0491';

    case 'H3':
      return '#DD00FD';

    case 'H4':
      return '#FEAFFF';

    case 'H5':
      return '#EFEFEF';

    case 'TY':
      return '#DD0101';

    case 'STY':
      return '#EFEFEF';

    default:
      return '#000000';
  }
};

exports.color = color;

const icon = (code = '') => {
  code = code.toUpperCase();

  switch (code) {
    case 'DB':
    case 'WV':
    case 'I':
    case 'LO':
    case 'EX':
      return `data:image/png;base64,
			iVBORw0KGgoAAAANSUhEUgAAADIAAAAxCAYAAACYq/ofAAAAnklEQVR4Ae3PIQwB
			cQCF8dckkikGfaJsZnrRm6AXVaAnfdM0mz5FE1TZphLFuxfv2u3+u93d7fu2199P
			1Y2IiIiIjuruPxo9XhrcErt/Nb6u1Z7VCXIxJPL51Az5GbICAgQIECBAgAABAgQI
			kJwB8f7e2dt6uww7vDXcnNTrlA0JniFPQ/oqMiBAgACZGLL0kXngFoZMDWmpGRER
			ERHFyMkdx1u9TkkAAAAASUVORK5CYII=`;

    case 'TD':
      return `data:image/png;base64,
			iVBORw0KGgoAAAANSUhEUgAAADIAAAAxCAYAAACYq/ofAAAHl0lEQVR42tWaCWwU
			VRjHv3a7pbSUUtrSC7a70HBoIXI15VAaCgoK0VQxQsELKoF4cgTLZUASEqMIBlSq
			IUgMlxoQ4gohyF0OURCMoQstCIKQcpWjlKMdfxOmcRxndndKm7Zf8k+TzrzjN+97
			733veyt27FtJzK4QT16mNIuXpmrrJWn+DfHM6F4LiInSMvWSuEcdk3bvoZVoN9qm
			aQf6ES1Bk/8UV79V0ia8XiBKxFVIRwozJDxZgrRp0iq9TNwFdO4XpNjULbS5VFwj
			f5CkuDqB2CTJG8vFvb+zON2iM68kRT8pkU4x2PvSOuuCpHnpyB2k1IGunRDXvK2S
			3LrWEBSeRyV3Loo7S3S2QtpE3hbPwgES0Vs0+1Di0v+WtG9ouMpPpyrQLvQxeh0N
			Ro+hbO3vMDQNLUCH0C1d2evHpV3BHkmx53bbJWUkBatwjykdxNncAJJ7Wlxqh0cL
			xt930CWLzt9G31FPDu4WKTYML4jmI46l/AZUiRSftDu5V1K7SzAGtQuIS7hIsVvC
			UgUzgHwNiKJNUi+6ZgJwgXk1k4n+wCscfQihLynUOQWVFTNSByV1bDAgawFRKPwi
			lfxnKFlRYlhZ/E3gqivinv+KRMdIHVuSOELO3QdaBIxyWNp+KlbGsD3N8N08L2nn
			UiUsWTADyFhALlhA7AWiv9SzxUqoA4/oR3tHj0rbQiuQg4AogBQAEmkCsgYQq9FY
			A0g3sWk50jzurrR/Zpkk2PoIJ8XVhja/Qm+L3vC7QcWavwOSYbKzdzslLl+gJROY
			1+zCXKWMVv4EbcynrSwJwpwSEkaflxtBVvDPavzwCP6YYAIylUauWABU0pnPR0hU
			O6mFsZQ/RPkDuvruokNsxgXsZW6xY4CUA6IAshiQaBOQrYAYAUrowPxhEtlWHtCo
			5yWLj3QPHWEBeouFKFH8GSvAE0DcpIAKkg9IM0Os9QghQ6mu8lIanoB/A1w31lci
			OuKW+4wgRij6uZ2P3tEKZBovVGogIwBxGkDeBeSWCkBj42g0SurBqDvPD8RNH0sv
			C1KmvxHxFkP7l6Qp8eJINIl+FxD9DiT6dYiJEaLEEqJk0thAlI1y2BB7sCHaGjGO
			CF2BOW02EriWF9cKDeRaRYBU6UBsGSCDATmmbxyQfYD0tAkSAcgksxEBpAKQDwKB
			VACiNCiIZox6l8viPmkGg2tdxbWymwpIBCBvavUcRqv19dLPEia70y+INtkz1bim
			QUA04xCXQfnj6q6NOqAbOpAKQCYHBtFWrQYGib0unmdZZNKjJTSUAHaMYVRO0+eI
			QCDzAIlqSBCjEfclEDbt0YHcos/jLZdfDWQDILGNDCQEkH46kCp1pTUDWcnDuxrI
			VUCSGxOIdh6Jo2879UkKwvgUI8j4Yt0ZGfqn+AqORgbSDJB8XRt3AJloBOkMyA0d
			iBeQuIYGMVo8UTlbRHXNbg/IUrPo9zdgal5Sj7pdGyFIDCDbtDaqAdlvBjJX716A
			FHJmj21kIM0BmVPTBiC3zUDiAbms70wZgZ9otlNSWvaRiLAGBgkDJFcPYnVm/8hH
			OK8DORAjoQlrJbEj0e8ywodOgUDs6Kyk3Vwi8bPswADSIRiQWEDKDA3mo7naeXxk
			Q4OQRYkni6IDsc5rzTiuW8HQNXRJAyki1E5vKiAhgBSpq4JFliSvSYBoud+2wPxh
			AbKFo67HANILkBU8L0LbgtROQDYBMkZMjMWiC1mU2WRR2luAVANSHAgkBhCvmpYx
			gyHxMFzqyfhQnbTEmwKIz8+IVAGy2Wqyt/HdT+tXmADoQdaTi0qTOjLqclCnet7f
			XvPxSHaUc9Ez07D8Oli1cmpyX4BM9zdHBjEai3jxLKr2A5P7oABDJFIFeJz69hvr
			B+QUID0NIOGAvFqTFASkr2h3Gy8zfK393Fj153kh7103AdlIXstTG4BciYqk/PPU
			8zNSTCAUDlU7TDbEFoAs17Lx5wSrAWmF1pEQTgxwGeqk8iG8+xm6rIEogAy1C0Fa
			dQBlT5kA6EGuqrk0E5DWgJwE5N7/rhUYnocp/CsTqD8TKWDozkVPDO/mUmY3HfoE
			90iuxYgkUHau1U0XID5APCb3I5naweo6IElmB6ssHl6EdhLUEVLPBkgcIAvNINT8
			MnnmdSbnkWhAFqtuRVz4vb8k9nO8dF5d4zmP9OA8ElrXAHnSIvTK/blRghQLkDJA
			xpuAJANyjT6W09d08Wcsvx7fv414CRp7cRnqeFCAcRIdTq5qMHVusgD4HS3WQI4A
			Ems4s0fycaf7eE4fZwd7Gepg+V2l3cgqaBeaSkfSiH6DzndNkVahF9mdKTsLlVqN
			AO68eoHEOduLM6NSPGe5FVsvBuNspM7jckAOAuKwe8/+AvfsRhc4ir5EM9Aw9CjK
			1tQPjUJz0Ep0NkCs5SNEGa67VmgJyGhAJhpudWMB+YKPe4aPnFbbXz6EsY+Mo9ET
			SKkjnSYuG0981sxkh3f+JMktRTPcOhz3zgfiHmGTjaXexj5iU+VoNV92gNgwXLMP
			XnEF7xgi9WHcwHY+I643tF/1eNEOwy9+tqClaAKd6arOF7FpRL+98YadeMVQaarG
			wpKJB6wm1grqbvIfGtZ9jk1z5nQAAAAASUVORK5CYII=`;

    case 'TD-FLIPPED':
      return `data:image/png;base64,
			iVBORw0KGgoAAAANSUhEUgAAADIAAAAxCAYAAACYq/ofAAAAGXRFWHRTb2Z0d2Fy
			ZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACgpJREFUeNrMWgl0VNUZ/mbLSsiELCZM
			lgGJRCgWKKAsNimboVZQFj3UQwq0hRZaelrSA1Joe6QCbZEjEGyB44JGqGDLUmSr
			KHOIIBBCElE2JetkJwwJIRsz0+8mb8jzMW+SgXiY/5z/ZO59d+67//237/8ngA/S
			EPgH1MKcehXxiz9EtK4r39Hc68veROSACQh8ogHOPhw+Rg4j26XH4uW15GLyuQjo
			jq+BrXAtbLe7uv934GewoPcUGxw/uYLWH6eivL7bBPkAD00YBv9pTXA+Lx3cG6oj
			HwyD9h9bUG9Z0SanZ0qCQZ8F03MU5s9FaH1qHMpL71mQQ4jRJ8IwuxXOpRw+3E3W
			UxIK7Svv4ebb6bjWLH+QjADDnxAWOBblQnC+0BDyGUzpNtjnWmEfmYKyUq8FOYqY
			1AQYNtyGM1E2LczlY3Il+TS5WjIlQc1tVgH0bbtQcS7PmrsSAu3iPWj470LUYBQC
			Qj9GzKTdaNDPRFWma5EZ+phTMO2ugyO8CvbE0Si7ayO9u90/RW9dFHSZNPipFMKP
			U1nkfZzbSfUWn0Oz08PhTro+pMOoWQrj0BrYp3M4w41GE+vh2DcFwe83wzkrA3Vx
			nHuVfIacKVtXTp5HziMfIU/sVOcnYepzGXFfX0Sck3ygGuZhVK/ufm3pZwjRMxJN
			555fSHsr+Tw5Q3wuRHw+/fEbmjRBH1SBhGU8m5Nn/I1H08qGaTxV/Q6vu9II7c+/
			B2uOFbcd3RlaX0QPbQYiplfCvloywbsoAJqabDQvn47KzfL5aOhichB7iVp0kPsN
			g7XG9Uzr+pCL2CQKsT0Y2q1jUDYqGkXZ3S2EIDq4IwyFO5ehdgQPtl5lWQQ5VSXy
			bSSHktfJH7QJ8jliB/IWtgdCM3UQSl6mTTd25VCbERl3G33TUhF0L9FMKx3srjjM
			8I6h8B+4B9F9FI8ayMJiwEufKi7/zma0SaMBmnR/aFIHoDTrOhx2T2/fgShjEeKf
			4/csDJXFN+FI4fRNbySYgeBkJtQzFbCv4LCXyrIo8gvyCa5n5i2t6AGthcMg8iL5
			rTxLQRY/ipIqHsrtjoQJ4YQLM3n4w4QP5Y1w/ofT37+TatpDcZdpFxosc1E9mKa1
			gMMLKsuE+UxyM99CtlArGlrRbFpTkMc8cgy9A0zQpVI9kzkUmTxYuYYH2T8NlYuO
			orHgXn2GZqn7F6LG8bZXcjhC/swPmqILaJn2NCrOdjiPTkeTSuGlfySEYqKeMwil
			27UqeWQLhbBRiN0cznEnhERvkQvux/kP4ZbdiMIj81HNAKMby6kTssdhSq3Qf+30
			47ygdh3opKQLrcr+vyYvlrK4W+JL907hTVEb3RLNLGgSAn2ShqrRD0EnnPjdFjh7
			JsFvCmGScrkAn19JgqSoZnZCAAE1NhGitBKi/JXZ3ehm2RvkItdgLcLDmCMSb8DR
			g0PhbLpI6K4THF55HXX1XRXoNFEOw/Mlot80ot/VBIwzpHxzVbZM7G+7g2DUBJF8
			ZBTN6y/uhOCNnfohKi6dYKCU0TApxveXzZ0iLySf9VZD5+nT4SgUgeBlT+sYqDQM
			QslqWIuxT7eVPhKp8n1x4Mu+VIyp+cjfyPJkJBDuOyJfUBunn0L5KYU2fE8QArIw
			2vYcaiNQNr2E/FJb0gUyJEeDr2tkeRsCkCgcun8zju9PQkkZa4Fl9I1jp9H8oM8t
			XGKwaj1C9BtBDDOHIcFfNr1KMi2m8rKtD1oCJkQBcMOYEPWeCqspkAnB+nrrcJQW
			FOK2L1mRnysJysimNK20tnKggzaRr/uYO/jJcB4IUZw0+zy9rB4JIIwf4pT8hoXV
			waGwllp9SxuQLnqyLDEeUzp7sqyJIGi/hP99hgiLDPmI/QH9I0wmSK7SRwa7BOlJ
			+QajdB8RaZOPaUPAn1kKzLVNqZEE2Thfau34DJmg19D8B9TB8YxUfzhZSRYQwn+p
			FMQsG+dJBcwDpcfgpzsFU6isYtysKLC2eexrSbX0fTceqmF/fBFCsxchVHUN89at
			PWhYsxA1KxW9316fwjSfZYKRa5bkwPQ8y/CBsiVV5PWdCWKR4MiDpHDWI79IgqHy
			DExxFGKDrIfVWA/H+mGwNnUmyAMl8bOCaNcSEsW3uYdo9HSQU6rzN6phLZu0yBdI
			IO/fSZ91UiPCdWBbLRw/pTZa1CCKcPCpalrag+h14xG4/0mUWc6h2V3L6Dram9q1
			XkQ8cchb5ELXxAhq4zBiJlXCbnazuJ5a+iMr2Fx3KNJFhTIHN0vPWuV9M27y0Q5E
			ZbEm2UxEvI81yZ0SNh3Xsslp3aSNuSrPRNvpeGcwPk8mSIIbzeyUhH2St5X5JiLz
			bDD/chwCQ7rLnkYRfVAbQ7n/QHfPaQb9WFacvYS440TqE90Kwkx+kZHgmsYVwtvB
			2R16FhW5OWguCOhohfVh5n99EyLyKdCyHyEoshtkeUTq4KiR8IuD5A1tFbmHwmqv
			ZE7fVQoi6yraFHNmCvTKWoSXUKB/zkBw3L1IkExtHED0SGrjcTeH/4T+MZvviSPS
			faY/SnbR2Rs8CSLq8kbCgJ6EA30FLFA8P+wqstyQP180fyV6FV+Hed4ceG1xA6SO
			iwtDZftBM/9rtMbw8GMTUbItBWVVbrooepra29pv9nOs2QxtV6TJycoO43RU5p9E
			07lA9U7r+wwEo3+Fmm1vocutLNDPaArRw3kRMdz7t4yKZh5+eF8Ub2FQqXWPHrUo
			QHzU54h9gzkj113NvlIKibPktbuMjkjwwB25gKdXgFN0K40o3MbDxyWg+LWZqLJ6
			Ws/KVfclYkc3w3mUhVUzv/faXYKMhHUvMVIWHT+G+GaCGXqlr3xAVvuZ+AnauCUD
			EatpWqHfQj2iKUNC75MwrWuEM4vo9zjR7zxPfa3fS079ByiadLytGxY0XZCayAel
			uC7XgJbCLF0C4+VrMC9fgJ4R9ysAL1NTSQGOofdi+m8e3zyfF53OSLvAY4OOmTPf
			CvsafumRM4id9DAMSq38T/q7XaqfX8LdvzxFUbMriXy/uoi4d6thHk/hgrwRgIDR
			rwbmsYcQk0nQKLr+f+eBb9KPR9KfX5Wv7ex39v1D4Z/CLw1h9LjSEdqigl5A8KqJ
			KH+P2hE/JYsmdr8X0WP1DTimetC0aN2LPnCOBAS/kHVtRDIWTUHRsO4vld5JsmbI
			LYbgjUQXK3jRrcqNOxOE3mv4zAht2RhYF15Ea7nrGWN+SAbqmg7gVmtHA6wXsUXI
			0zY4BOAbo5KLvKV6PTQbitC6bhzKVf/voyv/whGdCMMJCrMrGWWrzqPlRlfeTjMa
			lA5j2rX2fxYwe3l4UWecYB7ZeQEtu9RCsFeCCPoQ0T0ehV8mhdnBW9nNOO9VGUyH
			NzFRJtNnEiWziZcBUk07jIIIuTnMI7kEo+cZVGq+lQKBMB5XEb+OWXuagNq+Voz9
			X4ABABraXKFeUC2rAAAAAElFTkSuQmCC`;

    case 'TS':
      return `data:image/png;base64,
			iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAM1BMVEUAAADeDx3e
			Dx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3haVmj
			AAAAEXRSTlMAMCC/cID/YM+PQO+vEN+fUCJrQLgAAAHWSURBVHgBlZVhssIgDIRT
			gC2QBnr/075RMLymdBy/f1o3JpstkGVz9BvOB/qNiJ1+wiVk+kcpMca9OHpkY/j5
			ISd84CPIk4KFOnuFoZVFVwyM0c+KBYcjQwIqvZADa9iYmQHso79H2mUQAPxu6qqo
			obyIrfeahBQPIA8pjEiGhfWiKQBQnrpqTn2cvTUAIJL0ZfCorgoA+O7BGi9j5squ
			L6LbsWHC3nvGhLdRPXl1GJG8Ps9bX2+oC436heh0z0JKnJphQn+IF7Ghs9voAWYp
			KmGrsJpMSummmO+VgA/FSDosdMNra0tJpDsnYMcUTBwt0Gn8HF+ptOK4V6ywZRSz
			nGCrfJfo8/BVotDAfZFkKNvNeQgtSLhvc7fOX3CYnGQ8W3fWlqs+TZnFn1QjIW9e
			C0UPhKCzDNz6tZiHZy0qOcVmk8v1AunEookRL+qaPbhIIutL8ZZwX21yqlFSDmWP
			HkrsDh29Uv10cjKeqNJTs+sUeZy7CQ+UkV2ZqeQhD4wVYWy7XdbL0fWB6/pe2cxW
			Wm84v6/fPS0UlHX4QYTFxqraYDy7xaduINgoNaxoolFvdMOp6B6DaLKnSPCY+KA/
			2lYKpZzxxbld838I/YRHpN9ofqN//AHYjCHIaCdi5QAAAABJRU5ErkJggg==`;

    case 'H1':
    case 'H2':
    case 'H3':
    case 'H4':
    case 'H5':
    case 'H':
    case 'TY':
    case 'STY':
      return `data:image/png;base64,
			iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAM1BMVEUAAADeDx3e
			Dx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3eDx3haVmj
			AAAAEXRSTlMAMCC/cID/YM+PQO+vEN+fUCJrQLgAAAGJSURBVHgBldXR0qsgDATg
			FWBFMMD7P+2RNoPH/tLid9eLnZI1A/i0GDxjrMMzniseMYEb/hOj936NBkNLoj1/
			bIFUaXcySiTB25r5oUT8YRKpo9fMG7vBh0BmNLLzXnK42Eiuer6hchmEZMKhXhPZ
			xcaXzCYIOkty06jqIdEK8yUTeYijUxVz9ligCg+AhB+D+96q8GCBjSNWdOacDJr6
			rmPhWFrwIsH2hulhOZXpfdEbfpWMZtCw8YXf9YLPSOIPG7rIxvKneIlMCc8jXKGE
			sywUOM1AZc5yUPvzkzlOgzKctkBZzopQK2dVPO7M90jlT7lHpqdxOktnEr/LsUeq
			zO2mj31jxMpMa0lekYTGBzOR8e+GdjSSk85UE0eywPOw9ik2vXcDB6LurpxbmTTu
			0nDn8+W1KCSTNziIz/fvyqJ/dmaavL2e3zXcJLDp8J3/uVZZ78tu3Faq/Qs4XEnh
			nSJ91Qv+MGX4fsH3K/mDOMuTdQK1aOJerL6pC04SuAsesfR4ptgF//kH34UpW6ne
			P+cAAAAASUVORK5CYII=`;

    default:
      return null;
  }
};

exports.icon = icon;

const getStormTypeName = (type = '') => {
  switch (type) {
    case 'WV':
      return 'Tropical Wave';

    case 'DB':
      return 'Disturbance';

    case 'I':
      return 'Invest';

    case 'EX':
      return 'Extratropical Low';

    case 'LO':
      return 'Low';

    case 'TD':
      return 'Tropical Depression';

    case 'TS':
      return 'Tropical Storm';

    case 'H':
      return 'Hurricane';

    case 'H1':
      return 'Category 1 Hurricane';

    case 'H2':
      return 'Category 2 Hurricane';

    case 'H3':
      return 'Category 3 Hurricane';

    case 'H4':
      return 'Category 4 Hurricane';

    case 'H5':
      return 'Category 5 Hurricane';

    case 'TY':
      return 'Typhoon';

    case 'STY':
      return 'Super Typhoon';

    default:
      return null;
  }
};

exports.getStormTypeName = getStormTypeName;

const getAlertTypeName = (alertType = '') => {
  switch (alertType) {
    case 'TR.A':
      return 'Tropical Storm Watch';

    case 'TR.W':
      return 'Tropical Storm Warning';

    case 'HU.A':
      return 'Hurricane Watch';

    case 'HU.W':
      return 'Hurricane Warning';

    default:
      return null;
  }
};

exports.getAlertTypeName = getAlertTypeName;

const formatStormData = data => {
  if ((0, _index.isArray)(data)) {
    data.forEach(item => {
      const {
        profile,
        position,
        track,
        forecast,
        id
      } = item; // eslint-disable-line object-curly-newline

      let lonShift = 0;
      let startLon;
      let lastLon;
      let crossesDateline = false;

      if (track && track.length > 0) {
        track.forEach((row, index) => {
          const {
            loc: {
              lat: plat,
              long: plon
            }
          } = row; // handle wrap-around tracks by adjusting longitude value

          if (index === 0) {
            lastLon = plon;
            startLon = plon;
          } else if (lastLon < 0 && plon > 0) {
            lonShift = -360;
          } else if (lastLon > 0 && plon < 0) {
            lonShift = 360;
          }

          row.loc.long += lonShift;
          row.isForecast = false;
          lastLon = plon; // if storm is active, flag if track point is the current position

          if (position) {
            const {
              loc: {
                lat: clat,
                long: clon
              }
            } = position;
            row.isCurrent = plat === clat && plon === clon;
          } else if (index === 0) {
            (0, _index.set)(row, 'details.stormShortName', profile.name);
            row.label = true;
          }

          row.profile = profile;
        });
      }

      if (forecast && forecast.length > 0) {
        forecast.forEach((row, index) => {
          const plon = row.loc.long;

          if (lastLon < 0 && plon > 0) {
            lonShift = -360;
          } else if (lastLon > 0 && plon < 0) {
            lonShift = 360;
          }

          row.loc.long += lonShift;
          row.isForecast = true;
          row.isCurrent = false;
          row.profile = profile;
          lastLon = plon;
        });
      }

      crossesDateline = lonShift !== 0; // if lonShift is not 0, we also need to adjust the forecast cone coords

      const coneCoords = (0, _index.get)(item, 'errorCone.coordinates');

      if (lonShift !== 0 && (0, _index.isset)(coneCoords)) {
        if ((0, _index.isset)(coneCoords[0])) {
          const coords = coneCoords[0];
          coords.forEach(coord => {
            const plon = coord[0];

            if (crossesDateline) {
              if (plon > 0 && startLon < 0) {
                lonShift = -360;
              } else if (plon < 0 && startLon > 0) {
                lonShift = 360;
              } else {
                lonShift = 0;
              }
            }

            coord[0] += lonShift;
            lastLon = plon;
          });
        }
      }
    });
  }

  return data;
};

exports.formatStormData = formatStormData;

const getStormMarkerConfig = data => {
  const {
    lat
  } = (0, _index.get)(data, 'loc');
  const type = (0, _index.get)(data, 'details.stormCat');
  const isCurrent = data.isCurrent;
  const flipped = lat < 0 && flipForSouthernLat(type);

  if (isCurrent) {
    return {
      className: 'marker-tropicalcyclone',
      svg: {
        image: {
          url: flipped && type === 'TD' ? icon(`${type}-flipped`) : icon(type),
          size: [34, 34],
          transform: flipped && type !== 'TD' ? 'scale(-1, 1) translate(-80, 0)' : ''
        },
        text: [{
          value: type === 'STY' ? 'S' : type.replace(/[^\d]/g, ''),
          anchor: 'start',
          position: 'center',
          translate: {
            y: -3
          },
          size: 20,
          color: '#ffffff',
          autosize: false
        }, {
          value: (0, _index.get)(data, 'details.stormShortName'),
          anchor: 'start',
          translate: {
            y: 22
          },
          autosize: false
        }]
      },
      size: [80, 60],
      zIndex: 50
    };
  }

  return {
    className: 'marker-tropicalcyclone',
    svg: {
      shape: {
        type: 'circle',
        fill: {
          color: color(type)
        },
        stroke: {
          color: '#ffffff',
          width: 2
        },
        size: [14, 14]
      },
      text: data.label ? {
        value: (0, _index.get)(data, 'details.stormShortName'),
        anchor: 'start',
        translate: {
          y: 12
        },
        autosize: false
      } : null
    },
    size: data.label ? [60, 40] : [14, 14],
    zIndex: data.label ? 50 : null
  };
}; // a function to create the pop up content


exports.getStormMarkerConfig = getStormMarkerConfig;

const getTropMarkerContent = data => {
  const latPos = Math.abs(data.loc.lat) + (data.loc.lat < 0 ? 'S' : 'N');
  const lonPos = Math.abs(data.loc.long) + (data.loc.long < 0 ? 'W' : 'E');
  return `
		<div class="content">
			<div class="title">${data.details.stormName}</div>
			<div class="row">
				<div class="label">Date:</div>
				<div class="value">${(0, _index.formatDate)(new Date(data.timestamp * 1000), 'h:mm a, MMM d, yyyy')}
				</div>
			</div>
			<div class="row">
				<div class="label">Advisory:</div>
				<div class="value">${(0, _index.isNull)(data.details.advisoryNumber) ? 'N/A' : data.details.advisoryNumber}</div>
			</div>
			<div class="row">
				<div class="label">Postion:</div>
				<div class="value">${latPos}, ${lonPos}</div>
			</div>
			<div class="row">
				<div class="label">Wind Speed:</div>
				<div class="value">${data.details.windSpeedMPH} mph / ${data.details.windSpeedKTS} kts</div>
			</div>
			${!(0, _index.isEmpty)(data.details.gustSpeedKPH) ? `
				<div class="row">
					<div class="label">Wind Gusts:</div>
					<div class="value">${data.details.gustSpeedMPH} mph / ${data.details.gustSpeedKTS} kts</div>
				</div>
			` : ''}
			${!(0, _index.isEmpty)(data.details.pressureIN) ? `
				<div class="row">
					<div class="label">Pressure:</div>
					<div class="value">${data.details.pressureIN} in / ${data.details.pressureMB} mb</div>
				</div>
			` : ''}
		</div>
	`;
};

exports.getTropMarkerContent = getTropMarkerContent;

/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.secondsToString = exports.formatDataValue = exports.formatMeasurement = exports.dataTypeForProp = exports.unitsForProp = exports.unitsForDataType = void 0;

var _ = __webpack_require__(17);

var _number = __webpack_require__(183);

/**
 * @ignore
 */
const _units = {
  imperial: {
    temp: '&deg;F',
    speed: ' mph',
    distance: ' mi',
    height: ' ft',
    pressure: ' in',
    percent: '%',
    precip: '"',
    rain: '"',
    snow: '"',
    text: '',
    degree: '&deg;'
  },
  metric: {
    temp: '&deg;C',
    speed: ' km/h',
    distance: ' km',
    height: ' m',
    pressure: ' mb',
    percent: '%',
    precip: ' mm',
    rain: ' mm',
    snow: ' cm',
    phrase: 'met',
    degree: '&deg;'
  }
};
/**
 * @ignore
 */

const patterns = {
  temp: '(temp|dewpoint|dewpt|feelslike|windchill|heatindex)',
  speed: '(speed|gust|wind)',
  distance: '(visibility|distance)',
  height: '(ceiling|elev|elevation|height|ht)',
  pressure: '(pressure|altimeter)',
  rain: '(precip|rain|prcp)',
  snow: '(snow|snowdepth|hail)',
  text: '(phrase)',
  percent: '(rh|humid|pop|prob|sky|skycover)'
};

const unitsForDataType = (type, isMetric = false) => {
  if (isMetric) {
    return _units.metric[type] || '';
  }

  return _units.imperial[type] || '';
};

exports.unitsForDataType = unitsForDataType;

const unitsForProp = (prop, isMetric) => {
  const type = isMetric ? 'metric' : 'imperial';
  prop = prop.toLowerCase();
  let units;
  Object.keys(patterns).forEach(key => {
    const re = new RegExp(patterns[key], 'i');

    if (prop.match(re)) {
      units = (0, _.get)(_units, `${type}.${key}`);
    }
  });
  return units;
};

exports.unitsForProp = unitsForProp;

const dataTypeForProp = prop => {
  let result;
  prop = (prop || '').toLowerCase().replace(/\s/g, '');

  if (undefined !== patterns[prop]) {
    return prop;
  }

  if (/prob(ability)?/.test(prop)) {
    return 'percent';
  }

  Object.keys(patterns).forEach(key => {
    const re = new RegExp(patterns[key], 'i');

    if (re.test(prop)) {
      result = key;
    }
  });
  return result;
};

exports.dataTypeForProp = dataTypeForProp;

const formatMeasurement = (value, prop, isMetric = false, includeUnits = false, defaultValue = '--', unitsTemplate = null) => {
  if ((0, _.isset)(value) === false) {
    return defaultValue;
  }

  const type = dataTypeForProp(prop);

  if (!type) {
    return `${value}`;
  }

  let decimals = 0;
  let units = '';
  let spacer = ' ';

  if (type === 'temp') {
    spacer = '';
  } else if (type === 'pressure') {
    decimals = isMetric ? 0 : 2;
  } else if (type === 'rain') {
    decimals = isMetric ? 1 : 2;
  } else if (type === 'snow') {
    decimals = 1;
  } else if (type === 'distance') {
    decimals = 2;
  }

  if (decimals > 0) {
    value = parseFloat(value).toFixed(decimals);
  } else {
    value = Math.round(value);
  }

  if (includeUnits) {
    units = unitsForDataType(type, isMetric);

    if ((0, _.isset)(unitsTemplate)) {
      units = unitsTemplate.replace(/{{units}}/, units);
    }
  }

  return `${(0, _number.formatNumber)(value, decimals)}${spacer}${units}`;
};

exports.formatMeasurement = formatMeasurement;

const formatDataValue = (data, key, metricKey = null, isMetric = false) => {
  const prop = isMetric ? metricKey || key : key;
  return formatMeasurement((0, _.get)(data, prop), prop, isMetric, true, 'N/A', '<span class="units">{{units}}</span>');
};

exports.formatDataValue = formatDataValue;

const secondsToString = (value, includeSeconds = false) => {
  const result = [];
  const hours = Math.floor(value / 3600);
  const minutes = Math.floor((value - hours * 3600) / 60);
  const seconds = Math.floor(value - hours * 3600 - minutes * 60);

  if (hours > 0) {
    result.push(`${hours} hr`);
  }

  if (minutes > 0) {
    result.push(`${minutes} min`);
  }

  if (includeSeconds && seconds > 0) {
    result.push(`${seconds} sec`);
  }

  return result.join(', ');
};

exports.secondsToString = secondsToString;

/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.formatNumber = void 0;

/* eslint-disable import/prefer-default-export */
const formatNumber = (value, places = 0, decimal = '.', thousands = ',') => {
  let result = '';
  let str = value.toString();
  str = str.replace(/^-/, '');
  const split = str.split('.');
  const integer = split[0];
  const fraction = split[1];

  if (/e/.test(str)) {
    result = str;
  } else {
    for (let i = integer.length; i > 0; i -= 3) {
      if (i < integer.length) {
        result = thousands + result;
      }

      result = integer.slice(Math.max(0, i - 3), i) + result;
    }
  }

  if (fraction) {
    const count = places - fraction.length;
    const zeros = count > 0 ? '0'.repeat(places - fraction.length) : '';
    result += decimal + `${zeros}${fraction}`.substr(0, places);
  }

  return (value < 0 ? '-' : '') + result;
};

exports.formatNumber = formatNumber;

/***/ }),
/* 184 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_systems_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(185);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_systems_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_systems_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_systems_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_systems_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),
/* 185 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__header {\n  margin-bottom: 16px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__icon {\n  height: 50px;\n  position: relative;\n  width: 50px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__icon-label {\n  color: #fff;\n  font-size: 22px;\n  font-weight: bold;\n  left: 0;\n  top: 50%;\n  position: absolute;\n  text-align: center;\n  transform: translateY(-50%);\n  width: 50px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__name {\n  font-size: 18px;\n  font-weight: bold;\n  margin-bottom: 4px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__timestamp {\n  color: #666;\n  font-size: 12px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__metadata {\n  margin-left: 16px;\n  margin-top: 8px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__details .awxjs__ui-row, .awxjs__app__ui-panel-info-content .awxjs__tropical-system-profile__summary .awxjs__ui-row {\n  margin: 6px 0;\n}\n\n.awxjs__app__component.awxjs__mode-dark .awxjs__app__ui-panel-info .awxjs__tropical-system-profile__timestamp {\n  color: #999;\n}\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(187)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 187 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _index = __webpack_require__(17);

var _Systems = _interopRequireDefault(__webpack_require__(180));

var _utils = __webpack_require__(181);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Invests extends _Systems.default {
  get id() {
    return this.opts.id || 'tropical-invests';
  }

  source() {
    const request = this.account.api().endpoint('tropicalcyclones').action("search"
    /* SEARCH */
    ).limit(50).filter('invests');
    const properties = {
      id: 'id',
      category: 'details.stormCat',
      timestamp: 'timestamp',
      points: ['track', 'forecast']
    };
    return {
      type: 'vector',
      data: {
        service: request,
        properties,
        formatter: data => (0, _utils.formatStormData)(data)
      },
      style: {
        marker: data => (0, _utils.getStormMarkerConfig)(data),
        polygon: data => ({
          fill: {
            color: '#ffffff',
            opacity: 0.7
          }
        }),
        polyline: data => {
          const type = (0, _index.get)(data, 'details.stormCat');
          return {
            stroke: {
              color: (0, _utils.color)(type),
              width: 3
            }
          };
        }
      },
      animation: {
        enabled: true
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Invests'
    };
  }

}

var _default = Invests;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 188 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(189)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 189 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = __webpack_require__(167);

var _index = __webpack_require__(17);

const windFieldColors = {
  '34': '#ffff00',
  '50': '#FFA500',
  '64': '#FF0000'
};

const getWindFieldColor = speedKTS => {
  const defaultColor = '#000000';
  return windFieldColors[speedKTS] || defaultColor;
};

class Windfields extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'tropical-windfields-current';
  }

  source() {
    const request = this.account.api().endpoint('tropicalcyclones').action("search"
    /* SEARCH */
    ).fields('id,position.details.windRadii,forecast.details.windRadii').filter('windfield');
    return {
      type: 'vector',
      data: {
        service: request,
        properties: {
          id: 'id',
          category: 'windSpeedKTS',
          path: 'windField'
        },
        formatter: data => {
          const windFields = [];

          if ((0, _index.isArray)(data)) {
            data.forEach(system => {
              const {
                id,
                position,
                forecast
              } = system;
              let windRadii = (0, _index.get)(position, 'details.windRadii') || [];

              if (forecast && (0, _index.isArray)(forecast)) {
                forecast.forEach(period => {
                  const fradii = (0, _index.get)(period, 'details.windRadii');

                  if (fradii) {
                    windRadii = windRadii.concat(fradii);
                  }
                });
              }

              if ((0, _index.isArray)(windRadii)) {
                windRadii.forEach(radii => {
                  if (radii.windField) {
                    const windField = {
                      id,
                      windSpeedKTS: radii.windSpeedKTS,
                      windSpeedMPH: radii.windSpeedMPH,
                      windField: radii.windField
                    };
                    windFields.push(windField);
                  }
                });
              }
            });
          }

          return windFields;
        }
      },
      style: {
        polygon: data => {
          if (data && data.windSpeedKTS) {
            return {
              fill: {
                color: getWindFieldColor(data.windSpeedKTS),
                opacity: 0.85
              }
            };
          }

          return null;
        }
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Windfields'
    };
  }

  legend() {
    return {
      title: 'Tropical Windfields',
      code: 'tropical-windfields'
    };
  }

}

var _default = Windfields;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 190 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(191)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 191 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = __webpack_require__(167);

var _index = __webpack_require__(17);

const color = code => {
  code = (code || '').toUpperCase();

  switch (code) {
    case 'TR.A':
      return '#ffe401';

    case 'TR.W':
      return '#ff9000';

    case 'HU.A':
      return '#ff00d2';

    case 'HU.W':
      return '#ff0017';

    default:
      return '#000000';
  }
};

class Breakpoints extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'tropical-breakpoints';
  }

  source() {
    return {
      type: 'vector',
      data: {
        request: {
          endpoint: 'tropicalcyclones',
          action: ":id"
          /* ID */
          ,
          parameters: {
            filter: 'geo',
            fields: 'id,profile,breakPointAlerts',
            limit: 50
          }
        },
        properties: {
          id: 'id',
          category: '[path].alertType',
          path: 'breakPointAlerts'
        },
        formatter: data => {
          const records = !(0, _index.isArray)(data) ? [data] : data; // convert array of breakpoint geometries into MultiLineString features based on group

          records.forEach(record => {
            const groups = {};
            (record.breakPointAlerts || []).forEach(line => {
              const type = line.alertType;

              if (!groups[type]) {
                groups[type] = [];
              }

              groups[type].push(line.coords.coordinates);
            });
            const features = [];
            Object.keys(groups).forEach(group => {
              features.push({
                type: 'Feature',
                properties: {
                  id: `${record.id}-${group}`,
                  alertType: group
                },
                geometry: {
                  type: 'MultiLineString',
                  coordinates: groups[group]
                }
              });
            });
            record.breakPointAlerts = features;
          });
          return data;
        }
      },
      style: {
        polyline: data => {
          const type = (0, _index.get)(data, 'alertType');
          return {
            stroke: {
              color: color(type),
              width: 6
            }
          };
        }
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Breakpoints'
    };
  }

  legend() {
    return {
      title: 'Tropical Breakpoints',
      code: 'tropical-breakpoints'
    };
  }

}

var _default = Breakpoints;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(193)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 193 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapSourceModule = _interopRequireDefault(__webpack_require__(167));

var _Feature = _interopRequireDefault(__webpack_require__(194));

var _Http = _interopRequireDefault(__webpack_require__(101));

var _FeatureCollection = _interopRequireDefault(__webpack_require__(205));

var _MapboxRouteService = _interopRequireDefault(__webpack_require__(206));

var _GoogleRouteService = _interopRequireDefault(__webpack_require__(207));

var _utils = __webpack_require__(17);

var _layout = __webpack_require__(208);

var _utils2 = __webpack_require__(209);

var _views = __webpack_require__(210);

var _colors = __webpack_require__(211);

__webpack_require__(212);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const WEATHER_SEGMENTS = {
  temps: {
    value: 'temps',
    title: 'Temperatures'
  },
  winds: {
    value: 'winds',
    title: 'Wind Speeds'
  },
  windgusts: {
    value: 'windgusts',
    title: 'Wind Gusts'
  },
  weather: {
    value: 'weather',
    title: 'Weather'
  },
  alerts: {
    value: 'alerts',
    title: 'Alerts'
  }
};

class Routing extends _MapSourceModule.default {
  constructor(opts = null) {
    const vp = (0, _layout.viewportSizeClass)();
    super((0, _utils.extend)({
      weatherTypes: ['temps', 'winds', 'windgusts', 'weather', 'alerts'],
      insets: vp.width === 'compact' ? [0, 0] : [100, 100],
      refresh: 0,
      showInfoOnSelect: vp.width !== 'compact'
    }, opts));
    this.state = {
      dataType: (0, _utils.isset)(this.opts.weatherTypes) ? this.opts.weatherTypes[0] : 'temps',
      routeId: undefined
    };
    this.routeStore = new Map();
  }

  get id() {
    return this.opts.id;
  }

  source() {
    return {
      type: 'geojson',
      restrictToTimeline: false,
      data: {
        service: () => this.request,
        formatter: data => {
          const routeId = this.state.routeId;
          const routeData = this.routeStore.get(routeId);
          const features = (0, _utils2.generateRouteFeatures)(routeId, data, routeData);

          if (this.opts.onWeatherData) {
            this.opts.onWeatherData(features);
          }

          return features;
        }
      },
      style: {
        marker: data => (0, _utils2.getMarkerStyle)(data, this.routeStore.get(this.state.routeId)),
        polyline: data => {
          if ((0, _utils.get)(data, '0')) {
            data = (0, _utils.get)(data, '0');
          }

          const dataType = this.state.dataType;
          const color = (0, _colors.getColor)(dataType, data);
          return {
            stroke: {
              color,
              width: 6 // lineCap: 'square'

            }
          };
        }
      }
    };
  }

  controls() {
    const routes = this.opts.routes;
    const weatherTypes = this.opts.weatherTypes;
    const dataTypeSegments = (weatherTypes || []).map(type => Object.assign(Object.assign({}, WEATHER_SEGMENTS[type]), {
      id: type
    }));

    if (routes.length === 1) {
      const route = routes[0];
      return {
        value: route.id,
        title: route.title
      };
    }

    return {
      id: this.id,
      title: this.opts.title,
      filter: true,
      multiselect: false,
      reloadOnChange: false,
      segments: dataTypeSegments.length > 0 ? {
        groups: [{
          id: 'route',
          title: 'Route',
          segments: routes.map(route => ({
            value: route.id,
            title: route.title
          }))
        }, {
          id: 'datatype',
          title: 'Route Weather',
          segments: dataTypeSegments
        }]
      } : {
        groups: [{
          id: 'route',
          segments: routes.map(route => ({
            value: route.id,
            title: route.title
          }))
        }]
      }
    };
  }

  legend() {
    return {
      get: () => {
        let code;

        switch (this.state.dataType) {
          case 'temps':
            code = 'temps';
            break;

          case 'winds':
          case 'windgusts':
            code = 'winds';
            break;

          case 'weather':
            code = 'weather';
            break;

          case 'alerts':
            code = 'alerts';
            break;

          default:
        }

        return {
          code
        };
      }
    };
  }

  infopanel() {
    return {
      views: [(0, _views.assetInfoView)(info => {
        this.showRouteInfo(this.state.routeId, info);
      }), (0, _views.routeInfoView)(info => {
        this.showRouteInfo(this.state.routeId, info);
      }), {
        id: 'impacts',
        title: 'Short-Term Impacts',
        renderer: 'hazards'
      }, (0, _views.zoomRouteView)(() => {
        this.showRouteInfo(this.state.routeId);
      })]
    };
  }

  onInit() {
    this.request = this.account.api().endpoint((0, _utils2.getEndpointForDataType)(this.state.dataType)).action("route"
    /* ROUTE */
    );
    this.app.on('layer:change', e => {
      const {
        id,
        source,
        value
      } = e.data || {};

      if (id === this.id) {
        const {
          route,
          datatype
        } = value;

        if (source) {
          this.setRoute(route, datatype, source);
        }
      }
    });
  }

  onRemove() {
    if (this.refreshTimer) {
      window.clearTimeout(this.refreshTimer);
    }

    this.refreshTimer = undefined;
  }

  onData(results) {}

  onMarkerClick(marker, data) {
    const id = data.routeId;

    if (id) {
      this.showRouteInfo(id, data);
    }
  }

  dataForRoute(id = this.state.routeId) {
    return this.routeStore.get(id);
  }

  zoomToRoute(id = this.state.routeId, insets = this.opts.insets) {
    const routeData = this.routeStore.get(id);

    if (!routeData) {
      return;
    }

    const feature = routeData.feature;
    const bounds = feature.geometry.bounds();
    const vp = (0, _layout.viewportSizeClass)();
    this.map.fitBounds(bounds, insets);
  }

  setRoute(id, dataType, source) {
    const request = this.request;
    const endpoint = (0, _utils2.getEndpointForDataType)(dataType);
    const routeDidChange = id !== this.state.routeId;
    let needsReload = false; // select corresponding control in the app's layers panel

    if (this.app) {
      const panel = this.app.panels.layers;

      if (panel) {
        panel.select([`${this.id}::route::${id}`, `${this.id}::datatype::${dataType}`]);
      }
    } // route and/or weather data needs reloading if endpoint or route id changed


    if (routeDidChange || endpoint !== request.getEndpoint()) {
      needsReload = true; // remove cached route data to force reload

      this.routeStore.delete(id);
    }

    if (routeDidChange) {
      this.trigger('change:route', {
        id,
        type: dataType,
        module: this
      });
    }

    if (dataType !== this.state.dataType) {
      this.trigger('change:datatype', {
        id,
        type: dataType,
        module: this
      });
    }

    this.state = {
      dataType,
      routeId: id
    }; // start refresh timer if refresh duration is > 0

    this.startReloadTimeoutIfNeeded();

    if (!needsReload) {
      source.render();
      return;
    }

    this.getRouteData(id).then(result => {
      if (this.opts.onRouteData) {
        result = this.opts.onRouteData(result);
      }

      const {
        feature
      } = result;

      if (!feature || !feature.coordinates) {
        throw new Error('Invalid route GeoJSON feature or missing coordinates.');
      }

      const coords = feature.coordinates;
      const {
        points,
        distance: totalDistance
      } = (0, _utils2.convertCoordsToGeoJSON)(coords);
      result.distanceMeters = Math.max(result.distanceMeters, totalDistance);
      this.routeStore.set(id, result);
      this.trigger('route:load', {
        id,
        data: result,
        module: this
      }); // set points data initially so route is rendered while weather data loads

      source.setData(points);

      if (routeDidChange && this.opts.showInfoOnSelect) {
        this.showRouteInfo(id);
      }

      (0, _utils2.configureRouteRequest)(request, dataType, endpoint, points);
      source.reload();
    }).catch(e => {
      console.error('[Aeris] Routing - Failed to load route data', e);
    });
  }

  startReloadTimeoutIfNeeded() {
    if (this.opts.refresh > 0) {
      if (this.refreshTimer) {
        window.clearTimeout(this.refreshTimer);
      }

      this.refreshTimer = window.setTimeout(() => {
        this.reloadCurrentRoute();
      }, Math.max(this.opts.refresh * 1000, 60 * 1000));
    }
  }

  reloadCurrentRoute() {
    const id = this.state.routeId;
    const source = this.dataSource;
    this.getRouteData(id).then(result => {
      if (this.opts.onRouteData) {
        result = this.opts.onRouteData(result);
      }

      this.routeStore.set(id, result);
      this.startReloadTimeoutIfNeeded();

      if (source) {
        source.reload();
      }
    });
  }

  showRouteInfo(id, markerData) {
    const routeConfig = this.getRouteConfig(id);

    if (!routeConfig) {
      return;
    }

    const routeData = this.routeStore.get(id);

    if (!routeData) {
      return;
    }

    const feature = routeData.feature;
    const coords = feature.coordinates;
    const departureTime = (0, _utils.get)(routeData, 'departure.timestamp') || Date.now();
    const data = (0, _utils2.generateRouteData)((0, _utils.extend)({}, routeConfig, {
      data: Object.assign({}, (0, _utils.cloneDeep)(routeData))
    }, {
      data: {
        departure: {
          timestamp: departureTime
        },
        destination: {
          timestamp: departureTime + (routeData.durationSeconds || 0) * 1000
        }
      }
    }), coords.map(c => [c.lon, c.lat]));
    data.p = '';
    let zoomTo;

    if ((0, _utils.isset)(markerData)) {
      const {
        coordinate,
        index = 0,
        type
      } = markerData;

      if ((0, _utils.isset)(coordinate)) {
        data.p = `${coordinate.lat},${coordinate.lon}`;
        zoomTo = coordinate; // pass which marker was selected so it can be highlighted in the info panel

        if (type === 'waypoint') {
          data.selectedIndex = index;
        } else {
          data.selectedIndex = type;
        }
      }
    }

    if (!(0, _utils.isset)(zoomTo)) {
      this.zoomToRoute(id);
    } else {
      this.map.setView(zoomTo, 11);
    } // console.log('routeData', data, routeData, routeData.waypoints);


    this.showInfoPanel(`Route - ${routeConfig.title || routeConfig.id}`).load(data, {
      route: data
    });
  }

  getRouteConfig(id) {
    const {
      routes
    } = this.opts; // get route info associated with the id

    let match;
    (routes || []).forEach(route => {
      if (route.id === id) {
        match = route;
      }
    });
    return match;
  }

  getRouteData(id) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      var _a, _b;

      const {
        url,
        service: serviceOpts
      } = this.opts;
      const routeConfig = this.getRouteConfig(id);

      if (!routeConfig) {
        reject(new Error(`[Aeris] Routing - No route configuration found for id {${id}}`));
      }

      const cached = this.routeStore.get(id);

      if (cached) {
        resolve(cached);
        return;
      } // if route config already has a feature for data.feature, then it's a static route
      // and we don't need to perform a fetch request


      if ((0, _utils.get)(routeConfig, 'data.feature')) {
        const feature = routeConfig.data.feature;

        if ((0, _utils.isPlainObject)(feature)) {
          routeConfig.data.feature = new _Feature.default(feature);
        }

        resolve(routeConfig.data);
        return;
      }

      let data;

      if (url) {
        const requestUrl = (0, _utils.isFunction)(url) ? url(id) : url;
        data = yield this.getRouteDataFromUrl(id, requestUrl);
      } else if (serviceOpts) {
        data = yield this.getRouteDataFromService(id, serviceOpts);
      }

      const result = Object.assign(Object.assign(Object.assign({}, routeConfig.data), (0, _utils.pick)(data, ['asset', 'departure', 'destination', 'current', 'waypoints'])), {
        feature: (0, _utils.isPlainObject)(data.feature) ? new _Feature.default(data.feature) : data.feature,
        distanceMeters: data.distanceMeters || 0,
        durationSeconds: data.durationSeconds || 0
      });

      if (result.current && result.asset) {
        result.asset.loc = result.current.loc;
      } // add custom waypoints if defined with the route config
      // which should be provided as an array of valid GeoJSON Feature elements


      if ((_a = routeConfig.data) === null || _a === void 0 ? void 0 : _a.waypoints) {
        result.waypoints = result.waypoints.concat((_b = routeConfig.data) === null || _b === void 0 ? void 0 : _b.waypoints.map(item => new _Feature.default(item)));
      } // console.log('route service result', result, data);


      resolve(result);
    }));
  }

  getRouteDataFromUrl(id, url) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield _Http.default.request(url);
        let data;

        if (result && result.data) {
          data = result.data;

          if ((0, _utils.isString)(data)) {
            throw new Error('[Aeris] Routing - Invalid route data received');
          }

          if (!data.feature && data.type) {
            let feature;

            if (data.type === 'FeatureCollection' || data.type === 'Feature') {
              const collection = new _FeatureCollection.default(data);
              feature = collection.features[0];
            }

            data.feature = feature;
          }

          if ((0, _utils.isset)(data.waypoints)) {
            data.waypoints = (0, _utils2.convertPointsToFeatures)(data.waypoints);
          }
        }

        resolve(data);
      } catch (e) {
        console.error('[Aeris] Routing - Custom route URL request failed', e);
        reject(e);
      }
    }));
  }

  getRouteDataFromService(id, serviceOpts) {
    const routeConfig = this.getRouteConfig(id);
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      let service;

      if (serviceOpts.type === 'mapbox') {
        service = new _MapboxRouteService.default({
          accessToken: serviceOpts.accessKey
        });
      } else if (serviceOpts.type === 'google') {
        service = new _GoogleRouteService.default({
          accessToken: serviceOpts.accessKey
        });
      }

      if (service) {
        try {
          // overview can be "full" or "simplified" for Mapbox
          const result = yield service.getDirections(routeConfig.points, {
            overview: this.state.dataType === 'alerts' ? 'full' : 'simplified'
          });
          resolve(result);
        } catch (e) {
          console.error('[Aeris] Routing - Directions service request failed', e);
          reject(e);
        }
      } else {
        reject(new Error(`[Aeris] Routing - Invalid directions service type of \'${serviceOpts.type}\' specified`));
      }
    }));
  }

}

var _default = Routing;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 194 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Geometry = __webpack_require__(195);

var _utils = __webpack_require__(17);

class Feature {
  constructor(data = {}) {
    // if a geometry object was provided, convert it to a Feature object
    if (data.type && data.coordinates) {
      data = {
        type: 'Feature',
        geometry: data,
        properties: data.properties
      };
    }

    if (!(0, _utils.isEmpty)(data.geometry)) {
      this._geometry = (0, _Geometry.createGeometry)(data.geometry);
      this.properties = data.properties || {};

      if (data.id) {
        this.id = `${data.id}`;
      }
    }
  }

  get geometry() {
    return this._geometry;
  }

  get coordinates() {
    if (!this.geometry) {
      return undefined;
    }

    return this.geometry.coordinates;
  }

}

var _default = Feature;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createGeometry = void 0;

var _ = __webpack_require__(196);

const createGeometry = data => {
  const type = data.type;
  const coords = data.coordinates;
  let geometry;

  switch (type) {
    case 'Point':
      geometry = new _.Point(coords);
      break;

    case 'MultiPoint':
      geometry = new _.MultiPoint(coords);
      break;

    case 'LineString':
      geometry = new _.LineString(coords);
      break;

    case 'MultiLineString':
      geometry = new _.MultiLineString(coords);
      break;

    case 'Polygon':
      geometry = new _.Polygon(coords);
      break;

    case 'MultiPolygon':
      geometry = new _.MultiPolygon(coords);
      break;

    default:
      geometry = null;
  }

  return geometry;
};

exports.createGeometry = createGeometry;

/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Point", ({
  enumerable: true,
  get: function () {
    return _Point.default;
  }
}));
Object.defineProperty(exports, "MultiPoint", ({
  enumerable: true,
  get: function () {
    return _MultiPoint.default;
  }
}));
Object.defineProperty(exports, "LineString", ({
  enumerable: true,
  get: function () {
    return _LineString.default;
  }
}));
Object.defineProperty(exports, "MultiLineString", ({
  enumerable: true,
  get: function () {
    return _MultiLineString.default;
  }
}));
Object.defineProperty(exports, "Polygon", ({
  enumerable: true,
  get: function () {
    return _Polygon.default;
  }
}));
Object.defineProperty(exports, "MultiPolygon", ({
  enumerable: true,
  get: function () {
    return _MultiPolygon.default;
  }
}));

var _Point = _interopRequireDefault(__webpack_require__(197));

var _MultiPoint = _interopRequireDefault(__webpack_require__(200));

var _LineString = _interopRequireDefault(__webpack_require__(201));

var _MultiLineString = _interopRequireDefault(__webpack_require__(202));

var _Polygon = _interopRequireDefault(__webpack_require__(203));

var _MultiPolygon = _interopRequireDefault(__webpack_require__(204));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 197 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Point {
  constructor(coords) {
    if ((0, _utils.isEmpty)(coords)) {
      throw new Error('Invalid coordinates for Point');
    }

    const [lon, lat] = coords;
    this.coordinates = {
      lat,
      lon
    };
  }

  toArray(reversed = false) {
    const {
      lat,
      lon
    } = this.coordinates;
    return reversed ? [lon, lat] : [lat, lon];
  }

  bounds() {
    return _CoordinateBounds.default.fromPoints([this.coordinates]);
  }

}

var _default = Point;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 198 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.normalize = void 0;

var _InvalidCoordinateError = _interopRequireDefault(__webpack_require__(199));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const normalize = coord => {
  let factor = Math.ceil(Math.abs(coord.lat) / 180);
  if (coord.lat > 90) coord.lat -= 180 * factor;else if (coord.lat < -90) coord.lat += 180 * factor;
  factor = Math.ceil(Math.abs(coord.lon) / 360);
  if (coord.lon > 180) coord.lon -= 360 * factor;else if (coord.lon < -180) coord.lon += 360 * factor;
  return coord;
};
/**
 * A `CoordinateBounds` object represents a rectangular region defined by northwest and southeast
 * coordinates.
 */


exports.normalize = normalize;

class CoordinateBounds {
  /**
   * Initializes a bounds instance defined by the specified northwest and southeast coordinates.
   * @param nw
   * @param se
   */
  constructor(nw, se) {
    /** The northern latitude */
    this.north = 0;
    /** The southern latitude */

    this.south = 0;
    /** The western longitude */

    this.west = 0;
    /** The eastern longitude */

    this.east = 0;
    nw = normalize(nw);
    se = normalize(se);

    if (undefined === nw || !(0, _utils.isObject)(nw)) {
      throw new _InvalidCoordinateError.default('CoordinateBounds - northwest coordinate value is required');
    }

    if (undefined === se || !(0, _utils.isObject)(se)) {
      throw new _InvalidCoordinateError.default('CoordinateBounds - southeast coordinate value is required');
    }

    if (nw.lat < se.lat) {
      throw new _InvalidCoordinateError.default('CoordinateBounds - northern latitude must be greater than southern latitude');
    } // if (nw.lon > se.lon) {
    // 	throw new InvalidCoordinateError('CoordinateBounds - eastern longitude must be greater than western longitude');
    // }


    this.north = nw.lat;
    this.south = se.lat;
    this.west = nw.lon;
    this.east = se.lon;
  }

  static fromBounds(bounds) {
    return new CoordinateBounds({
      lat: bounds.north,
      lon: bounds.west
    }, {
      lat: bounds.south,
      lon: bounds.east
    });
  }

  static fromPoints(points) {
    const bounds = {
      north: null,
      south: null,
      west: null,
      east: null
    };
    points.forEach((coord, index) => {
      if (index === 0) {
        bounds.north = coord.lat;
        bounds.south = coord.lat;
        bounds.west = coord.lon;
        bounds.east = coord.lon;
      } else if ((0, _utils.isset)(coord.lat) && (0, _utils.isset)(coord.lon)) {
        bounds.north = Math.max(bounds.north, coord.lat);
        bounds.south = Math.min(bounds.south, coord.lat);
        bounds.west = Math.min(bounds.west, coord.lon);
        bounds.east = Math.max(bounds.east, coord.lon);
      }
    });
    return CoordinateBounds.fromBounds(bounds);
  }
  /**
   * Returns the northwestern coordinate for the bounds.
   */


  northwest() {
    return {
      lat: this.north,
      lon: this.west
    };
  }
  /**
   * Returns the southwestern coordinate for the bounds.
   */


  southwest() {
    return {
      lat: this.south,
      lon: this.west
    };
  }
  /**
   * Returns the northeastern coordinate for the bounds.
   */


  northeast() {
    return {
      lat: this.north,
      lon: this.east
    };
  }
  /**
   * Returns the southeastern coordinate for the bounds.
   */


  southeast() {
    return {
      lat: this.south,
      lon: this.east
    };
  }
  /**
   * Returns the center coordinate for the bounds.
   */


  center() {
    return {
      lat: this.north - (this.north - this.south) / 2,
      lon: this.west - (this.west - this.east) / 2
    };
  }
  /**
   * Expands the bounds to include the specified coordinate. If the bounds already contains the
   * coodinate, then the bounds will not change.
   *
   * @param coord
   */


  extend(coord) {
    if (!this.north && !this.south && !this.west && !this.east) {
      this.north = coord.lat;
      this.south = coord.lat;
      this.west = coord.lon;
      this.east = coord.lon;
      return;
    }

    this.north = Math.max(this.north, coord.lat);
    this.south = Math.min(this.south, coord.lat);
    this.west = Math.min(this.west, coord.lon);
    this.east = Math.max(this.east, coord.lon);
  }
  /**
   * Returns whether the bounds intersects the specified bounds but does not contain it.
   * @param bounds
   */


  intersects(bounds) {
    if (this.contains(bounds)) {
      return false;
    }

    const {
      north,
      south,
      east,
      west
    } = bounds;
    return (north <= this.north && north >= this.south || south >= this.south && south <= this.north) && ( // eslint-disable-line max-len
    west >= this.west && west <= this.east || east <= this.east && east >= this.west);
  }
  /**
   * Returns whether the bounds contains the specified coordinate or bounds.
   * @param value
   */


  contains(value) {
    if (value instanceof CoordinateBounds) {
      const {
        north,
        south,
        east,
        west
      } = value;
      return north < this.north && south > this.south && west > this.west && east < this.east;
    }

    const {
      lat,
      lon
    } = value;
    return lat < this.north && lat > this.south && lon > this.west && lon < this.east;
  }
  /**
   * Returns a string representation of the coordinate bounds.
   */


  toString() {
    return `${this.north},${this.west},${this.south},${this.east}`;
  }

}

var _default = CoordinateBounds;
exports["default"] = _default;

/***/ }),
/* 199 */
/***/ ((module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

class InvalidCoordinateError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    this.stack = new Error().stack;
  }

}

var _default = InvalidCoordinateError;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 200 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Point = _interopRequireDefault(__webpack_require__(197));

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MultiPoint {
  constructor(coords) {
    if ((0, _utils.isEmpty)(coords)) {
      throw new Error('Invalid coordinates for MultiPoint');
    }

    this.points = coords.map(pointCoords => new _Point.default(pointCoords));
    this.coordinates = this.points.map(point => point.coordinates);
  }

  toArray(reversed = false) {
    return this.points.map(point => point.toArray(reversed));
  }

  bounds() {
    const bounds = {
      north: null,
      south: null,
      west: null,
      east: null
    };
    this.coordinates.forEach(coord => {
      if ((0, _utils.isset)(coord.lat) && (0, _utils.isset)(coord.lon)) {
        bounds.north = Math.max(bounds.north, coord.lat);
        bounds.south = Math.min(bounds.south, coord.lat);
        bounds.west = Math.min(bounds.west, coord.lon);
        bounds.east = Math.max(bounds.east, coord.lon);
      }
    });
    return _CoordinateBounds.default.fromBounds(bounds);
  }

}

var _default = MultiPoint;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 201 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LineString {
  constructor(coords) {
    if ((0, _utils.isEmpty)(coords) || !(0, _utils.isArray)(coords)) {
      throw new Error('Invalid coordinates for LineString');
    }

    if (coords.length < 2) {
      throw new Error('Coordinate count in LineString is less than 2');
    }

    this.coordinates = coords.map(latlon => {
      if (latlon.length < 2) {
        throw new Error('Coordinate dimension count is less than 2');
      }

      const [lon, lat] = latlon;
      return {
        lat,
        lon
      };
    });
  }

  add(coord) {
    this.coordinates.push(coord);
  }

  toArray(reversed = false) {
    return this.coordinates.map(coord => reversed ? [coord.lon, coord.lat] : [coord.lat, coord.lon]);
  }

  bounds() {
    return _CoordinateBounds.default.fromPoints(this.coordinates);
  }

}

var _default = LineString;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 202 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _LineString = _interopRequireDefault(__webpack_require__(201));

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MultiLineString {
  constructor(coords) {
    if ((0, _utils.isEmpty)(coords)) {
      throw new Error('Invalid coordinates for MultiLineString');
    }

    this.lines = coords.map(lineCoords => new _LineString.default(lineCoords));
    this.coordinates = this.lines.map(line => line.coordinates);
  }

  toArray(reversed = false) {
    return this.lines.map(line => line.toArray(reversed));
  }

  bounds() {
    const bounds = {
      north: null,
      south: null,
      west: null,
      east: null
    };
    this.lines.forEach(line => {
      const b = line.bounds();

      if ((0, _utils.isset)(b)) {
        bounds.north = Math.max(bounds.north, b.north);
        bounds.south = Math.min(bounds.south, b.south);
        bounds.west = Math.min(bounds.west, b.west);
        bounds.east = Math.max(bounds.east, b.east);
      }
    });
    return _CoordinateBounds.default.fromBounds(bounds);
  }

}

var _default = MultiLineString;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 203 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.PolygonGeometry = void 0;

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class PolygonGeometry {
  constructor(vertices) {
    if ((0, _utils.isEmpty)(vertices)) {
      throw new Error('Invalid vertices for PolygonGeometry');
    }

    this.coordinates = vertices.map(vertex => {
      if (vertex.length < 2) {
        throw new Error('Coordinate dimension count is less than 2');
      }

      const [lon, lat] = vertex;
      return {
        lat,
        lon
      };
    });
  }

}

exports.PolygonGeometry = PolygonGeometry;

class Polygon {
  constructor(coords) {
    if ((0, _utils.isEmpty)(coords)) {
      throw new Error('Invalid coordinates for Polygon');
    }

    this.inner = [];
    this.coordinates = coords.map((vertices, index) => {
      if (vertices.length < 4) {
        throw new Error('Vertex count in Polygon is less than 4');
      }

      const polygon = new PolygonGeometry(vertices);

      if (index === 0) {
        this.outer = polygon;
      } else {
        this.inner.push(polygon);
      }

      return polygon.coordinates; // return element.map((latlon: LatLonValue) => {
      // 	if (latlon.length < 2) {
      // 		throw new Error('Coordinate dimension count is less than 2');
      // 	}
      // 	const [ lon, lat ] = latlon;
      // 	return { lat, lon };
      // });
    });
  }

  toArray(reversed = false) {
    return this.coordinates.map(polygon => polygon.map(coord => reversed ? [coord.lon, coord.lat] : [coord.lat, coord.lon]));
  }

  bounds() {
    return _CoordinateBounds.default.fromPoints(this.outer.coordinates);
  }

}

var _default = Polygon;
exports["default"] = _default;

/***/ }),
/* 204 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Polygon = _interopRequireDefault(__webpack_require__(203));

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MultiPolygon {
  constructor(coords) {
    if ((0, _utils.isEmpty)(coords)) {
      throw new Error('Invalid coordinates for MultiPolygon');
    }

    this.polygons = coords.map(polyCoords => new _Polygon.default(polyCoords));
    this.coordinates = this.polygons.map(polygon => polygon.coordinates);
  }

  toArray(reversed = false) {
    return this.polygons.map(polygon => polygon.toArray(reversed));
  }

  bounds() {
    const bounds = {
      north: null,
      south: null,
      west: null,
      east: null
    };
    this.polygons.forEach(polygon => {
      const b = polygon.bounds();

      if ((0, _utils.isset)(b)) {
        bounds.north = Math.max(bounds.north, b.north);
        bounds.south = Math.min(bounds.south, b.south);
        bounds.west = Math.min(bounds.west, b.west);
        bounds.east = Math.max(bounds.east, b.east);
      }
    });
    return _CoordinateBounds.default.fromBounds(bounds);
  }

}

var _default = MultiPolygon;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 205 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Feature = _interopRequireDefault(__webpack_require__(194));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class FeatureCollection {
  constructor(data) {
    data = data || {};
    data.features = data.features || data;

    if (!(0, _utils.isEmpty)(data.features)) {
      this._features = data.features.map(featureData => new _Feature.default(featureData));
    }
  }

  get features() {
    return this._features;
  }

}

var _default = FeatureCollection;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 206 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Http = _interopRequireWildcard(__webpack_require__(101));

var _Feature = _interopRequireDefault(__webpack_require__(194));

var _strings = __webpack_require__(133);

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const MAPBOX_DIRECTIONS_API = 'https://api.mapbox.com/directions/v5/mapbox/{mode}/{points}';
const MAPBOX_GEOCODE_API = 'https://api.mapbox.com/geocoding/v5/mapbox.places/{query}.json';

class MapboxRouteService {
  constructor(opts) {
    this.opts = (0, _utils.extend)({}, opts);
  }

  getDirections(points, params) {
    this.cancel();
    this.cancelToken = (0, _Http.createCancelToken)();
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      let coords = [];
      const geocodingTasks = [];
      (points || []).forEach(point => {
        if ((0, _utils.isString)(point)) {
          geocodingTasks.push(this.geocode(point));
        } else {
          coords.push(point);
        }
      });

      if (geocodingTasks.length > 0) {
        try {
          const geocodingResult = yield Promise.all(geocodingTasks);

          if (geocodingResult) {
            coords = geocodingResult;
          }
        } catch (e) {
          if (this.cancelToken.isCancel(e) === false) {
            reject(e);
          }
        }
      } // append coordinates


      const url = (0, _strings.parse)(MAPBOX_DIRECTIONS_API, {
        mode: 'driving',
        points: coords.filter(v => (0, _utils.isset)(v)).map(c => `${c.lon},${c.lat}`).join(';')
      });

      if (coords.length === 0) {
        console.warn('[Aeris] Routing - Cannot request directions, invalid or empty array of route coordinates provided.', points);
        return;
      }

      ;

      _Http.default.request(url, {
        params: Object.assign({
          geometries: 'geojson',
          access_token: this.opts.accessToken
        }, params),
        cancelToken: this.cancelToken.token
      }).then(response => {
        const result = {
          points: undefined,
          feature: undefined,
          distanceMeters: 0,
          durationSeconds: 0,
          response
        };
        const {
          routes,
          waypoints
        } = (0, _utils.get)(response, 'data') || {};
        const route = routes[0] || {};
        const geometry = route.geometry;

        if (geometry) {
          const feature = new _Feature.default(geometry);
          result.feature = feature;
        }

        result.distanceMeters = route.distance || 0;
        result.durationSeconds = route.duration || 0;

        if ((0, _utils.isArray)(waypoints)) {
          result.waypoints = waypoints.map((waypoint, index) => new _Feature.default({
            type: 'Point',
            coordinates: waypoint.location,
            properties: {
              name: (0, _utils.isString)(points[index]) ? points[index] : undefined,
              distance: waypoint.distance
            }
          }));
        }

        resolve(result);
      }).catch(e => {
        if (this.cancelToken.isCancel(e) === false) {
          console.error('[Aeris] - MapboxRouteService - Directions request failed', e);
          reject(e);
        }
      });
    }));
  }

  geocode(search) {
    const url = (0, _strings.parse)(MAPBOX_GEOCODE_API, {
      query: search
    });
    return _Http.default.request(url, {
      params: {
        access_token: this.opts.accessToken
      },
      cancelToken: this.cancelToken.token
    }).then(response => {
      let coord;

      if (response.status === 200) {
        const {
          features
        } = response.data || {};

        if (features) {
          for (let i = 0, len = features.length; i < len; i += 1) {
            const feature = features[i];
            const {
              place_type: type = [],
              geometry
            } = feature;

            if (type.includes('place') || type.includes('poi')) {
              const [lon, lat] = geometry.coordinates;
              coord = {
                lat,
                lon
              };
              break;
            }
          }
        }
      }

      return coord;
    });
  }

  cancel() {
    if (this.cancelToken) {
      this.cancelToken.cancel();
    }

    this.cancelToken = undefined;
  }

}

var _default = MapboxRouteService;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 207 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Http = _interopRequireWildcard(__webpack_require__(101));

var _Feature = _interopRequireDefault(__webpack_require__(194));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const GOOGLE_DIRECTIONS_API = 'https://maps.googleapis.com/maps/api/directions/json';
const GOOGLE_GEOCODE_API = 'https://maps.googleapis.com/maps/api/geocode/json';

const loadDependencies = key => new Promise((resolve, reject) => {
  if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
    Promise.all([(0, _utils.loadScript)(`https://maps.googleapis.com/maps/api/js?key=${key}`)]).then(() => {
      resolve();
    });
  } else {
    resolve();
  }
});

class GoogleRouteService {
  constructor(opts) {
    this.opts = (0, _utils.extend)({}, opts);
  }

  getDirections(points, params) {
    this.cancel();
    this.cancelToken = (0, _Http.createCancelToken)();
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      let coords = [];
      const geocodingTasks = [];
      (points || []).forEach(point => {
        if ((0, _utils.isString)(point)) {
          geocodingTasks.push(this.geocode(point));
        } else {
          coords.push(point);
        }
      });

      if (geocodingTasks.length > 0) {
        try {
          const geocodingResult = yield Promise.all(geocodingTasks);

          if (geocodingResult) {
            coords = geocodingResult;
          }
        } catch (e) {
          if (this.cancelToken.isCancel(e) === false) {
            reject(e);
          }
        }
      }

      if (coords.length === 0) {
        console.warn('[Aeris] Routing - Cannot request directions, invalid or empty array of route coordinates provided.', points);
        return;
      }

      ; // directions API via client-side must be used through the Google Maps JS SDK
      // https://github.com/googlemaps/google-maps-services-js/issues/59

      yield loadDependencies(this.opts.accessToken);
      const count = coords.length;
      const origin = coords[0];
      const destination = coords[count - 1];
      const intermediate = coords.filter((_, i) => i > 0 && i < count - 1);

      if (!this.directionsService) {
        this.directionsService = new google.maps.DirectionsService();
      }

      this.directionsService.route({
        travelMode: google.maps.TravelMode.DRIVING,
        origin: `${origin.lat},${origin.lon}`,
        destination: `${destination.lat},${destination.lon}`,
        waypoints: intermediate.map(p => ({
          location: `${p.lat},${p.lon}`
        }))
      }, response => {
        const result = {
          points: undefined,
          feature: undefined,
          distanceMeters: 0,
          durationSeconds: 0,
          response
        };
        const routes = response.routes;
        const route = routes[0] || {};
        const legs = route.legs || [];
        const pathPoints = route.overview_path;
        let distanceMeters = 0;
        let durationSeconds = 0;

        if (pathPoints) {
          const pathCoords = pathPoints.map(point => [point.lng(), point.lat()]);
          result.feature = new _Feature.default({
            type: 'LineString',
            coordinates: pathCoords
          });
        }

        legs.forEach(leg => {
          distanceMeters += (0, _utils.get)(leg, 'distance.value', 0);
          durationSeconds += (0, _utils.get)(leg, 'duration.value', 0);
        });
        result.distanceMeters = distanceMeters;
        result.durationSeconds = durationSeconds;
        result.waypoints = intermediate.map((coord, index) => new _Feature.default({
          type: 'Point',
          coordinates: [coord.lon, coord.lat],
          properties: {
            name: (0, _utils.isString)(points[index + 1]) ? points[index + 1] : undefined,
            distance: 0
          }
        }));
        resolve(result);
      });
    }));
  }

  geocode(search) {
    return _Http.default.request(GOOGLE_GEOCODE_API, {
      params: {
        address: search,
        key: this.opts.accessToken
      },
      cancelToken: this.cancelToken.token
    }).then(response => {
      let coord;

      if (response.status === 200) {
        const {
          results
        } = response.data || {};

        if (results && results.length > 0) {
          const {
            lat,
            lng: lon
          } = (0, _utils.get)(results[0], 'geometry.location') || {};
          coord = {
            lat,
            lon
          };
        }
      }

      return coord;
    });
  }

  cancel() {
    if (this.cancelToken) {
      this.cancelToken.cancel();
    }

    this.cancelToken = undefined;
  }

}

var _default = GoogleRouteService;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 208 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.insetBounds = exports.intersects = exports.boundsAdjustedForAnchor = exports.isCenterPinned = exports.isRightPinned = exports.isLeftPinned = exports.isMiddlePinned = exports.isBottomPinned = exports.isTopPinned = exports.viewportSizeClass = exports.getPinnedPosition = void 0;

var _ = __webpack_require__(17);

const getPinnedPosition = (position, size, container, translate) => {
  let x = 0;
  let y = 0;
  translate = (0, _.extend)({
    x: 0,
    y: 0
  }, translate);

  if ((0, _.isString)(position)) {
    const anchor = position;
    x = (container.width - size.width) / 2;
    y = (container.height - size.height) / 2;

    if (/^top/.test(anchor)) {
      y = 0;
    } else if (/^bottom/.test(anchor)) {
      y = container.height - size.height;
    }

    if (/left$/.test(anchor)) {
      x = 0;
    } else if (/right$/.test(anchor)) {
      x = container.width - size.width;
    }
  } else {
    const p = position;
    x = p.x;
    y = p.y;
  }

  x += translate.x;
  y += translate.y;
  return {
    x,
    y
  };
};

exports.getPinnedPosition = getPinnedPosition;

const viewportSizeClass = () => {
  if (!window) return {
    width: null,
    height: null
  };
  let width = 'normal';
  let height = 'normal';

  if (window.matchMedia("(max-width: 500px)").matches) {
    width = 'compact';
  } else if (window.matchMedia("(min-width: 1000px)").matches) {
    width = 'desktop';
  }

  if (window.matchMedia("(max-height: 500px)").matches) {
    height = 'compact';
  } else if (window.matchMedia("(min-height: 1000px)").matches) {
    height = 'desktop';
  }

  return {
    width,
    height
  };
};

exports.viewportSizeClass = viewportSizeClass;

const isTopPinned = anchor => ['topleft', 'top', 'topright'].indexOf(anchor) !== -1;

exports.isTopPinned = isTopPinned;

const isBottomPinned = anchor => ['bottomleft', 'bottom', 'bottomright'].indexOf(anchor) !== -1;

exports.isBottomPinned = isBottomPinned;

const isMiddlePinned = anchor => ['left', 'center', 'right'].indexOf(anchor) !== -1;

exports.isMiddlePinned = isMiddlePinned;

const isLeftPinned = anchor => ['topleft', 'left', 'bottomleft'].indexOf(anchor) !== -1;

exports.isLeftPinned = isLeftPinned;

const isRightPinned = anchor => ['topright', 'right', 'bottomright'].indexOf(anchor) !== -1;

exports.isRightPinned = isRightPinned;

const isCenterPinned = anchor => ['top', 'center', 'bottom'].indexOf(anchor) !== -1;

exports.isCenterPinned = isCenterPinned;

const boundsAdjustedForAnchor = (bounds, size, anchor) => {
  const adjusted = Object.assign({}, bounds);

  if (isLeftPinned(anchor)) {
    bounds.right = bounds.left + size.width;
  } else if (isRightPinned(anchor)) {
    bounds.left = bounds.right - size.width;
  }

  return adjusted;
};

exports.boundsAdjustedForAnchor = boundsAdjustedForAnchor;

const intersects = (bounds1, bounds2, any = false) => {
  // const top = bounds2.top <= bounds1.top && bounds2.top >= bounds1.bottom;
  // const bottom = bounds2.bottom >= bounds1.bottom && bounds2.bottom <= bounds1.top;
  // const left = bounds2.left >= bounds1.left && bounds2.left <= bounds1.right;
  // const right = bounds2.right <= bounds1.right && bounds2.right >= bounds1.left;
  const right = bounds1.left >= bounds2.left && bounds1.left <= bounds2.right;
  const left = bounds1.right >= bounds2.left && bounds1.right <= bounds2.right;
  const top = bounds1.top >= bounds2.top && bounds1.top <= bounds2.bottom;
  const bottom = bounds1.bottom >= bounds2.top && bounds1.bottom <= bounds2.bottom;

  if (any) {
    return top || bottom || left || right;
  } // console.log(bounds1.left, bounds1.right, bounds1.top, bounds1.bottom);
  // console.log(bounds2.left, bounds2.right, bounds2.top, bounds2.bottom);
  // console.log(left, right, top, bottom);


  return (top || bottom) && (left || right);
};

exports.intersects = intersects;

const insetBounds = (bounds, inset = 0) => ({
  top: bounds.top + inset,
  bottom: bounds.bottom - inset,
  left: bounds.left + inset,
  right: bounds.right - inset,
  width: bounds.width - inset * 2,
  height: bounds.height - inset * 2
});

exports.insetBounds = insetBounds;

/***/ }),
/* 209 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.renderLocation = exports.getWindsFormatted = exports.getMarkerStyle = exports.generateRouteFeatures = exports.generateRouteData = exports.getLocationData = exports.filterWaypoints = exports.convertCoordsToGeoJSON = exports.convertPointsToFeatures = exports.createPoint = exports.configureForecastRequest = exports.configureRouteRequest = exports.getMarkerOpts = exports.getPropForDataType = exports.getEndpointForDataType = void 0;

var _Feature = _interopRequireDefault(__webpack_require__(194));

var _utils = __webpack_require__(17);

var _math = __webpack_require__(140);

var _number = __webpack_require__(183);

var _strings = __webpack_require__(133);

var _units = __webpack_require__(182);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PROP_MAPPING = {
  temps: ['tempF', 'tempC'],
  dewpt: ['dewpointF', 'dewpointC'],
  feelslike: ['feelslikeF', 'feelslikeC'],
  winds: ['windSpeedMPH', 'windSpeedKPH'],
  windgusts: ['windGustMPH', 'windGustKPH'],
  humidity: ['humidity', 'humidity'],
  precip: ['precipIN', 'precipMM'],
  sky: ['sky', 'sky'],
  weather: ['weatherPrimary', 'weatherPrimary']
};

const getEndpointForDataType = type => {
  if (type === 'alerts') {
    return 'alerts';
  }

  return 'forecasts';
};

exports.getEndpointForDataType = getEndpointForDataType;

const getPropForDataType = type => {
  const endpoint = getEndpointForDataType(type);
  const result = PROP_MAPPING[type];

  if (result) {
    let prefix = '';

    if (endpoint === 'observations') {
      prefix = 'ob.';
    } else if (endpoint === 'forecasts' || endpoint === 'conditions') {
      prefix = 'periods.';
    }

    return `${prefix}${result[0]}`;
  }

  if (endpoint === 'alerts') {
    return 'details.name,details.type,details.color,details.cat';
  }

  return '';
};

exports.getPropForDataType = getPropForDataType;

const getMarkerOpts = type => {
  switch (type) {
    case 'end':
    case 'start':
      return {
        fill: {
          color: '#222222'
        },
        stroke: {
          width: 4
        },
        size: [30, 30]
      };

    case 'current':
      return {
        fill: {
          color: '#ee6b00'
        },
        stroke: {
          width: 3
        },
        size: [22, 22]
      };

    default:
      return {
        fill: {
          color: '#222222'
        },
        stroke: {
          width: 2
        },
        size: [14, 14]
      };
  }
};

exports.getMarkerOpts = getMarkerOpts;

const configureRouteRequest = (request, dataType, endpoint, points) => {
  const dataProp = getPropForDataType(dataType);
  request.endpoint(endpoint);
  request.route(points.map(p => {
    const [lon, lat] = (0, _utils.get)(p, 'geometry.coordinates');
    const opts = dataType !== 'alerts' ? {
      from: (0, _utils.get)(p, 'properties.from')
    } : undefined;
    return Object.assign({
      p: `${lat},${lon}`
    }, opts);
  }));

  if (endpoint === 'forecasts') {
    const fields = ['temps', 'winds', 'windgusts', 'weather'].map(type => getPropForDataType(type));
    request.fields(`${fields.join(',')},request.skipped,periods.dateTimeISO`);
    request.filter('1min');
    request.plimit(1);
    request.mindist('10mi');
  } else if (endpoint === 'alerts') {
    request.fields(`${dataProp},request.skipped`);
    request.limit(1);
    request.mindist('5mi');
  }
};

exports.configureRouteRequest = configureRouteRequest;

const configureForecastRequest = (request, loc, timestamp) => {
  const forecastFields = `
		timestamp,dateTimeISO,tempF,tempC,icon,weatherPrimary,windSpeedMPH,windSpeedKPH,windSpeedMinMPH,windSpeedMinKPH,
		windSpeedMaxMPH,windSpeedMaxKPH,windGustMPH,windGustKPH
	`.split(',').map(key => `periods.${key}`);
  let dateParam = timestamp;

  if ((0, _utils.isNumber)(dateParam)) {
    dateParam = new Date(dateParam);
  }

  request.endpoint('forecasts').place(loc).fields(forecastFields.join(',')).filter('1hr').from(dateParam).limit(1);
  return {
    request,
    date: dateParam
  };
};

exports.configureForecastRequest = configureForecastRequest;

const createPoint = (coord, properties = {}) => ({
  type: 'Feature',
  geometry: {
    type: 'Point',
    coordinates: coord
  },
  properties
});

exports.createPoint = createPoint;

const convertPointsToFeatures = points => {
  const features = points.map(point => {
    const featureType = (0, _utils.get)(point, 'type');

    if (point instanceof _Feature.default) {
      return point;
    }

    if ((0, _utils.isset)(featureType)) {
      if (featureType === 'Point' || featureType === 'Feature') {
        return new _Feature.default(point);
      }
    }

    if ((0, _utils.isArray)(point)) {
      const [lon, lat] = point;
      return new _Feature.default({
        type: 'Point',
        coordinates: [lon, lat]
      });
    }

    if ((0, _utils.isPlainObject)(point)) {
      if ((0, _utils.isValidCoord)(point)) {
        const {
          lat,
          lon
        } = point;
        return new _Feature.default({
          type: 'Point',
          coordinates: [lon, lat]
        });
      }
    }

    return null;
  });
  return features.filter(v => (0, _utils.isset)(v));
};

exports.convertPointsToFeatures = convertPointsToFeatures;

const convertCoordsToGeoJSON = (coords, distance = 0, duration = 0) => {
  let totalDistance = 0;
  const points = coords.map((coord, i) => {
    let progress = 0;

    if (distance > 0) {
      if (i === coords.length - 1) {
        progress = 1;
      } else if (i > 0) {
        const lastCoord = coords[i - 1];
        totalDistance += (0, _math.geoDistance)(coord, lastCoord);
        progress = totalDistance / distance;
      }
    }

    return {
      type: 'Feature',
      geometry: {
        type: 'Point',
        coordinates: [coord.lon, coord.lat]
      },
      properties: {
        from: `+${Math.round(duration * progress / 60)}minutes`
      }
    };
  });
  return {
    points,
    distance: totalDistance
  };
};

exports.convertCoordsToGeoJSON = convertCoordsToGeoJSON;

const filterWaypoints = (waypoints, startCoord, endCoord) => waypoints.filter(waypoint => {
  let lat;
  let lon;
  let unique = true;

  if ((0, _utils.isArray)(waypoint)) {
    lat = waypoint[1];
    lon = waypoint[0];
  } else if (waypoint instanceof _Feature.default) {
    const coord = waypoint.geometry.toArray(true);
    lat = coord[1];
    lon = coord[0];
  } else if ((0, _utils.isPlainObject)(waypoint)) {
    lat = waypoint.lat;
    lon = waypoint.lon;
  }

  if (startCoord) {
    if (lon === startCoord[0] && lat === startCoord[1]) {
      unique = false;
    }
  }

  if (endCoord) {
    if (lon === endCoord[0] && lat === endCoord[1]) {
      unique = false;
    }
  }

  return unique;
});

exports.filterWaypoints = filterWaypoints;

const getLocationData = (point, place) => {
  if (!(0, _utils.isArray)(point) || point.length < 2) {
    return undefined;
  }

  const coord = {
    lat: point[1],
    lon: point[0]
  };
  const id = `${coord.lat}_${coord.lon}`;

  if (!place) {
    place = {
      lat: point[1],
      lon: point[0]
    };
  }

  return {
    id,
    place: (0, _utils.isPlainObject)(place) ? `${(0, _number.formatNumber)(place.lat, 4)}, ${(0, _number.formatNumber)(place.lon, 4)}` : (0, _strings.toName)(place),
    loc: coord
  };
};

exports.getLocationData = getLocationData;

const generateRouteData = (config, points) => {
  const configPoints = config.points || [];
  const startCoord = points[0];
  const endCoord = points[points.length - 1];
  const waypoints = (0, _utils.get)(config, 'data.waypoints') || configPoints.filter((v, i) => i !== 0 && i < configPoints.length - 1);
  let departure = (0, _utils.isset)(configPoints[0]) ? configPoints[0] : undefined;
  let destination = configPoints.length > 0 ? configPoints[configPoints.length - 1] : undefined;
  departure = (0, _utils.get)(config, 'data.departure.place') || departure;
  destination = (0, _utils.get)(config, 'data.destination.place') || destination;
  return (0, _utils.extend)({
    departure: {
      title: (0, _utils.get)(config, 'data.departure.title') || 'Departure',
      place: departure
    },
    destination: {
      title: (0, _utils.get)(config, 'data.destination.title') || 'Destination',
      place: destination
    }
  }, config.data, {
    departure: getLocationData(startCoord, departure),
    destination: getLocationData(endCoord, destination),
    waypoints: filterWaypoints(waypoints, startCoord, endCoord).map(waypoint => {
      if (waypoint instanceof _Feature.default) {
        const coord = waypoint.geometry.toArray(true);
        const name = (0, _utils.get)(waypoint.properties, 'name');
        return getLocationData(coord, name);
      }

      return getLocationData(undefined, waypoint);
    })
  });
};

exports.generateRouteData = generateRouteData;

const generateRouteFeatures = (routeId, points, routeData) => {
  const features = [];
  let startCoord;
  let endCoord;

  if ((0, _utils.isArray)(points)) {
    let currentFeature;

    const addFeature = () => {
      features.push({
        type: 'Feature',
        geometry: {
          type: 'LineString',
          coordinates: currentFeature.coords
        },
        properties: Object.assign(Object.assign({}, currentFeature.data), {
          routeId
        })
      });
    };

    const resetFeature = (coord, apiData) => {
      currentFeature = {
        data: apiData,
        coords: [coord]
      };
    };

    if (points.length > 1) {
      startCoord = (0, _utils.get)(points[0], 'geometry.coordinates');
      endCoord = (0, _utils.get)(points[points.length - 1], 'geometry.coordinates'); // add points for route markers

      const startFeature = createPoint(startCoord, {
        type: 'start',
        label: 'A',
        routeId,
        coordinate: {
          lat: startCoord[1],
          lon: startCoord[0]
        }
      });
      const endFeature = createPoint(endCoord, {
        type: 'end',
        label: 'B',
        routeId,
        coordinate: {
          lat: endCoord[1],
          lon: endCoord[0]
        }
      });
      features.push(startFeature, endFeature); // add line segments

      points.forEach((point, index) => {
        const coord = (0, _utils.get)(point, 'geometry.coordinates');
        const skipped = (0, _utils.get)(point, 'properties.request.skipped');
        const apiResponse = (0, _utils.get)(point, 'properties.response');

        if (index === 0) {
          resetFeature(coord, apiResponse);
        } else {
          currentFeature.coords.push(coord);

          if (index > 0 && !skipped || index === points.length - 1) {
            addFeature();
            resetFeature(coord, apiResponse);
          }
        }
      });
    }
  } // add points for route markers and waypoints


  if (routeData) {
    const {
      waypoints,
      current
    } = routeData;

    if (waypoints) {
      const filteredWaypoints = filterWaypoints(waypoints, startCoord, endCoord);
      filteredWaypoints.forEach((waypoint, index) => {
        if (waypoint instanceof _Feature.default) {
          const [lon, lat] = waypoint.geometry.toArray(true);
          features.push(createPoint([lon, lat], {
            type: 'waypoint',
            routeId,
            coordinate: {
              lat,
              lon
            },
            index
          }));
        }
      });
    }

    if (current && current.loc) {
      const {
        lat,
        lon
      } = current.loc || {};

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        features.push(createPoint([lon, lat], {
          type: 'current',
          routeId,
          coordinate: {
            lat,
            lon
          }
        }));
      }
    }
  }

  return features;
};

exports.generateRouteFeatures = generateRouteFeatures;

const getMarkerStyle = (modelData, routeData) => {
  const {
    type,
    label
  } = modelData;
  const markerOpts = getMarkerOpts(type); // use a custom marker style for this waypoint if defined

  const markerStyle = (0, _utils.get)(routeData, `${type}.markerStyle`);

  if (markerStyle) {
    return Object.assign({}, markerStyle);
  }

  return {
    className: 'marker-route-waypoint',
    svg: {
      shape: (0, _utils.extend)({
        type: 'circle',
        fill: {
          color: '#222222'
        },
        stroke: {
          color: '#ffffff',
          width: 2
        },
        size: [14, 14]
      }, markerOpts),
      text: label ? {
        value: label,
        anchor: 'start',
        color: '#ffffff',
        translate: {
          y: -2
        },
        autosize: false
      } : undefined
    },
    size: markerOpts.size || [14, 14]
  };
};

exports.getMarkerStyle = getMarkerStyle;

const getWindsFormatted = (data, metric = false) => {
  let result = 'Calm';

  if (data.windSpeedMaxMPH > 5) {
    if (metric) {
      result = `${(0, _utils.toRangeStr)(data.windSpeedMinKPH, data.windSpeedMaxKPH, 5)} ${(0, _units.unitsForDataType)('speed', true)}`;
    } else {
      result = `${(0, _utils.toRangeStr)(data.windSpeedMinMPH, data.windSpeedMaxMPH, 5)} ${(0, _units.unitsForDataType)('speed', false)}`;
    }
  } else if (data.windSpeedMaxMPH < 5 && data.windSpeedMinMPH > 0) {
    result = metric ? '< 8 kmh' : '< 5 mph';
  }

  return result;
};

exports.getWindsFormatted = getWindsFormatted;

const renderLocation = (type, data, includesDuration = true) => {
  const {
    weather,
    metric = false,
    selected = false,
    loc
  } = data;
  const dataAttr = [`data-waypoint-type="${data.type}"`];

  if ((0, _utils.isset)(loc)) {
    dataAttr.push(`data-coord="${loc.lat},${loc.lon}"`);
  }

  if (type === 'waypoint') {
    return `
			<div class="awxjs__routing-waypoint${selected ? ' awxjs__routing-location-selected' : ''}">
				<div class="awxjs__ui-row">
					<div class="awxjs__routing-marker">
						<div class="awxjs__routing-marker-connector"></div>
					</div>
					<div class="awxjs__routing-location-info">
						<div class="awxjs__text-md awxjs__text-bold">
							${data.place}
						</div>
					</div>
				</div>
			</div>
		`;
  }

  return `
		<div class="awxjs__routing-location${selected ? ' awxjs__routing-location-selected' : ''}">
			<div class="awxjs__ui-row">
				<div class="awxjs__routing-marker">
					<div class="awxjs__routing-marker-outer"></div>
					<div class="awxjs__routing-marker-inner"></div>
					<div class="awxjs__routing-marker-label">${data.indicator || ''}</div>
				</div>
				<div class="awxjs__routing-location-info awxjs__expand">
					<div class="awxjs__ui-cols">
						<div class="awxjs__expand">
							<div class="awxjs__text-lg awxjs__text-bold">
								${data.title}
							</div>
							<div class="awxjs__text-md">
								${data.place}
							</div>
							${includesDuration ? `
								<div class="awxjs__text-md awxjs__push-top">
									${data.timeLabel}:&nbsp;
									<strong>${(0, _utils.formatDate)(new Date(data.timestamp), 'h:mm a, MMM d, yyyy')}</strong>
								</div>
							` : ''}
						</div>
						${(0, _utils.isset)(loc) ? `
							<div class="awxjs__right">
								<div class="awxjs__ui-btn-icon awxjs__ui-btn-icon-filled awxjs__ui-btn-goto" ${dataAttr.join(' ')} title="Zoom to location">
									<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">
										<path d="M50,0C30.9,0,15.6,15.3,15.6,34.4C15.6,53.4,50,100,50,100s34.4-46.6,34.4-65.6C84.4,15.3,69.1,0,50,0z M50,50
											c-8.7,0-15.6-6.9-15.6-15.6c0-8.7,6.9-15.6,15.6-15.6c8.7,0,15.6,6.9,15.6,15.6C65.6,43.1,58.7,50,50,50z"/>
									</svg>
								</div>
							</div>
						` : ''}
					</div>
					${weather ? `
						<div class="awxjs__routing-location-wx">
							<div class="awxjs__ui-cols align-center">
								<div>
									<img class="awxjs__app__ui-panel-info__forecast-icon" src="https://cdn.aerisapi.com/wxblox/icons/${weather.icon || 'na.png'}">
								</div>
								<div class="awxjs__app__ui-panel-info__forecast-temp">
									${(0, _units.formatDataValue)(weather, 'tempF', 'tempC', metric)}
								</div>
								<div class="awxjs__app__ui-panel-info__forecast-conditions">
									<div class="awxjs__app__ui-panel-info__forecast-wx">
										${weather.weatherPrimary}
									</div>
									<div class="awxjs__app__ui-panel-info__forecast-detail">
										<span>Winds</span> ${getWindsFormatted(weather, metric)}
									</div>
								</div>
							</div>
						</div>
					` : ''}
				</div>
			</div>
		</div>
	`;
};

exports.renderLocation = renderLocation;

/***/ }),
/* 210 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.routeInfoView = exports.assetInfoView = exports.zoomRouteView = void 0;

var _utils = __webpack_require__(17);

var _color = __webpack_require__(139);

var _units = __webpack_require__(182);

var _utils2 = __webpack_require__(209);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const handleGoToMarker = (event, handler) => {
  const $el = (0, _DOM.default)(event.currentTarget);
  const coord = $el.data('coord');
  const type = $el.data('waypoint-type');

  if (!(0, _utils.isEmpty)(coord)) {
    const [lat, lon] = coord.split(',');

    if ((0, _utils.isset)(handler)) {
      handler({
        coordinate: {
          lat,
          lon
        },
        type
      });
    }
  }
};

const zoomRouteView = onClick => ({
  id: 'zoom',
  static: true,
  renderer: () => `
		<div class="awxjs__ui-btn awxjs__ui-btn-default awxjs__ui-btn-full awxjs__btn-routing-zoom">
			Zoom to Route
		</div>
	`,
  init: view => {
    view.el('.awxjs__btn-routing-zoom').on('click', () => {
      if (onClick) {
        onClick();
      }
    });
  }
});

exports.zoomRouteView = zoomRouteView;

const assetInfoView = onViewClick => ({
  id: 'asset',
  requiresData: true,
  init: view => {
    view.on('render', () => {
      view.el('.awxjs__ui-btn-goto').on('click', e => {
        handleGoToMarker(e, onViewClick);
      });
    });
  },
  data: data => (0, _utils.get)(data, 'route.asset'),
  renderer: data => {
    const {
      title,
      description,
      imageUrl,
      status,
      loc
    } = data;
    const badgeColor = (0, _utils.get)(status, 'color');
    const badgeTextColor = (0, _color.isLight)(badgeColor) ? '#333' : '#fff';
    const badgeStyles = `background-color: ${badgeColor}; color: ${badgeTextColor}`;
    const dataAttr = [`data-waypoint-type="current"`];

    if ((0, _utils.isset)(loc)) {
      dataAttr.push(`data-coord="${loc.lat},${loc.lon}"`);
    }

    return `
			<div class="awxjs__ui-cols">
				<div class="awxjs__text-xl awxjs__text-bold awxjs__push-bottom awxjs__ui-expand">
					${title}
				</div>
				${(0, _utils.isset)(loc) ? `
					<div class="awxjs__right">
						<div class="awxjs__ui-btn-icon awxjs__ui-btn-icon-filled awxjs__ui-btn-goto" ${dataAttr.join(' ')} title="Zoom to location">
							<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">
								<path d="M50,0C30.9,0,15.6,15.3,15.6,34.4C15.6,53.4,50,100,50,100s34.4-46.6,34.4-65.6C84.4,15.3,69.1,0,50,0z M50,50
									c-8.7,0-15.6-6.9-15.6-15.6c0-8.7,6.9-15.6,15.6-15.6c8.7,0,15.6,6.9,15.6,15.6C65.6,43.1,58.7,50,50,50z"/>
							</svg>
						</div>
					</div>
				` : ''}
			</div>
			<div class="awxjs__routing-asset__details">
				<div class="awxjs__ui-cols">
					<div>
						${(0, _utils.isset)(status) ? `
							<div class="awxjs__ui-row awxjs__ui-expand">
								<div class="awxjs__ui-expand label">Status</div>
								<div class="awxjs__ui-expand value">
									<div class="awxjs__routing-asset__details-status" style="${badgeStyles}">
										${(0, _utils.get)(status, 'label')}
									</div>
								</div>
							</div>
						` : ''}
						${description ? `
							<div class="awxjs__routing-asset__details-desc awxjs__text-sm awxjs__push-top">
								${description}
							</div>
						` : ''}
					</div>
					${imageUrl ? `
						<div class="awxjs__routing-asset__details-image">
							<img src="${(0, _utils.get)(data, 'imageUrl')}" />
						</div>
					` : ''}
				</div>
			</div>
		`;
  }
});

exports.assetInfoView = assetInfoView;

const routeInfoView = onViewClick => ({
  id: 'route',
  requiresData: true,
  init: view => {
    view.on('render', () => {
      view.el('.awxjs__ui-btn-goto').on('click', e => {
        handleGoToMarker(e, onViewClick);
      });
    });
  },
  data: data => {
    if (!(0, _utils.get)(data, 'route.departure') || !(0, _utils.get)(data, 'route.destination')) {
      return undefined;
    }

    const {
      departure,
      destination,
      waypoints = [],
      distanceMeters,
      durationSeconds
    } = (0, _utils.get)(data, 'route') || {};
    const departureWeather = (0, _utils.get)(data[`forecasts_${departure.id}`], '0.periods.0');
    const destinationWeather = (0, _utils.get)(data[`forecasts_${destination.id}`], '0.periods.0');
    return (0, _utils.extend)({}, data, {
      route: {
        distance: (0, _utils.isset)(distanceMeters) ? {
          distanceMI: distanceMeters * 0.00062,
          distanceKM: distanceMeters * 0.001
        } : undefined,
        duration: durationSeconds || 0,
        departure: {
          weather: departureWeather
        },
        destination: {
          weather: destinationWeather
        }
      }
    });
  },
  request: (account, data) => {
    const {
      departure,
      destination,
      durationSeconds = 0
    } = data || {};
    const request = account.api();
    let startTimestamp = Date.now();

    if (departure) {
      const {
        loc,
        timestamp = startTimestamp
      } = departure;

      if (loc) {
        const {
          lat,
          lon
        } = loc;
        const req = account.api();
        const {
          request: forecastRequest,
          date
        } = (0, _utils2.configureForecastRequest)(req, `${lat},${lon}`, timestamp);
        request.addRequest(forecastRequest);

        if (date) {
          startTimestamp = date.getTime();
        }
      }
    }

    if (destination) {
      const {
        loc,
        timestamp = startTimestamp + durationSeconds * 1000
      } = destination;

      if (loc) {
        const {
          lat,
          lon
        } = loc;
        const req = account.api();
        const {
          request: forecastRequest
        } = (0, _utils2.configureForecastRequest)(req, `${lat},${lon}`, timestamp);
        request.addRequest(forecastRequest);
      }
    }

    return request;
  },
  renderer: data => {
    const metric = data.units === "metric"
    /* Metric */
    ;
    const {
      departure,
      destination,
      waypoints = [],
      distance,
      duration,
      selectedIndex
    } = (0, _utils.get)(data, 'route') || {}; // console.log(data);

    const startLocation = (0, _utils2.renderLocation)('major', Object.assign(Object.assign({}, departure), {
      indicator: 'A',
      type: 'start',
      timeLabel: 'Departing',
      selected: selectedIndex === 'start',
      metric
    }), duration > 0);
    const endLocation = (0, _utils2.renderLocation)('major', Object.assign(Object.assign({}, destination), {
      indicator: 'B',
      type: 'end',
      timeLabel: 'Arriving',
      selected: selectedIndex === 'end',
      metric
    }), duration > 0);
    const waypointLocations = waypoints.length > 0 ? `<div class="awxjs__routing-waypoints">
			${waypoints.map((waypoint, index) => (0, _utils2.renderLocation)('waypoint', Object.assign(Object.assign({}, waypoint), {
      type: 'waypont',
      selected: index === selectedIndex
    }))).join('\n')}
				</div>` : '';
    return `
			${(0, _utils.isset)(distance) && distance.distanceMI > 0 ? `
				<div class="awxjs__text-md awxjs__push-bottom">
					<strong>${(0, _units.formatDataValue)(distance, 'distanceMI', 'distanceKM', metric)}</strong>
					${duration > 0 ? ` - ${(0, _units.secondsToString)(duration)}` : ''}
				</div>
			` : ''}
			<div class="awxjs__routing-route">
				<div class="awxjs__routing-track${duration > 0 ? ' awxjs__routing-track-tall' : ''}">
					<svg width="10px" height="300px" viewBox="0 0 10 300">
						<line x1="5" x2="5" y1="0" y2="300" stroke-width="4" stroke-linecap="round" stroke-dasharray="1,6"/>
					</svg>
				</div>
				${startLocation}
				${waypointLocations}
				${endLocation}
			</div>
		`;
  }
});

exports.routeInfoView = routeInfoView;

/***/ }),
/* 211 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getColor = exports.COLORS = void 0;

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(209);

const COLORS = {
  temps: [[-60, '#8f00ca'], [-55, '#7900a1'], [-50, '#630078'], [-45, '#840088'], [-40, '#a50099'], [-35, '#c900ba'], [-30, '#ed00dc'], [-25, '#f138ed'], [-20, '#f671ff'], [-15, '#e999f6'], [-10, '#dcc1ed'], [-5, '#7b60b4'], [0, '#1b007b'], [5, '#4428bd'], [10, '#6e51ff'], [15, '#8483ff'], [20, '#9bb6ff'], [25, '#59adfd'], [30, '#18a5fc'], [35, '#1052f1'], [40, '#0900e7'], [45, '#0e5873'], [50, '#14b000'], [55, '#84c204'], [60, '#f5d508'], [65, '#eba304'], [70, '#e17200'], [75, '#ea5200'], [80, '#f33300'], [85, '#e11900'], [90, '#d00000'], [95, '#a10000'], [100, '#720000'], [105, '#a00023'], [110, '#ce0046'], [115, '#e6256f'], [120, '#ff4b98']],
  winds: [[2, '#0050ff'], [3, '#007bff'], [4, '#1087ff'], [6, '#17b7fe'], [8, '#1bd3ff'], [10, '#34ff87'], [12.5, '#72ff09'], [15, '#b4ff08'], [17.5, '#efff0b'], [20, '#fee20a'], [25, '#f0b90a'], [30, '#ed9909'], [35, '#fd8609'], [40, '#fd5d08'], [45, '#fb3706'], [50, '#fb311b'], [55, '#fb2e28'], [60, '#fb2b36'], [65, '#fb3c44'], [70, '#fb4d53'], [75, '#fc5e63'], [80, '#fd7074'], [85, '#f87b7e'], [90, '#f48688'], [95, '#f09092'], [100, '#ec9a9c']]
};
exports.COLORS = COLORS;
const WEATHER = {
  rain: '#03be17',
  ice: '#f200b9',
  mix: '#a604dc',
  snow: '#0465dc',
  storms: '#ce0000',
  fog: '#f2cc00'
};

const getColorScale = type => {
  if (type === 'windgusts') {
    type = 'winds';
  }

  return COLORS[type];
};

const getColor = (type, data) => {
  let result = '#999999';
  const colors = getColorScale(type);

  if (type === 'alerts') {
    const alertColor = (0, _utils.get)(data, 'details.color');

    if ((0, _utils.isset)(alertColor)) {
      result = `#${alertColor}`;
    }
  } else {
    const prop = (0, _utils2.getPropForDataType)(type);
    const value = (0, _utils.get)(data, prop.replace(/periods\./, 'periods.0.'));

    if (type === 'weather') {
      let code = null;

      if (/(storm)/i.test(value)) {
        code = 'storms';
      } else if (/(rain|showers|drizzle)/i.test(value)) {
        code = 'rain';
      } else if (/(ice|freezing (rain|drizzle))/i.test(value)) {
        code = 'ice';
      } else if (/(rain\sand\ssnow|sleet)/i.test(value)) {
        code = 'mix';
      } else if (/(snow|flurries)/i.test(value)) {
        code = 'snow';
      } else if (/(fog)/i.test(value)) {
        code = 'fog';
      }

      if (WEATHER[code]) {
        result = WEATHER[code];
      }
    } else if (colors) {
      colors.forEach(([val, color]) => {
        if (value >= val) {
          result = color;
        }
      });
    }
  }

  return result;
};

exports.getColor = getColor;

/***/ }),
/* 212 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(7);
/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _css_loader_dist_cjs_js_routing_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(213);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_routing_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_routing_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _css_loader_dist_cjs_js_routing_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _css_loader_dist_cjs_js_routing_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),
/* 213 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".awxjs__app__ui-panel-info-content .awxjs__routing-asset__details .label {\n  line-height: 24px;\n  margin-right: 24px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-asset__details-status {\n  border-radius: 3px;\n  display: inline-block;\n  font-weight: bold;\n  padding: 4px 8px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-asset__details-desc {\n  margin-right: 20px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-asset__details-image img {\n  background: #eee;\n  border: 0;\n  border-radius: 3px;\n  min-height: 60px;\n  width: 120px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-route {\n  position: relative;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-track {\n  bottom: 87px;\n  left: 13px;\n  overflow: hidden;\n  position: absolute;\n  top: 40px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-track svg {\n  stroke: #ccc;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-track-tall {\n  bottom: 120px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location:first-child {\n  margin-bottom: 40px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location:last-child {\n  margin-top: 40px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-info {\n  margin-left: 20px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-wx {\n  margin-top: 8px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-wx .awxjs__app__ui-panel-info__forecast-icon {\n  margin-left: 0;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-wx .awxjs__app__ui-panel-info__forecast-temp {\n  font-size: 22px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-marker {\n  height: 36px;\n  position: relative;\n  width: 36px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-marker-inner, .awxjs__app__ui-panel-info-content .awxjs__routing-marker-outer, .awxjs__app__ui-panel-info-content .awxjs__routing-marker-label {\n  position: absolute;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-marker-outer {\n  border: 3px solid #333;\n  border-radius: 9999px;\n  height: 30px;\n  width: 30px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-marker-inner {\n  background: #333;\n  border-radius: 9999px;\n  height: 24px;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  width: 24px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-marker-label {\n  color: #fff;\n  font-size: 12px;\n  font-weight: bold;\n  left: 0;\n  right: 0;\n  text-align: center;\n  text-transform: uppercase;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-waypoint {\n  margin: 20px 0 20px 14px;\n  position: relative;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-waypoint .awxjs__routing-marker {\n  background: #666;\n  border-radius: 9999px;\n  height: 8px;\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  width: 8px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-waypoint .awxjs__routing-marker-connector {\n  background: #666;\n  height: 2px;\n  left: 8px;\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  width: 16px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-waypoint .awxjs__routing-location-info {\n  color: #666;\n  margin-left: 46px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-selected .awxjs__routing-marker-outer {\n  border-color: #1397ca;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-selected .awxjs__routing-marker-inner {\n  background: #1397ca;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-selected.awxjs__routing-waypoint .awxjs__routing-marker {\n  background: #1397ca;\n  height: 12px;\n  margin-left: -2px;\n  width: 12px;\n}\n.awxjs__app__ui-panel-info-content .awxjs__routing-location-selected.awxjs__routing-waypoint .awxjs__routing-marker-connector {\n  background: #1397ca;\n  width: 18px;\n}\n\n.awxjs__app__component.awxjs__mode-dark .awxjs__app__ui-panel-info .awxjs__routing-marker-inner {\n  background: #fff;\n}\n.awxjs__app__component.awxjs__mode-dark .awxjs__app__ui-panel-info .awxjs__routing-marker-outer {\n  border-color: #fff;\n}\n.awxjs__app__component.awxjs__mode-dark .awxjs__app__ui-panel-info .awxjs__routing-marker-label {\n  color: #333;\n}\n.awxjs__app__component.awxjs__mode-dark .awxjs__app__ui-panel-info .awxjs__routing-track svg {\n  stroke: #666;\n}\n", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),
/* 214 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(215)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 215 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ModuleGroup = _interopRequireDefault(__webpack_require__(216));

var _flightrules = __webpack_require__(165);

var _sigmets = __webpack_require__(168);

var _stationplots = __webpack_require__(170);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

/**
 * The Aviation module contains a series of modules that are specific to aviation usage.
 *
 * Includes:
 * - flight rules
 * - SIGMETs
 * - station plots
 *
 * @class AviationModule
 * @extends {ModuleGroup}
 */
class AviationGroup extends _ModuleGroup.default {
  get id() {
    return 'aviation';
  }

  controls() {
    return {
      title: 'Aviation',
      buttons: this.modules ? this.modules.map(m => m.controls()) : []
    };
  }

  load() {
    return __awaiter(this, void 0, void 0, function* () {
      const flightRules = yield (0, _flightrules.loader)();
      const stationPlots = yield (0, _sigmets.loader)();
      const sigmets = yield (0, _stationplots.loader)();
      return new Promise((resolve, reject) => {
        this._modules = [flightRules, stationPlots, sigmets].map(Module => new Module.default()); // eslint-disable-line new-cap

        resolve(this._modules);
      });
    });
  }

}

var _default = AviationGroup;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 216 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

/**
 * A module group is a container module for one or more child modules.
 *
 * @class ModuleGroup
 */
class ModuleGroup {
  /**
   * Creates and initializes a module group instance with the optional array of child modules if
   * provided. Alternatively, child modules can be loaded on-demand using the group's `load()`
   * method.
   *
   * @param {IMapSourceModule[]} [modules=null]
   * @memberof ModuleGroup
   */
  constructor(modules = null) {
    if (modules) {
      this._modules = [...modules];
    }
  }
  /**
   * Module identifier
   *
   * @readonly
   * @type {string}
   * @memberof ModuleGroup
   */


  get id() {
    return null;
  }
  /**
   * Array of child modules associated with the group.
   *
   * For groups that load on-demand modules, this value will be `null` until the modules have
   * been loaded via the group's `load()` method.
   *
   * @readonly
   * @type {IMapSourceModule[]}
   * @memberof ModuleGroup
   */


  get modules() {
    return this._modules;
  }
  /**
   * Aeris account associated with the module group.
   *
   * @readonly
   * @type {Account}
   * @memberof MapSourceModule
   */


  get account() {
    return this._account;
  }
  /**
   * Application the module group was initialized with.
   *
   * @readonly
   * @type {InteractiveMapApp}
   * @memberof MapSourceModule
   */


  get app() {
    return this._app;
  }
  /**
   * Application map instance.
   *
   * @readonly
   * @type {InteractiveMap}
   * @memberof MapSourceModule
   */


  get map() {
    return (0, _utils.isset)(this._app) ? this._app.map : this._map;
  }
  /**
   * Initializes the module group with the specified AerisWeather account and application.
   *
   * @param {Account} account
   * @param {InteractiveMapApp} app
   * @memberof MapSourceModule
   */


  initialize(account, app, map = null) {
    this._account = account;
    this._app = app;
    this._map = app ? app.map : map;
  }
  /**
   * Returns the app controls configuration for the module.
   *
   * @returns {*}
   * @memberof ModuleGroup
   */


  controls() {
    return null;
  }
  /**
   * Loads the child modules associated with the module group. This is an asynchronous method
   * that returns a Promise that provides the array of modules for the group once they've been
   * loaded.
   *
   * @returns {Promise<any>}
   * @memberof ModuleGroup
   */


  load() {
    return null;
  }

}

var _default = ModuleGroup;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 217 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loader = loader;
exports.utils = utils;

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/* eslint-disable import/prefer-default-export */


function loader() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(218)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

function utils() {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(__webpack_require__(181)));
    return new Promise((resolve, reject) => {
      resolve(module);
    }).catch(error => {
      console.error('AerisWeather.Module - ERROR', error);
    });
  });
}

/***/ }),
/* 218 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ModuleGroup = _interopRequireDefault(__webpack_require__(216));

var _systems = __webpack_require__(179);

var _invests = __webpack_require__(186);

var _windfields = __webpack_require__(188);

var _breakpoints = __webpack_require__(190);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class TropicalGroup extends _ModuleGroup.default {
  get id() {
    return 'tropical';
  }

  load() {
    return __awaiter(this, void 0, void 0, function* () {
      const systems = yield (0, _systems.loader)();
      const invests = yield (0, _invests.loader)();
      const windfields = yield (0, _windfields.loader)();
      const breakpoints = yield (0, _breakpoints.loader)();
      return new Promise((resolve, reject) => {
        this._modules = [systems, invests, windfields, breakpoints].map(Module => new Module.default()); // eslint-disable-line new-cap

        resolve(this._modules);
      });
    });
  }

  controls() {
    return {
      title: 'Tropical',
      buttons: this.modules ? this.modules.map(m => m.controls()) : []
    };
  }

}

var _default = TropicalGroup;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 219 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Views = void 0;

var _InteractiveMap2 = _interopRequireDefault(__webpack_require__(220));

var _MapView = _interopRequireDefault(__webpack_require__(315));

var _LegendView = _interopRequireDefault(__webpack_require__(319));

var _sources = __webpack_require__(229);

var mapUtils = _interopRequireWildcard(__webpack_require__(254));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../node_modules/@types/leaflet/index.d.ts" />
/// <reference path="../../node_modules/@types/mapbox-gl/index.d.ts" />
/// <reference path="../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/* eslint-disable func-names */

/* eslint-disable object-shorthand */

/* eslint-disable no-redeclare */

/**
 * @ignore
 * Private class extension to better handle naming conflicts within this public interface.
 *
 * @class _InteractiveMap
 * @extends {Map}
 */
class _InteractiveMap extends _InteractiveMap2.default {}
/**
 * @ignore
 */


let _account;
/**
 * @ignore
 */


let _servers;
/**
 * The `Views` module provides the public interface for all mapping functionality, including both
 * static and interactive map views.
 */


var Views;
exports.Views = Views;

(function (Views) {
  /**
   * Provides access to the `View` module's utility functions.
   *
   * @readonly
   * @type { [key: string]: Function }
   */
  Views.utils = Object.assign({}, mapUtils);
  /**
   * Data source classes that can be used to add custom datasets to an `InteractiveMap` instance.
   *
   * @readonly
   * @type {
   * 			Tile: TileSource,
   * 			Vector: VectorSource,
   * 			GeoJson: GeoJsonSource,
   *          Text: TextSource
   * 		}
   */

  Views.datasources = {
    Tile: _sources.TileSource,
    Vector: _sources.VectorSource,
    GeoJson: _sources.GeoJsonSource,
    Text: _sources.TextSource
  };
  /**
   * Sets the Aeris account instance to use with the `Views` module.
   *
   * @param {Account} account
   */

  Views.setAccount = account => {
    _account = account;
  };
  /**
   * Sets the base paths for the API servers to use with data and image requests.
   *
   * @param {Servers} servers
   */


  Views.setServers = servers => {
    _servers = servers;
  };
  /**
   * Initializes and returns a new `Map` instance.
   *
   * @param {*} target
   * @param {InteractiveMapOptions} [opts]
   * @param {(map: Map) => void} [onInit]
   * @returns {InteractiveMap}
   */


  Views.InteractiveMap = function (target, opts, onInit) {
    return new _InteractiveMap(target, Object.assign({}, opts, {
      account: _account,
      servers: opts.servers || _servers
    }), onInit);
  };
  /**
   * Initializes and returns a new `MapView` instance.
   *
   * @param {HTMLElement} target
   * @param {MapViewOptions} [opts]
   * @returns {MapView}
   */


  Views.Map = function (target, opts) {
    return new _MapView.default(target, Object.assign({}, opts, {
      account: _account,
      servers: opts.servers || _servers
    }));
  };
  /**
   * Initializes and returns a new `LegendView` instance.
   *
   * @param {HTMLElement} target
   * @param {LegendOptions} [opts]
   * @returns {LegendView}
   */


  Views.Legend = function (target, opts) {
    return new _LegendView.default(target, Object.assign({}, opts, {
      account: _account
    }));
  };
})(Views || (exports.Views = Views = {}));

/***/ }),
/* 220 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.isModule = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _Timeline = _interopRequireDefault(__webpack_require__(221));

var _constants = __webpack_require__(225);

var _CoordinateBounds = __webpack_require__(198);

var _strategies = __webpack_require__(226);

var _sources = __webpack_require__(229);

var _MapLayerConfig = _interopRequireDefault(__webpack_require__(286));

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(302));

var _Layers = _interopRequireDefault(__webpack_require__(300));

var _MapRequest = _interopRequireDefault(__webpack_require__(135));

var _utils = __webpack_require__(254);

var _utils2 = __webpack_require__(17);

var _utils3 = __webpack_require__(303);

var _DataSourceStore = _interopRequireDefault(__webpack_require__(304));

var _MaplibreMapStrategy = _interopRequireDefault(__webpack_require__(306));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const layerToModuleMapping = {
  'tropical-cyclones': 'tropical.Systems',
  'tropical-cyclones-break-points': 'tropical.Breakpoints'
};

const isModule = key => (0, _utils2.isset)(layerToModuleMapping[key]);
/**
 * An `InteractiveMap` object provides an abstract interface for displaying weather-related data on an interactive map view using
 * one of the supported third-party mapping libraries.
 *
 * @export
 * @class InteractiveMap
 * @extends {EventDispatcher}
 * @implements {MapStrategyDataSource}
 */


exports.isModule = isModule;

class InteractiveMap extends _EventDispatcher.default {
  /**
   * Initializes a map instance with the specified target and configuration object.
   *
   * @param {*} target Either the `HTMLElement` where you want your map view to be rendered, or
   * an existing map object instance that pertains to one of the supported third-party mapping
   * libraries. If a map object instance if provided, then that instance will be used for
   * rendering weather data instead of the library creating a new instance.
   * @param {InteractiveMapOptions} [opts] Map configuration
   * @param {(map: InteractiveMap) => void} [onInit] Optional callback to be called when the map
   * view has been fully initialized
   * @memberof InteractiveMap
   */
  constructor(target, opts, onInit) {
    super();
    this._ready = false;
    this._metric = false;
    this.store = new _DataSourceStore.default();
    this._stateForData = {};
    this._resumeAnimationTimer = null;
    this._resumeOnBoundsChange = false;
    /**
     * Updates the map timeline and all active map content sources on the map.
     *
     * @memberof InteractiveMap
     */

    this.update = (0, _utils2.debounce)(() => {
      this._loadForBounds(true);
    }, 250);
    this._dblClickTimer = null;

    if (!target) {
      throw new Error('[Aeris] Invalid target specified for InteractiveMap, which must be a DOM element or map instance');
    }

    opts = opts || {}; // if a map object was passed instead of an HTMLElement, set the appropriate strategy type

    if (target instanceof HTMLElement === false) {
      if ((0, _utils.isLeaflet)(target)) {
        opts.strategy = 'leaflet';
      } else if ((0, _utils.isMapbox)(target)) {
        opts.strategy = 'mapbox';
      } else if ((0, _utils.isMaplibre)(target)) {
        opts.strategy = 'maplibre';
      } else if ((0, _utils.isGoogle)(target)) {
        opts.strategy = 'google';
      } else if ((0, _utils.isOpenLayers)(target)) {
        opts.strategy = 'openlayers';
      }
    }

    opts = (0, _utils2.extend)({
      strategy: 'leaflet',
      center: undefined,
      zoom: 7,
      metric: false,
      timeline: {
        from: -2 * 3600,
        to: 0,
        intervals: 10,
        bufferIntervals: 2,
        showLoading: true,
        showLoadingIntervals: true,
        resetOnBoundsChange: false
      },
      refresh: 0,
      attribution: true,
      onInit: undefined,
      reloadOnBoundsChange: true
    }, opts);
    this._opts = opts;

    if (opts.account) {
      this.account = opts.account;
    }

    if (opts.strategy === 'mapbox') {
      this._strategy = new _strategies.MapboxMapStrategy(target, opts);
    } else if (opts.strategy === 'maplibre') {
      this._strategy = new _MaplibreMapStrategy.default(target, opts);
    } else if (opts.strategy === 'google') {
      this._strategy = new _strategies.GoogleMapStrategy(target, opts);
    } else if (opts.strategy === 'openlayers') {
      this._strategy = new _strategies.OpenLayersMapStrategy(target, opts);
    } else {
      this._strategy = new _strategies.LeafletMapStrategy(target, opts);
    }

    this._strategy.dataSource = this;
    this._timeline = new _Timeline.default((0, _utils2.extend)(opts.timeline, {
      key: 'map-timeline'
    }));
    this._sourceOrder = {
      tile: []
    };
    this._layers = new _Layers.default(this.account);
    this._config = new _MapLayerConfig.default(opts.styles);
    this._metric = this._opts.metric;

    const onReady = () => {
      this._indicator = new _ActivityIndicator.default();

      this._indicator.appendTo(this.strategy.$el);

      this.strategy.$el.addClass('awxjs__ia-map');

      this._setupEvents();

      this._ready = true; // add layers if defined in config options

      if (opts.layers) {
        let layers = opts.layers;

        if (!(0, _utils2.isArray)(layers)) {
          layers = layers.split(',');
        }

        layers.forEach(layer => {
          if ((0, _utils2.isString)(layer)) {
            this.addLayer(layer);
          } else if ((0, _utils2.isPlainObject)(layer)) {
            const {
              layer: code,
              options
            } = layer;
            this.addLayer(code, options);
          }
        });
      }

      if (opts.refresh > 0) {
        this.enableAutoUpdate(opts.refresh);
      }

      if (onInit) onInit(this);
      this.trigger("load"
      /* LOAD */
      );
      this.trigger("ready"
      /* READY */
      );
    };

    this._layers.fetch().then(() => {
      // strategy may not be ready if it requires loading additional assets at runtime
      if (!this.strategy.isReady()) {
        this.strategy.on('ready', e => {
          onReady();
        });
      } else {
        onReady();
      }
    });
  }
  /**
   * Returns the underlying third-party map object instance associated with the current map strategy.
   *
   * @readonly
   * @memberof InteractiveMap
   */


  get map() {
    return this.strategy.map;
  }
  /**
   * Returns the current map strategy being used.
   *
   * @readonly
   * @type {MapStrategy}
   * @memberof InteractiveMap
   */


  get strategy() {
    return this._strategy;
  }
  /**
   * Returns the configured options for the map.
   *
   * @readonly
   * @type {InteractiveMapOptions}
   * @memberof InteractiveMap
   */


  get opts() {
    return this._opts;
  }
  /**
   * Configuration and style manager for the map content sources and associated layers.
   *
   * @readonly
   * @type {MapLayerConfig}
   * @memberof InteractiveMap
   */


  get config() {
    return this._config;
  }
  /**
   * Returns the map's animation timeline.
   *
   * @readonly
   * @type {Timeline}
   * @memberof InteractiveMap
   */


  get timeline() {
    return this._timeline;
  }
  /**
   * Returns the layer metadata info instance.
   *
   * @readonly
   * @type {Layers}
   * @memberof InteractiveMap
   */


  get layerInfo() {
    return this._layers;
  }
  /**
   * The Aeris account to use when requesting data for the map.
   *
   * @type {Account}
   * @memberof InteractiveMap
   */


  get account() {
    return this._account;
  }

  set account(value) {
    this._account = value;
  }
  /**
   * Returns whether the current map units are set to metric.
   *
   * @readonly
   * @type {boolean}
   * @memberof InteractiveMap
   */


  get isMetric() {
    return this._metric;
  }
  /**
   * Returns whether the map is ready, meaning the underlying map view and events have been fully
   * setup and initialized.
   *
   * @returns {boolean}
   * @memberof InteractiveMap
   */


  isReady() {
    return this.strategy.isReady();
  }
  /**
   * Returns the map's center coordinate.
   *
   * @returns {Coordinate}
   * @memberof InteractiveMap
   */


  getCenter() {
    return this.strategy.getCenter();
  }
  /**
   * Sets the map's center coordinate.
   *
   * @param {Coordinate} coord
   * @memberof InteractiveMap
   */


  setCenter(coord) {
    this.strategy.setCenter(coord);
  }
  /**
   * Returns the current map zoom level.
   *
   * @returns {number}
   * @memberof InteractiveMap
   */


  getZoom() {
    return this.strategy.getZoom();
  }
  /**
   * Sets the map zoom level.
   *
   * @param {number} zoom
   * @memberof InteractiveMap
   */


  setZoom(zoom) {
    this.strategy.setZoom(zoom);
  }
  /**
   * Sets the map's center coordinate and zoom level.
   *
   * @param {Coordinate} center
   * @param {number} zoom
   * @memberof InteractiveMap
   */


  setView(center, zoom) {
    this.strategy.setView(center, zoom);
  }
  /**
   * Returns the geographical bounds for the visible map region.
   *
   * @returns {GeoBounds}
   * @memberof InteractiveMap
   */


  getBounds() {
    return this.strategy.getBounds();
  }
  /**
   * Sets the map bounds to contain the specified geographical bounds.
   *
   * @param {GeoBounds} bounds
   * @memberof InteractiveMap
   */


  setBounds(bounds) {
    this.strategy.setBounds(bounds);
  }
  /**
   * Sets the map bounds to contain the specified geographical bounds with optional padding insets.
   *
   * @param {GeoBounds} bounds
   * @param {number[]} [padding]
   * @memberof InteractiveMap
   */


  fitBounds(bounds, padding) {
    padding = padding || [10, 10];
    this.strategy.fitBounds(bounds, padding);
  }
  /**
   * Sets the units to display on the map.
   *
   * Map content sources that display measurement values should observe the change:unit event
   * and update their content on the map accordingly.
   *
   * @param {boolean} isMetric
   * @memberof InteractiveMap
   */


  setMetric(isMetric) {
    if (this._metric !== isMetric) {
      this._metric = isMetric;
      this.trigger("change:units"
      /* CHANGE_UNITS */
      , {
        metric: isMetric,
        unit: isMetric ? "metric"
        /* Metric */
        : "imperial"
        /* Imperial */

      });
    }
  }
  /**
   * AMP Layers
   */

  /**
   * Adds an AMP layer to the map for the specified layer code.
   *
   * @param {string} layer
   * @param {LayerOptions} [opts]
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  addLayer(layer, opts) {
    this._checkReady();

    if (!(0, _utils2.isset)(layer) || (0, _utils2.isEmpty)(layer) || !(0, _utils2.isString)(layer)) {
      console.warn(`[Aeris] Cannot add invalid layer code {${layer}} to InteractiveMap.`, layer);
      debugger;
      return this;
    }

    const key = (0, _utils3.identifierForLayer)(layer);
    const identifier = (0, _utils2.get)(opts, 'id') || key;
    let source = this.getSourceForId(identifier); // if (!source && identifier === layerKey) {
    // 	source = this.getSourceForLayer(layerKey);
    // }

    if (source) {
      return this;
    } // handle backwards compatibility for layers that are now part of lazy-loaded modules
    // if the layer is associated with a lazy-loaded map module, we need to load the module first
    // and then add its source to the map


    const layerModule = layerToModuleMapping[layer];

    if (layerModule) {
      (0, _utils.loadMapModuleConfig)(layerModule, (id, config, module) => {
        const mid = (0, _utils2.get)(opts, 'id') || id;

        if (module) {
          module.initialize(this.account, null, this);
        }

        config = (0, _utils2.extend)({}, config, opts);
        const moduleSource = this.createSource(mid, config.type, config);
        moduleSource.code = layer;
        this.store.mapping.set(layer, mid);
        this.addSource(moduleSource, opts); // need to trigger layer:add event since this source is being added via addLayer()

        this.trigger("layer:add"
        /* LAYER_ADD */
        , {
          id: identifier,
          layer: key,
          source
        });
      });
      return this;
    }

    source = (0, _utils3.createAerisSource)(layer, (0, _utils2.extend)({}, (0, _utils2.cloneDeep)(opts), {
      account: this.account,
      servers: this._opts.servers,
      time: this.timeline.currentDate(),
      attribution: this._opts.attribution ? _constants.AERIS_ATTRIBUTION : null,
      timeline: {
        intervals: (0, _utils2.get)(this._opts, 'timeline.intervals'),
        alwaysShowPast: (0, _utils2.get)(this._opts, 'timeline.alwaysShowPast'),
        alwaysShowFuture: (0, _utils2.get)(this._opts, 'timeline.alwaysShowFuture'),
        bufferIntervals: (0, _utils2.get)(this._opts, 'timeline.bufferIntervals'),
        showLoadingIntervals: (0, _utils2.get)(this._opts, 'timeline.showLoadingIntervals')
      }
    }), this.strategy.factory, this._layers);

    if (source) {
      source.code = key;
      this.addSource(source, opts);
      this.store.mapping.set(key, identifier);
      this.trigger("layer:add"
      /* LAYER_ADD */
      , {
        id: identifier,
        layer: key,
        source
      }); // const zIndex = get(opts, 'style.zIndex');
      // if (source instanceof TileSource && isset(zIndex)) {
      // 	this.setLayerOrder(layer, zIndex);
      // }
    }

    return this;
  }
  /**
   * Adds a series of AMP layers for the specified array of layer codes.
   *
   * @param {string[]} layers
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  addLayers(layers) {
    this._checkReady();

    layers.forEach(layer => this.addLayer(layer));
    return this;
  }
  /**
   * Removes an AMP layer from the map for the specified layer code.
   *
   * @param {string} layer
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeLayer(layer) {
    layer = layer.replace(/\:.+$/, '');
    const source = this.getSourceForLayer(layer);

    if (!source) {
      return this;
    }

    this.removeSource(source); // this.trigger(MapEvent.LAYER_REMOVE, {
    // 	layer: layer.replace(/\:[^,]+/g, ''), source
    // });

    const key = this.store.mapping.get(source.key);
    const identifier = this.store.mapping.get(key);
    this.trigger("layer:remove"
    /* LAYER_REMOVE */
    , {
      id: identifier,
      layer: key,
      source
    });
    return this;
  }
  /**
   * Removes an AMP layer from the map for the specified identifier.
   *
   * @param {string} id
   * @returns
   * @memberof InteractiveMap
   */


  removeLayerForId(id) {
    const source = this.getSourceForId(id);

    if (!source) {
      return this;
    }

    ;
    const key = this.store.mapping.get(source.key);
    const identifier = this.store.mapping.get(key);
    this.removeSource(source);
    this.trigger("layer:remove"
    /* LAYER_REMOVE */
    , {
      id: identifier,
      layer: key,
      source
    });
    return this;
  }
  /**
   * Removes a series of AMP layers associated with the specified array of layer codes.
   *
   * @param {string[]} layers
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeLayers(layers) {
    layers.forEach(layer => this.removeLayer(layer));
    return this;
  }
  /**
   * Updates the layer's zIndex order by bringing it to the top of the layer stack. This only
   * affects tile and image layers.
   *
   * @param {string} layer
   * @memberof InteractiveMap
   */


  bringLayerToFront(layer) {
    const source = this.getSourceForLayer(layer);
    const index = this.store.count;

    if (source && source instanceof _sources.TileSource) {
      const order = this._sourceOrder.tile;
      const previous = order.indexOf(layer);

      if (previous !== -1) {
        order.splice(previous, 1);
        order.push(layer);
      } // update all source z-index values so they aren't at the same index


      Object.keys(this.store.items).forEach(key => {
        const keySource = this.store.get(key);

        if (keySource instanceof _sources.TileSource) {
          // add 1 to the z-index since the map library base layer is at index 0
          keySource.setOrder(order.indexOf(key) + 1);
        }
      });
    }
  }
  /**
   * Updates the layer's zIndex order by sending it to the bottom of the layer stack. This only
   * affects tile and image layers.
   *
   * @param {string} layer
   * @memberof InteractiveMap
   */


  sendLayerToBack(layer) {
    const source = this.getSourceForLayer(layer);

    if (source && source instanceof _sources.TileSource) {
      const order = this._sourceOrder.tile;
      const previous = order.indexOf(layer);

      if (previous !== -1) {
        order.splice(previous, 1);
        order.splice(0, 0, layer);
      } // update all source z-index values so they aren't at the same index


      Object.keys(this.store.items).forEach(key => {
        const keySource = this.store.get(key);

        if (keySource instanceof _sources.TileSource) {
          // add 1 to the z-index since the map library base layer is at index 0
          keySource.setOrder(order.indexOf(key) + 1);
        }
      });
    }
  }
  /**
   * Updates the layer's zIndex order. This only affects tile and image layers.
   *
   * @param {string} layer
   * @param {number} zIndex
   * @memberof InteractiveMap
   */


  setLayerOrder(layer, zIndex) {
    const source = this.getSourceForLayer(layer);

    if (source && source instanceof _sources.TileSource && (0, _utils2.isset)(zIndex)) {
      source.setOrder(zIndex);
    }
  }
  /**
   * Returns the map content source associated with the specified layer code, if any.
   *
   * @param {string} layer
   * @returns {*}
   * @memberof InteractiveMap
   */


  getSourceForLayer(layer) {
    const mappedId = this.store.mapping.get(layer);

    if (mappedId) {
      return this.getSource(mappedId);
    }

    return this.getSource(layer);
  }
  /**
   * Returns the map content source associated with the specified identifier, if any.
   *
   * @param {string} id
   * @returns {*}
   * @memberof InteractiveMap
   */


  getSourceForId(id) {
    const mappedId = this.store.mapping.get(id);

    if (mappedId) {
      return this.getSource(mappedId);
    }

    return this.getSource(id);
  }
  /**
   * Instantiates and returns a new map content source instance based on the specified type and
   * configuration options.
   *
   * @param {string} key
   * @param {string} type
   * @param {any} config
   * @returns {any}
   * @memberof InteractiveMap
   */


  createSource(key, type, config) {
    return (0, _utils3.createSource)(key, type, Object.assign({
      account: this.account,
      servers: this._opts.servers
    }, config), this.strategy.factory);
  }
  /**
   * Content Sources
   */

  /**
   * Adds a new map content source for the specified layer code.
   *
   * @param {*} source
   * @param {string} key
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  addSource(source, opts) {
    this._checkReady();

    if (!(0, _utils2.isset)(source.key)) {
      console.error('[Aeris] Cannot add a data source with an undefined key to the map. Make sure you have set the `key` property on your data source before adding to the map.');
      return this;
    }

    source.strategy = this.strategy;
    source.enabled = true;
    source.identifier = source.key;
    this.store.add(source.identifier, source);
    this.strategy.addSource(source);
    const style = (0, _utils2.get)(opts, 'style');

    if (style) {
      this._updateSourceStyle(source, style);
    }

    if ((0, _utils2.has)(source, 'animation') && (0, _utils2.isset)(source.animation)) {
      if (source.animation.isEnabled() === true) {
        this.timeline.add(source.key, source.animation);
      }
    }

    const bounds = this.getBounds();

    if (source instanceof _sources.VectorSource) {
      source.on('data:load:start', e => this.trigger("source:load:start"
      /* SOURCE_LOAD_START */
      , e.data));
      source.on('data:load:done', e => this.trigger("source:load:done"
      /* SOURCE_LOAD_DONE */
      , e.data));
      source.load({
        bounds,
        from: this.timeline.startDate(),
        to: this.timeline.endDate()
      }).catch(error => {
        console.error(`[Aeris] Failed to load data for VectorSource with key ${source.key}`, error);
      });
    }

    this.trigger("source:add"
    /* SOURCE_ADD */
    , {
      source,
      id: source.key
    });
    return this;
  }
  /**
   * Adds the map content source associated with a map module.
   *
   * @param {*} module
   * @param {*} [overrides=null]
   * @memberof InteractiveMap
   */


  addModule(module, overrides = null, constructorOpts = null) {
    const initialize = _module => {
      _module.initialize(this.account, null, this);

      const config = _module.source();

      const source = this.createSource(_module.id, config.type, (0, _utils2.extend)({}, config, overrides));

      if (source) {
        this.addSource(source);
      }
    };

    const setup = _module => {
      if (this.isReady) {
        initialize(_module);
      } else {
        this.on('ready', () => {
          initialize(_module);
        });
      }
    }; // determine if we're loading in a pre-built module from the library, which we then need
    // to load and then create an instance of before adding


    if ((0, _utils2.isFunction)(module)) {
      module().then(Module => {
        Module = Module.default || Module;
        const result = new Module(constructorOpts);
        setup(result);
      });
    } else if ((0, _utils2.has)(module, 'source')) {
      setup(module);
    }
  }
  /**
   * Removes the map content source associated with the specified layer code.
   *
   * @param {*} source
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeSource(source) {
    source.enabled = false;
    this.strategy.removeSource(source);

    if ((0, _utils2.has)(source, 'animation') && (0, _utils2.isset)(source.animation)) {
      if (source.animation.isEnabled() === true) {
        source.animation.reset();
        this.timeline.remove(source.animation);
      }
    }

    if ((0, _utils2.has)(source, 'reset')) {
      source.reset();
    }

    this.store.remove(source.identifier);
    this.store.each((key, item) => {
      if (item === source) {
        this.store.remove(key);
      }
    }); // const layer = this.store.mapping(source.key);
    // const key = this.store.mapping(source.key);
    // const identifier = this.store.mapping(key);

    const identifier = source.key;
    const layer = source.code;
    this.trigger("source:remove"
    /* SOURCE_REMOVE */
    , {
      source,
      id: identifier,
      layer
    });
    return this;
  }
  /**
   * Removes all active data sources from the map.
   *
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeAllSources() {
    this.store.each((_, source) => {
      this.removeSource(source);
    });
    return this;
  }
  /**
   * Returns the map content source associated with the specified key, if any.
   *
   * @param {string} key
   * @returns {*}
   * @memberof InteractiveMap
   */


  getSource(key) {
    let source = this.store.get(key);

    if (!source) {
      key = (0, _utils3.getSourceId)(key);
      source = this.store.get(key);
    }

    return source;
  }
  /**
   * Returns whether a data source exists on the map for the specified key.
   *
   * @param {string} key
   * @returns {boolean}
   * @memberof InteractiveMap
   */


  hasSource(key) {
    key = (0, _utils3.getSourceId)(key);
    return this.store.has(key);
  }
  /**
   * Presents a callout bubble on the map from the specified target. The target can either be an
   * `Coordinate` object or a native marker object for the current mapping strategy.
   *
   * You can provide native options to configure the callout via the `opts` parameter, which is
   * a configuration object as supported by the strategy's mapping library.
   *
   * @param {*} target
   * @param {*} content
   * @param {*} opts
   * @memberof InteractiveMap
   */


  showCallout(target, content, opts) {
    this.strategy.showCallout(target, content, opts);
  }
  /**
   * Enables auto-updating of map data on regular intervals based on the specified number of
   * seconds.
   *
   * @param {number} interval
   * @memberof InteractiveMap
   */


  enableAutoUpdate(seconds) {
    if (!this._refreshInterval && seconds > 0) {
      seconds = Math.max(seconds, 10);

      if (this._refreshInterval) {
        window.clearInterval(this._refreshInterval);
      }

      this._refreshInterval = setInterval(() => {
        this._updateTimeline();
      }, seconds * 1000);
    }
  }
  /**
   * Disables auto-updating of map data.
   *
   * @memberof InteractiveMap
   */


  disableAutoUpdate() {
    if (this._refreshInterval) {
      clearInterval(this._refreshInterval);
    }

    this._refreshInterval = null;
  }
  /**
   * @ignore
   *
   * @memberof InteractiveMap
   */


  _updateTimeline() {
    const tl = this.timeline;
    let restartAnimation = false;

    if (tl.isAnimating() || tl.isLoading()) {
      tl.stop();
      tl.reset();
      restartAnimation = true;
    }

    tl.refresh();
    tl.goToInit(); // if animation was previously active/playing before updating, we need to restart it

    if (restartAnimation) {
      clearTimeout(this._restartAnimationTimeout);
      this._restartAnimationTimeout = setTimeout(() => {
        tl.play();
      }, 300);
    }
  }

  _updateSourceStyle(source, style = {}) {
    if (!source) return;

    if (source instanceof _sources.TileSource) {
      const {
        zIndex,
        opacity
      } = style;

      if ((0, _utils2.isset)(opacity)) {
        source.setOpacity(opacity);
      }

      if ((0, _utils2.isset)(zIndex)) {
        source.setOrder(zIndex);
      }
    }
  }
  /**
   * @ignore
   * Updates point and shape map content sources by loading new data for the current map bounds.
   *
   * @memberof InteractiveMap
   */


  _loadForBounds(force = false, isAnimating = false) {
    const bounds = this.getBounds();
    this.store.each((key, source) => {
      if (source instanceof _sources.VectorSource) {
        const vectorSource = source;

        if (vectorSource.requiresBounds || vectorSource.hasData() === false || force) {
          vectorSource.load({
            bounds,
            from: this.timeline.startDate(),
            to: this.timeline.endDate()
          }, isAnimating).catch(error => {
            console.error(`[Aeris] Failed to load data for VectorSource with key ${source.key}`, error);
          });
        }
      }
    });
  }
  /**
   * @ignore
   * Updates existing map content sources for the specified date and time.
   *
   * @param {(number | Date)} date
   * @memberof InteractiveMap
   */


  _updateSourcesForDate(date) {
    if (!(0, _utils2.isDate)(date)) {
      date = new Date(date);
    }

    this.store.each((key, source) => {
      if (source instanceof _sources.TileSource) {
        source.timestamp = date;
      }
    });
  }
  /**
   * @ignore
   * Called before the map's visible region changes, either from a center or zoom change.
   *
   * @memberof InteractiveMap
   */


  _beforeBoundsChange() {
    if (this.timeline.isAnimating() && this.timeline.isPaused() === false) {
      this._resumeOnBoundsChange = true;
      this.timeline.pause();
    } else {
      this._resumeOnBoundsChange = false;
    }
  }
  /**
   * @ignore
   * Called after the map's visible region changes, either from a center or zoom change. This method will also request an update
   * for all point and shape layers that are active on the map and require new data for the visible region change.
   *
   * @memberof InteractiveMap
   */


  _afterBoundsChange() {
    const shouldReset = (0, _utils2.get)(this._opts, 'timeline.resetOnBoundsChange');
    let reload = this._opts.reloadOnBoundsChange;

    if (this._resumeAnimationTimer) {
      clearTimeout(this._resumeAnimationTimer);
      this._resumeAnimationTimer = null;
    }

    if (reload && !(0, _utils2.isEmpty)(this._stateForData)) {
      const prev = this._stateForData;
      const prevCenter = this.strategy.coordToPoint(prev.center);
      const newCenter = this.strategy.coordToPoint(this.getCenter());

      if ((0, _utils2.isset)(prevCenter) && (0, _utils2.isset)(newCenter)) {
        const delta = Math.max(Math.abs(prevCenter.x - newCenter.x), Math.abs(prevCenter.y - newCenter.y));
        reload = delta >= 50;
      }

      if (this.getZoom() !== prev.zoom) {
        reload = true;
      }
    } // check if we need to reset animations based on whether there are vector sources currently being animated


    let hasVectorSource = false;
    this.store.each((key, source) => {
      if (source instanceof _sources.VectorSource) {
        hasVectorSource = true;
      }
    }); // only reload data for new bounds if change was large enough to prevent reloading
    // with minor adjustments to map panning

    if (reload) {
      if (shouldReset === true) {
        this.timeline.reset();
      }

      if (hasVectorSource) {
        const isAnimating = this.timeline.isPaused() || this.timeline.isAnimating();

        this._loadForBounds(false, isAnimating);

        this._stateForData = {
          center: this.getCenter(),
          bounds: this.getBounds(),
          zoom: this.getZoom()
        };
      }
    }

    if (this._resumeOnBoundsChange && this.timeline.isPaused()) {
      this._resumeAnimationTimer = setTimeout(() => {
        this.timeline.resume();
      }, 500);
    }
  }
  /**
   * @ignore
   * Sets up the event mappings between the internal strategy and Map instance.
   *
   * @memberof InteractiveMap
   */


  _setupEvents() {
    // need to use a timeout to better handle click vs double-click for mapping strategies
    // that trigger click events for dblclick as well
    this.strategy.on('click', e => {
      if (this._dblClickTimer !== null) {
        return;
      }

      this._dblClickTimer = setTimeout(() => {
        e.data.coord = (0, _CoordinateBounds.normalize)(e.data.coord);
        this.trigger("click"
        /* CLICK */
        , e.data);
        this._dblClickTimer = null;
      }, 200);
    });
    this.strategy.on('dblclick', e => {
      clearTimeout(this._dblClickTimer);
      this._dblClickTimer = null;
      this.trigger("dblclick"
      /* DBL_CLICK */
      , e.data);
    });
    this.strategy.on('resize', e => this.trigger("resize"
    /* RESIZE */
    , e.data));
    this.strategy.on('mousedown', e => this.trigger("mousedown"
    /* MOUSE_DOWN */
    , e.data));
    this.strategy.on('mouseup', e => this.trigger("mouseup"
    /* MOUSE_UP */
    , e.data));
    this.strategy.on('mouseover', e => this.trigger("mouseover"
    /* MOUSE_OVER */
    , e.data));
    this.strategy.on('mouseout', e => this.trigger("mouseout"
    /* MOUSE_OUT */
    , e.data));
    this.strategy.on('mousemove', e => this.trigger("mousemove"
    /* MOUSE_MOVE */
    , e.data)); // bounds/zoom events

    this.strategy.on('before:change:bounds', () => {
      this._beforeBoundsChange();
    });
    this.strategy.on('change:bounds', e => {
      this.trigger("change:bounds"
      /* CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });

      this._afterBoundsChange();
    });
    this.strategy.on('change:center', e => this.trigger("change:center"
    /* CHANGE_CENTER */
    , {
      center: this.getCenter()
    }));
    this.strategy.on('change:zoom', e => this.trigger("change:zoom"
    /* CHANGE_ZOOM */
    , {
      zoom: this.getZoom()
    }));
    this.strategy.on('move', e => this.trigger("move"
    /* MOVE */
    ));
    this.strategy.on('move:start', e => {
      this.trigger("move:start"
      /* MOVE_START */
      );
      this.trigger("before:change:bounds"
      /* BEFORE_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('move:end', e => {
      this.trigger("move:end"
      /* MOVE_END */
      );
      this.trigger("after:change:bounds"
      /* AFTER_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('zoom', e => this.trigger("zoom"
    /* ZOOM */
    ));
    this.strategy.on('zoom:start', e => {
      this.trigger("zoom:start"
      /* ZOOM_START */
      );
      this.trigger("before:change:bounds"
      /* BEFORE_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('zoom:end', e => {
      this.trigger("zoom:end"
      /* ZOOM_END */
      );
      this.trigger("after:change:bounds"
      /* AFTER_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('idle', e => this.trigger('idle')); // marker events

    this.strategy.on('marker:click', e => this.trigger("marker:click"
    /* MARKER_CLICK */
    , e.data));
    this.strategy.on('marker:mouseover', e => this.trigger("marker:mouseover"
    /* MARKER_MOUSEOVER */
    , e.data));
    this.strategy.on('marker:mouseout', e => this.trigger("marker:mouseout"
    /* MARKER_MOUSEOUT */
    , e.data));
    this.strategy.on('marker:drag', e => this.trigger("marker:drag"
    /* MARKER_DRAG */
    , e.data));
    this.strategy.on('marker:dragstart', e => this.trigger("marker:dragstart"
    /* MARKER_DRAG_START */
    , e.data));
    this.strategy.on('marker:dragend', e => this.trigger("marker:dragend"
    /* MARKER_DRAG_END */
    , e.data)); // shape events

    this.strategy.on('shape:click', e => this.trigger("shape:click"
    /* SHAPE_CLICK */
    , e.data));
    this.strategy.on('shape:mouseover', e => this.trigger("shape:mouseover"
    /* SHAPE_MOUSEOVER */
    , e.data));
    this.strategy.on('shape:mouseout', e => this.trigger("shape:mouseout"
    /* SHAPE_MOUSEOUT */
    , e.data)); // timeline events

    this.timeline.on('play load:start', () => {
      this.trigger("timeline:play"
      /* TIMELINE_PLAY */
      , {
        timeline: this.timeline
      });
    });
    this.timeline.on('stop', e => {
      clearTimeout(this._restartAnimationTimeout);
      this.trigger("timeline:stop"
      /* TIMELINE_STOP */
      , {
        timeline: this.timeline
      });
    });
    this.timeline.on('advance', e => {
      if (!this.timeline.isAnimating()) {
        this._updateSourcesForDate(e.data.time);
      }

      this.trigger("timeline:change"
      /* TIMELINE_CHANGE */
      , (0, _utils2.extend)({
        timeline: this.timeline
      }, e.data));
    });
    this.timeline.on('start:change end:change', () => {
      this.timeline.reset();
      this.update();
    });
    this.timeline.on('load:start', () => {
      this._indicator.startAnimating();
    });
    this.timeline.on('load:done', () => {
      this._indicator.stopAnimating();
    });
  }
  /**
   * @ignore
   * @private
   * @memberof InteractiveMap
   */


  _checkReady() {
    if (!this._ready) {
      const message = `[Aeris] Must wait for an instance of InteractiveMap to be fully
				initialized before calling methods on it. Observe the \`load\` or \`ready\` events
				that are triggered when an InteractiveMap instance is fully initialized.`;
      throw new Error(message.replace(/\n\s+/g, ' '));
    }
  }
  /**
   * Data Sources
   */

  /**
   * @ignore
   * @param {string} layer
   * @returns {MapRequest}
   * @memberof InteractiveMap
   */


  requestForMap(layer) {
    const request = new _MapRequest.default({
      server: (0, _utils2.get)(this._opts, 'servers.maps'),
      client: {
        id: this.account.id,
        secret: this.account.secret
      }
    }, {
      type: "tile"
      /* TILE */

    });
    request.layers(layer);
    return request;
  }

}

var _default = InteractiveMap;
exports["default"] = _default;

/***/ }),
/* 221 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Animation = _interopRequireDefault(__webpack_require__(222));

var _TileAnimation = _interopRequireDefault(__webpack_require__(223));

var _ImageAnimation = _interopRequireDefault(__webpack_require__(224));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `Timeline` object is a subclass of `Animation` that manages, syncs and controls multiple
 * animations. All animations within are controlled by a single timeline, resulting in animations
 * being synced across time during playback.
 */
class Timeline extends _Animation.default {
  /**
   * Initializes a new timeline instance with the provided configuration.
   *
   * @param {TimelineOptions} [opts=null]
   * @memberof Timeline
   */
  constructor(opts = null) {
    super(opts);
    this._loading = false;
    this._animations = {};
  }
  /**
   * The animation instances being managed by this timeline.
   *
   * @type {{ [key: string]: Animation }}
   * @memberof Timeline
   */


  get animations() {
    return this._animations || {};
  }

  set animations(value) {
    this.stop();
    this._animations = value;

    this._each(anim => {
      anim.timeline = this;
    });
  }
  /**
   * Returns the timeline animation associated with the specified key, if exists.
   *
   * @param {string} key
   * @returns {Animation}
   * @memberof Timeline
   */


  get(key) {
    return this._animations[key];
  }

  opt(key, value) {
    if (value) {
      // some options we need to also update on child animations
      const commonKeys = ['intervals'];
      (0, _utils.set)(this.opts, key, value);

      if (commonKeys.indexOf(key) !== -1) {
        this._each(anim => {
          anim.opt(key, value);
        });
      }

      return this;
    }

    return (0, _utils.get)(this.opts, key);
  }
  /**
   * Adds an animation instance to the timeline for the specified key.
   *
   * @param {string} key
   * @param {Animation} animation
   * @memberof Timeline
   */


  add(key, animation) {
    this.stop();
    animation.timeline = this;
    this._animations[key] = animation;
  }
  /**
   * Removes an animation instance from the timeline.
   *
   * @param {Animation} animation
   * @memberof Timeline
   */


  remove(animation) {
    Object.keys(this._animations).forEach(key => {
      const anim = this._animations[key];

      if (anim === animation) {
        this.removeBy(key);
      }
    });
  }
  /**
   * Removes an animation instance from the timeline for the specified key.
   *
   * @param {string} key
   * @memberof Timeline
   */


  removeBy(key) {
    const anim = this._animations[key];

    if (anim) {
      this.stop();
      anim.timeline = undefined;
    }

    delete this._animations[key];
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * Playback will wait for all internal animation instances to become ready, which means each
   * animation will need to load its required animation data before the timeline can begin
   * playback.
   *
   * @returns
   * @memberof Timeline
   */


  play() {
    let ready = true;
    const waiting = [];
    const loading = []; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    } // can't start timeline animation if internal animations aren't ready
    // (e.g. need to load data or imagery)


    this._each(anim => {
      const showLoading = this.opt('showLoading');
      const showFutureWhileLoading = this.containsPast() === false;

      if (anim instanceof _TileAnimation.default) {
        const tileAnimation = anim;
        tileAnimation.showWhenLoading = showLoading;

        if (anim.isFuture()) {
          tileAnimation.showWhenLoading = showFutureWhileLoading || tileAnimation.alwaysShow();
        }
      } else if (anim instanceof _ImageAnimation.default) {
        const imageAnimation = anim;
        imageAnimation.showWhenLoading = showLoading;

        if (anim.isFuture()) {
          imageAnimation.showWhenLoading = showFutureWhileLoading || imageAnimation.alwaysShow();
        }
      }

      if (anim.isEnabled()) {
        if (!anim.isReady()) {
          ready = false;
          waiting.push(anim);
          loading.push(anim);
          anim.once("ready"
          /* READY */
          , () => {
            waiting.splice(waiting.indexOf(anim), 1);
            loading.splice(loading.indexOf(anim), 1);

            if (waiting.length === 0) {
              setTimeout(() => {
                this.trigger("ready"
                /* READY */
                );
                this.play();
              }, 100);
            }
          });
        } else if (anim.isLoading() || anim.needsData()) {
          loading.push(anim);
          anim.once("load:done"
          /* LOAD_DONE */
          , () => {
            loading.splice(loading.indexOf(anim), 1);

            if (loading.length === 0) {
              this._loading = false;
              this.trigger("load:done"
              /* LOAD_DONE */
              );
            }
          });
        } // calling `play` on an animation starts the data loading process but doesn't
        // actually begin playback since it's tied to an animation timeline


        anim.play();
      }
    });

    if (this._loading === false && loading.length > 0) {
      this._loading = true;
      this.trigger("load:start"
      /* LOAD_START */
      );
    } else if (this._loading && loading.length === 0) {
      this._loading = false;
      this.trigger("load:done"
      /* LOAD_DONE */
      );
    }

    if (ready) {
      // this._loading = false;
      // this.trigger(AnimationEvent.LOAD_DONE);
      this._each(anim => {
        anim.play();
      });

      super.play();
    }
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof Timeline
   */


  stop() {
    this._each(anim => {
      anim.stop();
    });

    super.stop();

    if (this._loading) {
      this.trigger("load:done"
      /* LOAD_DONE */
      );
    }

    this._loading = false;
  }
  /**
   * Pauses the animation at the current position.
   *
   * To resume playback from a paused animation's current position, use `resume()`.
   *
   * @memberof Timeline
   */


  pause() {
    this._each(anim => {
      anim.pause();
    });

    super.pause();
  }
  /**
   * Restarts the animation from the beginning.
   *
   * @memberof Timeline
   */


  restart() {
    this._each(anim => {
      anim.restart();
    });

    super.restart();
  }
  /**
   * Resets the animation to its original state.
   *
   * @memberof Timeline
   */


  reset(updateTime = false) {
    this.stop();
    this._loading = false;

    this._each(anim => {
      anim.reset(updateTime);
    });

    super.reset(updateTime);
  }
  /**
   * Returns whether internal animations are currently loading data required for playback.
   *
   * @returns {boolean}
   * @memberof Timeline
   */


  isLoading() {
    return this._loading;
  }
  /**
   * Advances the animation to the specified time.
   *
   * @param {*} time
   * @returns
   * @memberof Timeline
   */


  goToTime(time) {
    this._each(anim => {
      anim.goToTime(time);
    });

    return super.goToTime(time);
  }
  /**
   * Sets the start date of the animation.
   *
   * @param {(Date | number)} date
   * @returns
   * @memberof Timeline
   */


  setStartDate(date) {
    this._each(anim => {
      anim.setStartDate(date);
    });

    return super.setStartDate(date);
  }
  /**
   * Sets the start date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Timeline
   */


  setStartOffset(offset) {
    this._each(anim => {
      anim.setStartOffset(offset);
    });

    return super.setStartOffset(offset);
  }
  /**
   * Sets the end date of the animation.
   *
   * @param {(Date | number)} date
   * @returns
   * @memberof Timeline
   */


  setEndDate(date) {
    this._each(anim => {
      anim.setEndDate(date);
    });

    return super.setEndDate(date);
  }
  /**
   * Sets the end date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Timeline
   */


  setEndOffset(offset) {
    this._each(anim => {
      anim.setEndOffset(offset);
    });

    return super.setEndOffset(offset);
  }
  /**
   * Updates the animation's start and end times based on the configured offsets and the current
   * time and date.
   *
   * @memberof Timeline
   */


  refresh() {
    super.refresh();

    this._each(anim => {
      anim.now = this.now;
    });
  }
  /**
   * @ignore
   * Performs a function on each internal animation instance.
   *
   * @private
   * @param {(anim: Animation) => void} fn
   * @memberof Timeline
   */


  _each(fn) {
    Object.keys(this.animations).forEach(key => {
      const anim = this._animations[key];
      fn(anim);
    });
  }
  /**
   * @ignore
   * Called when the animation time range has changed.
   *
   * @protected
   * @memberof Timeline
   */


  _onTimingChange() {
    super._onTimingChange();

    this._each(anim => {
      anim.from = this.from;
      anim.to = this.to;
    });
  }

}

var _default = Timeline;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 222 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `Animation` object provides the core functionality necessary for a single time-based animation. The animation
 * is defined by a specified start and end date.
 */
class Animation extends _EventDispatcher.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {*} [opts=null]
   * @memberof Animation
   */
  constructor(opts = null) {
    super();
    this._startOffset = 0;
    this._endOffset = 0;
    this._elapsed = 0;
    this._time = 0;
    this._offset = 0;
    this._manualTimes = false;
    this._delay = 1 / 60;
    this._increment = 0;
    this._timer = null;
    this._restartTimer = null;
    this._paused = false;
    this._currentInterval = 0;
    this._active = false;
    this._enabled = true;
    opts = (0, _utils.extend)({}, {
      key: undefined,
      enabled: true,
      from: 0,
      to: 0,
      duration: 2,
      endDelay: 1,
      intervals: 10,
      autoplay: false,
      future: false,
      alwaysShow: false
    }, opts);
    this._now = new Date();

    const time = this._now.getTime(); // const offsetForDate = (date: Date, relativeTo: Date): number => date.getTime() - relativeTo.getTime();
    // convert strings to numbers as needed


    Object.keys(opts).forEach(key => {
      let val = opts[key]; // convert time string offsets to numerical second offsets

      if ((key === 'from' || key === 'to') && (0, _utils.isString)(val)) {
        const replacements = {
          year: ['y', 'yr'],
          month: ['mn', 'mth'],
          week: ['w', 'wk'],
          day: ['d'],
          hour: ['h', 'hr'],
          minute: ['m', 'min'],
          second: ['s', 'sec']
        };
        val = val.replace(/\s/g, '');
        Object.keys(replacements).forEach(name => {
          const abbr = replacements[name];

          if ((0, _utils.isArray)(abbr)) {
            abbr.forEach(v => {
              const regex = new RegExp(`^([\\d\\.-]+)${v}$`);
              val = val.replace(regex, `\$1${name}`);
            });
          }
        });

        if (/(year|month|week|day|hour|minute|second)/.test(val)) {
          val = (0, _utils.toTimeOffsetHours)(val) * 3600;
        }
      }

      if ((0, _utils.isNumeric)(val)) {
        val = parseFloat(val);
      } // // if from or to are < 3600, then assume an hour value was provided and convert to seconds
      // if ((key === 'from' || key === 'to') && Math.abs(val) < 3600) {
      // 	val *= 3600;
      // }


      opts[key] = val;
    }); // convert from/to date strings to Date objects

    if ((0, _utils.isString)(opts.from)) {
      opts.from = (0, _strings.toDate)(`${opts.from}`);
    }

    if ((0, _utils.isString)(opts.to)) {
      opts.to = (0, _strings.toDate)(`${opts.to}`);
    }

    this.opts = opts;

    if ((0, _utils.isDate)(opts.from)) {
      const date = opts.from;
      this._startOffset = date.getTime() - time;
      this.from = date.getTime();
    } else {
      this._startOffset = parseFloat(`${opts.from}`) * 1000;
      this.from = time + this._startOffset;
    }

    if ((0, _utils.isDate)(opts.to)) {
      const date = opts.to;
      this._endOffset = date.getTime() - time;
      this.to = date.getTime();
    } else {
      this._endOffset = parseFloat(`${opts.to}`) * 1000;
      this.to = time + this._endOffset;
    }

    this._enabled = opts.enabled;
    this.duration = opts.duration || 2;
    this.endDelay = opts.endDelay || 1;
    this.totalIntervals = opts.intervals || 10;
    this._time = this.from;
    this._times = [];

    this._startup();
  }
  /**
   * The key associated with the animation, if any.
   *
   * @readonly
   * @type {string}
   * @memberof Animation
   */


  get key() {
    return this.opts.key;
  }
  /**
   * Parent timeline managing this animation, if any.
   *
   * @type {Timeline}
   * @memberof Animation
   */


  get timeline() {
    return this._timeline;
  }

  set timeline(value) {
    this._timeline = value;

    if (value) {
      this.now = value.now;
      this.from = value.from;
      this.to = value.to; // update config options to match parent timeline

      ['duration', 'endDelay'].forEach(key => {
        this.opt(key, value.opt(key));
      });
      this.goToTime(value.currentTime);
    }
  }
  /**
   * Starting Epoch timestamp in milliseconds.
   *
   * @type {number}
   * @memberof Animation
   */


  get from() {
    return parseFloat(`${this.opts.from}`);
  }

  set from(value) {
    this.stop();
    this.opts.from = value;
    this._startOffset = value - this._now.getTime();

    this._onTimingChange();

    this.trigger("start:change"
    /* START_CHANGE */
    , {
      from: this.startDate(),
      to: this.endDate()
    });
  }
  /**
   * Ending Epoch timestamp in milliseconds.
   *
   * @type {number}
   * @memberof Animation
   */


  get to() {
    return parseFloat(`${this.opts.to}`);
  }

  set to(value) {
    this.stop();
    this.opts.to = value;
    this._endOffset = value - this._now.getTime();

    this._onTimingChange();

    this.trigger("end:change"
    /* END_CHANGE */
    , {
      from: this.startDate(),
      to: this.endDate()
    });
  }
  /**
   * Current time value that represents now. This value is used to determine past/future time
   * periods within the full time range.
   *
   * @type {Date}
   * @memberof Animation
   */


  get now() {
    return this._now;
  }

  set now(value) {
    this._now = value;
  }
  /**
   * Total time in seconds for the animation to complete. The animation speed will be determined
   * by the duration and total intervals, so a longer duration will result in a slower animation
   * speed for the same number of intervals.
   *
   * @type {number}
   * @memberof Animation
   */


  get duration() {
    return this.opts.duration;
  }

  set duration(value) {
    if (value !== this.opts.duration) {
      this.opts.duration = value;

      this._updateTiming();
    }
  }
  /**
   * Delay duration in seconds to hold the last interval of the animation before restarting from
   * the beginning.
   *
   * @type {number}
   * @memberof Animation
   */


  get endDelay() {
    return this.opts.endDelay;
  }

  set endDelay(value) {
    this.opts.endDelay = value;
  }
  /**
   * Returns the total time, in milliseconds, of the animation based on the start and end timestamps.
   *
   * @readonly
   * @type {number}
   * @memberof Animation
   */


  get totalTime() {
    return this.to - this.from;
  }
  /**
   * Returns the current time of the animation's position in milliseconds.
   *
   * @readonly
   * @type {number}
   * @memberof Animation
   */


  get currentTime() {
    return this._time;
  }
  /**
   * Returns the current time offset from the beginning of the animation in milliseconds.
   *
   * @readonly
   * @type {number}
   * @memberof Animation
   */


  get currentOffset() {
    return this._offset;
  }

  get increment() {
    return this._increment;
  }
  /**
   * The animation's current position in the range of `0` to `1.0`, where `0` is the beginning
   * and `1.0` is the end.
   *
   * @type {number}
   * @memberof Animation
   */


  get position() {
    return this._offset / this.totalTime;
  }

  set position(value) {
    this.goToTime(this.from + (this.to - this.from) * value);
  }
  /**
   * Sets or returns the configuration value for the specified key path.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {*}
   * @memberof Animation
   */


  opt(key, value) {
    if (value) {
      (0, _utils.set)(this.opts, key, value);

      if (key === 'intervals') {
        this.reset();
        this.totalIntervals = value;

        this._updateTimes();
      }

      return this;
    }

    return (0, _utils.get)(this.opts, key);
  }
  /**
   * Either plays or stops the animation playback depending on the current state.
   *
   * @memberof Animation
   */


  toggle() {
    if (this.isAnimating() || this.isLoading()) {
      this.stop();
    } else {
      this.play();
    }
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * @returns
   * @memberof Animation
   */


  play() {
    if (this.isAnimating()) {
      return;
    } // if not resuming from paused state, start from beginning of the timeline


    if (!this._paused) {
      this.goToTime(this.from);
    } // if from and to are the same times, just go to that time and don't animate


    if (!this.canAnimate()) {
      return;
    }

    this._paused = false;
    this._active = true;

    this._updateTiming();

    this.trigger("play"
    /* PLAY */
    , {
      from: this.startDate(),
      to: this.endDate()
    });

    this._start();
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @returns
   * @memberof Animation
   */


  stop() {
    this._clearTimers();

    if (!this.isAnimating() && !this.isLoading()) {
      return;
    }

    this._paused = false;
    this._active = false;
    this.trigger("stop"
    /* STOP */
    );
    this.goToInit();
  }
  /**
   * Pauses the animation at the current position.
   *
   * To resume playback from a paused animation's current position, use `resume()`.
   *
   * @memberof Animation
   */


  pause() {
    this._clearTimers();

    this._paused = true;
    this.trigger("pause"
    /* PAUSE */
    );
  }
  /**
   * Resumes playing the animation from the paused position.
   *
   * @memberof Animation
   */


  resume() {
    if (this.isAnimating() && this._paused) {
      this._start();
    }

    this._paused = false;
    this.trigger("resume"
    /* RESUME */
    );
  }
  /**
   * Restarts the animation from the beginning.
   *
   * @memberof Animation
   */


  restart() {
    this._clearTimers();

    this._restartTimer = setTimeout(() => {
      this.goToTime(this.from);

      this._start();
    }, this.endDelay * 1000);
  }
  /**
   * Resets the animation to its original state.
   *
   * @memberof Animation
   */


  reset(updateTime = false) {
    if (this.isAnimating()) {
      this.stop();
    } else if (updateTime) {
      this.goToInit();
    }

    this.trigger("reset"
    /* RESET */
    );
  }
  /**
   * Called when an animation is first created, stopped or reset and determines the time interval
   * to display for the static position so that it's closest to the current time as possible.
   *
   * @memberof Animation
   */


  goToInit() {
    const now = this._now.getTime();

    let time = now;

    if (time > this.to) {
      time = this.to;
    } else if (time < this.from) {
      time = this.from;
    }

    if (this.from >= now) {
      time = this.from;
    } else if (this.to <= now) {
      time = this.to;
    }

    if (time > 0) {
      this.goToTime(time);
    }
  }
  /**
   * Advances the animation to the specified time.
   *
   * @param {(number | Date)} time The time in milliseconds to update the animation's playhead
   * to, which must be within the `to` and `from` time range.
   * @returns {Animatable}
   * @memberof Animation
   */


  goToTime(time) {
    let _time;

    if ((0, _utils.isDate)(time)) {
      _time = time.getTime();
    } else {
      _time = time;
    }

    this._offset = _time - this.from;

    const closest = this._intervalClosestToTime(_time);

    this._currentInterval = closest;
    this._time = _time;

    this._updateForTime(closest);

    this.trigger("advance"
    /* ADVANCE */
    , {
      time: this._time,
      offset: this._offset,
      position: this.position
    });
    return this;
  }
  /**
   * Returns an array of timestamps defining the interval steps that will be rendered during
   * playback.
   *
   * Total intervals returned will be evenly distributed across the animations time range based
   * on the value for `opts.intervals`.
   *
   * @returns {number[]}
   * @memberof Animation
   */


  neededIntervals() {
    return this._times.slice(0);
  }
  /**
   * Returns the current time interval in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  currentInterval() {
    return this._currentInterval;
  }
  /**
   * Returns the current time interval as a `Date`.
   *
   * @returns {Date}
   * @memberof Animation
   */


  currentDate() {
    return new Date(this.currentTime);
  }
  /**
   * Returns the start date of the animation.
   *
   * @returns {Date}
   * @memberof Animation
   */


  startDate() {
    return new Date(this.from);
  }
  /**
   * Sets the start date of the animation.
   *
   * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to
   * update the start time to
   * @returns
   * @memberof Animation
   */


  setStartDate(date) {
    const time = (0, _utils.isDate)(date) ? date.getTime() : date;

    if (time > this.to) {
      console.error(`[Aeris] Animation start date cannot be set to a date after the current
				end date value. You may need to change the end date first.`);
      return this;
    }

    this.from = time; // const now = new Date().getTime();
    // if (this.from > now) {
    // 	this.goToTime(now);
    // } else if (this.currentTime < this.from) {
    // 	this.goToTime(this.from);
    // }

    return this;
  }
  /**
   * Returns the current start offset relative to now, in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  startOffset() {
    return this._startOffset;
  }
  /**
   * Sets the start date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Animation
   */


  setStartOffset(offset) {
    const time = this._now.getTime() + offset;

    if (time > this.to) {
      console.error(`[Aeris] Animation start offset cannot be set to a time offset after the
				current end date value. You may need to change the end date or time offset first.`);
      return this;
    }

    this.from = time;
    return this;
  }
  /**
   * Returns the end date of the animation.
   *
   * @returns {Date}
   * @memberof Animation
   */


  endDate() {
    return new Date(this.to);
  }
  /**
   * Sets the end date of the animation.
   *
   * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to update
   * the end time to
   * @returns
   * @memberof Animation
   */


  setEndDate(date) {
    const time = (0, _utils.isDate)(date) ? date.getTime() : date;

    if (time < this.from) {
      console.error(`[Aeris] Animation end date cannot be set to a date before the current
				start date value. You may need to change the start date first.`);
      return this;
    }

    this.to = time;

    const now = this._now.getTime();

    if (this.to > now) {
      this.goToTime(now);
    } else if (this.currentTime > this.to) {
      this.goToTime(this.to);
    }

    return this;
  }
  /**
   * Returns the current end offset relative to now, in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  endOffset() {
    return this._endOffset;
  }
  /**
   * Sets the end date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Animation
   */


  setEndOffset(offset) {
    const time = this._now.getTime() + offset;

    if (time < this.from) {
      console.error(`[Aeris] Animation end offset cannot be set to a time offset before the
				current start date value. You may need to change the start date or time offset first.`);
      return this;
    }

    this.to = time;
    return this;
  }

  setTimes(times, every = 1) {
    this.reset();

    if ((0, _utils.isset)(times)) {
      this._manualTimes = true;
      this._times = times.map(t => {
        if ((0, _utils.isset)(t.time)) {
          t = t.time;
        }

        if (t instanceof Date) {
          return t.getTime();
        }

        if ((0, _utils.isNumber)(t)) {
          return t;
        }

        return Number.NaN;
      }).filter((t, idx) => (0, _utils.isNumeric)(t) && idx % every === 0);
    } else {
      this._manualTimes = false;

      this._updateTimes();
    }
  }
  /**
   * Updates the animation's start and end times based on the configured offsets and the current
   * time and date.
   *
   * @memberof Animation
   */


  refresh() {
    this._now = new Date();
    this.from = this._now.getTime() + this._startOffset;
    this.to = this._now.getTime() + this._endOffset;
  }
  /**
   * Returns whether or not the animation can animation.
   *
   * This method will return `false` if the animation's `from` and `to` values are the same, or
   * if the animation is disabled.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  canAnimate() {
    return this.to !== this.from && this.isEnabled();
  }
  /**
   * Returns whether the animation should be visible for the specified time.
   *
   * This method will return `false` if the animation is specified as a future animation and the
   * `time` is in the past, or if the animation is not specified as a future animation and the
   * `time` is in the future.
   *
   * @param {number} [time]
   * @returns {boolean}
   * @memberof Animation
   */


  canShow(time) {
    if (this.alwaysShow() === true) {
      return true;
    }

    if (!time) {
      time = this._time;
    }

    const now = this._now.getTime();

    const delta = time - now;

    if (this.isFuture()) {
      if (this.containsPast() === false || this.startsAtNow()) {
        return time >= now;
      }

      return time > now;
    } // if start time is the same as now, then don't show past animations


    if (this.startsAtNow() && this.containsFuture()) {
      return delta < 0;
    }

    return time <= now;
  }
  /**
   * Returns whether the animation should be shown regardless of time.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  alwaysShow() {
    return this.opts.alwaysShow;
  }
  /**
   * Sets whether the animation should be enabled.
   *
   * @param {boolean} enable
   * @memberof Animation
   */


  enabled(enable) {
    this._enabled = enable;
  }
  /**
   * Returns whether the animation is currently enabled. Disabled animations would not animate
   * during playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isEnabled() {
    return this._enabled;
  }
  /**
   * Returns whether the animation should automatically begin playback after being created.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isAutoPlay() {
    return this.opts.autoplay;
  }
  /**
   * Returns whether the animation is ready for playback.
   *
   * Subclasses may override this value to indicate additional data or assets are required to be
   * loaded in order to begin playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isReady() {
    return true;
  }
  /**
   * Returns whether the animation is currently loading data or assets required for playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isLoading() {
    return false;
  }
  /**
   * Returns whether the animation is currently running.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isAnimating() {
    return this._active;
  }
  /**
   * Returns whether the animation is currently paused.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isPaused() {
    return this._paused;
  }
  /**
   * Returns whether the animation has been specified as a future-only animation, meaning it's
   * only valid for time intervals into the future.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isFuture() {
    return this.opts.future === true;
  }
  /**
   * Returns whether the animation's time range extends into the past.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  containsPast() {
    return this.startDate().getTime() < this._now.getTime();
  }
  /**
   * Returns whether the animation's time range extends into the future.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  containsFuture() {
    return this.endDate().getTime() > this._now.getTime();
  }

  startsAtNow() {
    const delta = Math.abs(this.startDate().getTime() - this.now.getTime());
    return delta <= 30000;
  }

  endsAtNow() {
    const delta = Math.abs(this.endDate().getTime() - this.now.getTime());
    return delta <= 30000;
  }

  needsData() {
    return false;
  }
  /**
   * @ignore
   * @protected
   * @memberof Animation
   */


  _startup() {
    this._updateTimes();

    if (this.opts.autoplay) {// this.play();
    } else {
      // determine the time interval to display initially before animation begins
      this.goToInit();
    }
  }
  /**
   * @ignore
   * Begins running the internal animation timer.
   *
   * @private
   * @returns
   * @memberof Animation
   */


  _start() {
    if (this.timeline) return;
    this._active = true;
    this._timer = setInterval(() => {
      const next = this._time + this._increment;

      if (next > this.to) {
        this.restart();
      } else {
        this.goToTime(next);
      }
    }, this._delay * 1000);
  }
  /**
   * @ignore
   * Stops and clears all running timers.
   *
   * @private
   * @memberof Animation
   */


  _clearTimers() {
    if (this._timer) {
      window.clearInterval(this._timer);
    }

    if (this._restartTimer) {
      window.clearTimeout(this._restartTimer);
    }

    this._timer = undefined;
    this._restartTimer = undefined;
  }
  /**
   * @ignore
   * @protected
   * @memberof Animation
   */


  _onTimingChange() {
    this._updateTiming();

    this._updateTimes();

    this._handleTimingChange();

    if (this.currentTime < this.from) {
      this.goToTime(this.from);
    } else if (this.currentTime > this.to) {
      this.goToTime(this.to);
    }
  }
  /**
   * @ignore
   * Calculates the step increment to use on each timer interval update based on the animation
   * duration and delay.
   *
   * @private
   * @returns
   * @memberof Animation
   */


  _updateTiming() {
    if (this.to < this.from) return;
    this._increment = (this.to - this.from) / this.duration * this._delay;
  }

  _updateTimes() {
    if (!this._manualTimes) {
      this._times = this._timesForIntervals();
    }
  }

  _handleTimingChange() {// subclasses should update the animation data for the specified time
  }

  _updateForTime(time) {// subclasses should update the animation data for the specified time
  }
  /**
   * Returns the closest valid animation interval to the specified time.
   *
   * @protected
   * @param {number} time
   * @returns {number}
   * @memberof Animation
   */


  _intervalClosestToTime(time) {
    let closest = this.from;
    let diff = Math.abs(time - closest);

    if (undefined === this._times) {
      this._updateTimes();
    }

    this._times.forEach(t => {
      const tdiff = Math.abs(time - t);

      if (tdiff < diff) {
        diff = tdiff;
        closest = t;
      }
    });

    return Math.round(closest);
  }
  /**
   * Returns an array of step time intervals, in milliseconds, that will be used during playback.
   *
   * @protected
   * @returns {number[]}
   * @memberof Animation
   */


  _timesForIntervals() {
    if (this.from === this.to) return []; // const now = new Date().getTime();
    // if (null !== this._startOffset) {
    // 	this.from = now + this._startOffset;
    // 	this._time = this.from;
    // }
    // if (null !== this._endOffset) {
    // 	this.to = now + this._endOffset;
    // }

    const times = [];

    const append = time => {
      if (this.canShow(time) && times.indexOf(time) === -1) {
        times.push(time);
      }
    }; // calculate time intervals needed


    const total = this.opts.intervals;
    const interval = Math.round((this.to - this.from) / (total - 1)); // hack to shift first interval 1 second after now for future animations to work around an issue where
    // Google Maps won't animate first frame if it's the same as now at the start of the animation

    const shift = this.isFuture() && this.startDate().getTime() === this.now.getTime() ? 60 * 1000 : 0;
    let lastTime = null;

    for (let i = 0; i < total - 1; i += 1) {
      const tshift = i === 0 ? shift : 0;
      const t = this.from + interval * i + tshift;

      if (i === 0 || t !== lastTime) {
        append(Math.round(t));
        lastTime = t;
      }
    }

    if (times.length > 0) append(this.to);
    this.totalIntervals = times.length;
    return times;
  }

}

var _default = Animation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 223 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Animation = _interopRequireDefault(__webpack_require__(222));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `TileAnimation` object is a subclass of `Animation` that is responsible for loading and
 * managing a series of tile layers required for animation playback.
 */
class TileAnimation extends _Animation.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {TileAnimationOptions} [opts=null]
   * @memberof TileAnimation
   */
  constructor(opts = null) {
    opts = (0, _utils.extend)({}, {
      refresh: 0,
      showWhenLoading: true,
      showLoadingIntervals: false,
      bufferIntervals: -1,
      reverseLoadOrder: false,
      times: undefined
    }, opts);
    super(opts);
    this._layersByTime = null;
    this._isReset = false;
    this._loading = false;
    this._hasLoaded = false;
    this._visible = true;

    if ((0, _utils.isset)(this.opts.times)) {
      this.setTimes(this.opts.times);
    }

    this._startup();
  }

  get showWhenLoading() {
    return this.opts.showWhenLoading;
  }

  set showWhenLoading(value) {
    this.opts.showWhenLoading = value;
  }

  get bufferCount() {
    let totalBufferIntervals = this.opts.bufferIntervals;

    if (totalBufferIntervals === -1) {
      return this.totalIntervals;
    } // if animation is future and animation contains future and past, then we need to reduce the buffer intervals
    // for this animation by those required by the associated past animation


    if (this.isFuture() && this.containsPast()) {
      totalBufferIntervals = this.opts.bufferIntervals - (this.opts.intervals - this.totalIntervals);
    } // buffer count should never be greater than the times required for the animation


    return Math.max(0, Math.min(totalBufferIntervals, this.totalIntervals));
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof TileAnimation
   */


  dataByTime() {
    return this._layersByTime || {};
  }
  /**
   * Returns an array of cached raster data items for the animation.
   *
   * @returns {any[]}
   * @memberof TileAnimation
   */


  dataItems() {
    return Object.keys(this.dataByTime()).map(k => this._layersByTime[k]);
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * If images required for playback have not been loaded, then all images will be requested
   * before playback can begin.
   *
   * @returns
   * @memberof TileAnimation
   */


  play() {
    if (this.isAnimating()) return; // // if from and to are the same times, just go to that time and don't animate
    // if (!this.canAnimate()) {
    // 	return;
    // }

    const totalIntervals = this.totalIntervals;
    const needed = this.bufferCount;

    if ((needed > 0 || this.bufferCount === 0) && (!this._hasImages() && totalIntervals > 0 || this._totalImages() < needed)) {
      this._load();

      return;
    }

    this.show();
    super.play();
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof TileAnimation
   */


  stop() {
    super.stop();

    if (this._loading) {
      this.reset();
    }
  }
  /**
   * Resets the animation to its original state.
   *
   * All images that were cached during animation playback will be removed and new images will
   * have to be requested again when playback begins.
   *
   * @memberof TileAnimation
   */


  reset(updateTime = false) {
    super.reset(updateTime);
    this.hide();

    if (this._reloadTimer) {
      window.clearTimeout(this._reloadTimer);
    }

    this._isReset = true;
    this._loading = false;
    this._hasLoaded = false;
    this._layersByTime = null;
    this._currentLayer = null; // trigger removal of all layers associated with the animation

    if (this._layersByTime) {
      Object.keys(this._layersByTime).forEach(key => {
        const time = parseInt(key, 10);

        this._layersByTime[time].remove();

        delete this._layersByTime[time];
      });
    }
  }
  /**
   * Returns whether the animation is ready for playback.
   *
   * A tile animation is only ready once all images have been loaded.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  isReady() {
    const needed = this.bufferCount;

    const loaded = this._totalImages();

    return this.canBeginPlayback() && (this._hasImages() && loaded >= needed || needed === 0);
  }

  needsData() {
    return this._totalImages() < this.totalIntervals;
  }

  canBeginPlayback() {
    if (this.bufferCount >= 0) {
      return this._totalImages() >= this.bufferCount;
    }

    return !this.isLoading();
  }
  /**
   * Returns whether the animation can animate based on whether or not animation data has
   * loaded or is already cached.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  canAnimate() {
    let can = super.canAnimate();

    if (can && this._hasLoaded && this.needsData()) {
      can = false; // } else if (can && ((!this.isFuture() && !this.containsPast())) || (this.isFuture() && !this.containsFuture())) {
      // 	can = false;
    }

    return can;
  }
  /**
   * Returns whether the animation is currently loading data.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  isLoading() {
    return this._loading;
  }
  /**
   * Shows the animation content.
   *
   * @memberof TileAnimation
   */


  show() {
    this._visible = true;

    if (this._currentLayer) {
      this._currentLayer.show();
    }
  }
  /**
   * Hides the animation content.
   *
   * @memberof TileAnimation
   */


  hide() {
    this._visible = false;

    if (this._currentLayer) {
      this._currentLayer.hide();
    }
  }
  /**
   * Returns whether the animation element is currently visible.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  isVisible() {
    if (this._currentLayer) {
      return this._currentLayer.isVisible();
    }

    return true;
  }
  /**
   * Updates the opacity for all raster-related data associated with the animation.
   *
   * @param {number} value
   * @memberof ImageAnimation
   */


  setOpacity(value) {
    this.dataItems().forEach(item => {
      if ((0, _utils.has)(item, 'setOpacity')) {
        item.setOpacity(value, true);
      }
    });
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate tile layer for the specifyed time.
   *
   * @protected
   * @param {number} time
   * @memberof TileAnimation
   */


  _updateForTime(time) {
    if (this.canShow(this.currentTime)) {
      this.show();
    } else {
      this.hide();
    } // if (this.isAnimating() === false) return;


    if (this._visible === false) return;

    const layer = this._frameClosestToTime(time);

    if (layer && layer !== this._currentLayer) {
      layer.show();

      if (this._currentLayer) {
        this._currentLayer.hide();
      }

      this._currentLayer = layer;
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // } else {
    // 	this.hide();
    // }

  }
  /**
   * @ignore
   * Returns the tile layer closest to the specified time.
   *
   * @private
   * @param {number} time
   * @returns {ITileLayer}
   * @memberof TileAnimation
   */


  _frameClosestToTime(time) {
    if (Object.keys(this.dataByTime()).length === 0) {
      return null;
    }

    const times = Object.keys(this._layersByTime).sort().reverse().map(o => parseInt(o, 10)); // eslint-disable-line max-len

    let image = null;
    let closest = times[times.length - 1];
    let diff = Math.abs(time - closest);
    times.forEach(t => {
      const checkDiff = Math.abs(time - t);

      if (checkDiff < diff) {
        diff = checkDiff;
        closest = t;
      }
    });

    if (closest !== this._lastImageTime && this._layersByTime[closest]) {
      image = this._layersByTime[closest];
      closest = Math.round(closest);
      this._lastImageTime = closest;
      this.trigger("advance:image"
      /* ADVANCE_IMAGE */
      , {
        time: closest,
        layer: image
      });
    }

    return image;
  }
  /**
   * @ignore
   * Returns whether animation layers are available.
   *
   * @private
   * @returns {boolean}
   * @memberof TileAnimation
   */


  _hasImages() {
    return this._totalImages() > 0;
  }
  /**
   * @ignore
   * Returns the total number of animation layers.
   *
   * @private
   * @returns {number}
   * @memberof TileAnimation
   */


  _totalImages() {
    return Object.keys(this.dataByTime()).length;
  }
  /**
   * @ignore
   * Loads all tile layers based on the required time intervals.
   *
   * @private
   * @returns
   * @memberof TileAnimation
   */


  _load() {
    if (this._loading) {
      return;
    }

    let times = this.neededIntervals();

    if (!times || times.length === 0) {
      this._hasLoaded = true;
      this.trigger("load:done"
      /* LOAD_DONE */
      );
      this.trigger("ready"
      /* READY */
      );
      return;
    }

    this._isReset = false;
    this._loading = true;
    const bufferCount = this.bufferCount;

    if (this._layersByTime) {
      // reduce times by interval images we may already have cached
      Object.keys(this._layersByTime).forEach(key => {
        const time = parseInt(key, 10);
        const index = times.indexOf(time);

        if (index !== -1) {
          times.splice(index, 1);
        }
      });
    }

    const onLoadComplete = () => {
      this._loading = false;
      this._hasLoaded = true;
      this.trigger("load:done"
      /* LOAD_DONE */
      );

      if (bufferCount === -1 || bufferCount >= times.length) {
        this.trigger("ready"
        /* READY */
        );
      }

      if (!this.timeline) {
        this.play();
      }
    };

    if (times.length === 0) {
      onLoadComplete();
      return;
    } // if bufferCount is less than total times, then reverse times array so that
    // the most recent intervals are loaded and rendered first


    if (bufferCount >= 0 && this.opts.reverseLoadOrder === true) {
      times = times.reverse();
    }

    this.trigger("load:start"
    /* LOAD_START */
    , {
      times
    });

    const loadTimes = timesToLoad => {
      const wait = this.opts.showLoadingIntervals === false && bufferCount !== 0;
      timesToLoad.forEach(time => {
        this._loadInterval(time, true, wait, () => {
          if (this._totalImages() === times.length) {
            onLoadComplete();
          }
        });
      });
    };

    let loadingInterval = 0;

    const loadNextInterval = () => {
      const wait = this.opts.showLoadingIntervals === false || bufferCount !== 0 && loadingInterval <= this._totalImages();

      this._loadInterval(times[loadingInterval], true, wait, () => {
        loadingInterval += 1; // don't continue loading remaining intervals if animation was reset during load process

        if (!this._isReset) {
          if (loadingInterval >= times.length) {
            onLoadComplete(); // start refresh timer if needed

            if (this.opts.refresh > 0) {
              if (this._reloadTimer) {
                window.clearTimeout(this._reloadTimer);
              }

              this._reloadTimer = setTimeout(() => {
                this.reset();

                this._load();
              }, this.opts.refresh * 1000);
            }
          } else if (bufferCount > 0 && this._totalImages() === bufferCount) {
            this.trigger("ready"
            /* READY */
            );

            if (this.opts.showLoadingIntervals) {
              loadTimes(times.slice(loadingInterval));
            } else {
              loadNextInterval();
            }
          } else {
            loadNextInterval();
          }
        }
      });
    };

    if (bufferCount === 0) {
      this.trigger("ready"
      /* READY */
      );
      loadTimes(times);
    } else {
      loadNextInterval();
    }
  }
  /**
   * @ignore
   * Loads a single tile layer for the specified time.
   *
   * @private
   * @param {number} time
   * @param {boolean} cache
   * @param {() => void} callback
   * @returns
   * @memberof TileAnimation
   */


  _loadInterval(time, cache, wait, callback = null) {
    time = Math.round(time);

    if (!this._layersByTime) {
      this._layersByTime = {};
    } else if (this._layersByTime[time]) {
      // skip the request if we already have a cached image for this interval
      if (callback) {
        callback();
      }

      return;
    }

    const date = new Date(time);

    if (this.provider) {
      this.provider.animationLayerForDate(this, date, wait).then(layer => {
        // if animation was reset while loading the interval, then immediately remove it
        if (this._isReset) {
          layer.remove();
          return;
        }

        if (this.showWhenLoading && this._totalImages() < this.bufferCount) {
          if (this._currentLayer) {
            this._currentLayer.hide();
          }

          layer.show();
          this._currentLayer = layer;
        }

        this._layersByTime[time] = layer;
        this.trigger("load:image"
        /* LOAD_IMAGE */
        , {
          date: new Date(time),
          layer
        });
        this.trigger("load:progress"
        /* LOAD_PROGRESS */
        , {
          time,
          loaded: Object.keys(this._layersByTime).length,
          total: this.totalIntervals
        });

        if (callback) {
          callback();
        }
      }).catch(e => {
        console.error('Failed to load tile animation interval', e); // eslint-disable-line no-console
      });
    }
  }

}

var _default = TileAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 224 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Animation = _interopRequireDefault(__webpack_require__(222));

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `ImageAnimation` object is a subclass of `Animation` that is responsible for managing a
 * series of images required for animation playback.
 */
class ImageAnimation extends _Animation.default {
  /**
   * Initializes a new animation instance with the provided DOM target and configuration.
   *
   * @param {HTMLElement} target
   * @param {ImageAnimationOptions} [opts=null]
   * @memberof ImageAnimation
   */
  constructor(target, opts = undefined) {
    opts = (0, _utils.extend)({}, {
      refresh: 0,
      showWhenStopped: true,
      showWhenLoading: true
    }, opts);
    super(opts);
    this.element = target ? (0, _DOM.default)(target) : undefined;
    this._images = {};
    this._targets = {};
    this._idPrefix = 'awxb-map-layer-';
    this._isReset = false;
    this._loading = false;
    this._visible = true;
    this._hasLoaded = false;

    if (!(0, _utils.isEmpty)(opts.key)) {
      this._idPrefix += `${opts.key}-`;
    } // setup containers


    if (this.element) {
      this.element.addClass('amp-map');
    }

    this._startup();
  }

  get showWhenLoading() {
    return this.opts.showWhenLoading;
  }

  set showWhenLoading(value) {
    this.opts.showWhenLoading = value;
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof ImageAnimation
   */


  dataByTime() {
    return this._images;
  }
  /**
   * Returns an array of cached raster data items for the animation.
   *
   * @returns {any[]}
   * @memberof TileAnimation
   */


  dataItems() {
    return Object.keys(this.dataByTime()).map(k => this._images[k]);
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * If images required for playback have not been loaded, then all images will be requested
   * before playback can begin.
   *
   * @returns
   * @memberof ImageAnimation
   */


  play() {
    if (this.isAnimating()) return; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    }

    if (!this._hasImages() || this._totalImages() < this.totalIntervals) {
      this._load();

      return;
    } // this.show();


    super.play();
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof ImageAnimation
   */


  stop() {
    super.stop();

    if (this._loading) {
      this.reset();
    }
  }
  /**
   * Resets the animation to its original state.
   *
   * @memberof ImageAnimation
   */


  reset(updateTime = false) {
    this._isReset = true;
    this._loading = false;
    this._hasLoaded = false;

    if (this._reloadTimer) {
      window.clearTimeout(this._reloadTimer);
    }

    if (this._loaders) {
      Object.keys(this._loaders).forEach(key => {
        this._loaders[key].onload = undefined;
      });
    }

    this._images = {};
    this._loaders = {};

    if (this.element) {
      this.element.empty();
    }

    super.reset(updateTime);
  } // goToTime(time: any) {
  // 	super.goToTime(time);
  // 	// // show or hide animation container depending on current interval and if it's future or not
  // 	// if (!this.canShow(time)) {
  // 	// 	this.hide();
  // 	// } else if (this._hasImages()) {
  // 	// 	this.show();
  // 	// }
  // 	return this;
  // }

  /**
   * Returns whether the animation is ready for playback.
   *
   * An image animation is only ready once all images have been loaded.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  isReady() {
    const needed = this.totalIntervals;

    const loaded = this._totalImages();

    return !this.isLoading() && (this._hasImages() && loaded === needed || needed === 0);
  }
  /**
   * Returns whether the animation can animate based on whether or not animation data has
   * loaded or is already cached.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  canAnimate() {
    let can = super.canAnimate();

    if (can && this._hasLoaded && !this._hasImages()) {
      can = false;
    } else if (can && !this.isFuture() && !this.containsPast() || this.isFuture() && !this.containsFuture()) {
      can = false;
    }

    return can;
  }
  /**
   * Returns whether the animation is currently loading data.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  isLoading() {
    return this._loading;
  }
  /**
   * Shows the animation content.
   *
   * @memberof ImageAnimation
   */


  show() {
    this._visible = true;

    if (this.element) {
      this.element.show();
    } else if (this._currentImage) {
      (0, _DOM.default)(this._currentImage).show();
    }

    this.trigger('show');
  }
  /**
   * Hides the animation content.
   *
   * @memberof ImageAnimation
   */


  hide() {
    this._visible = false;

    if (this.element) {
      this.element.hide();
    } else if (this._currentImage) {
      (0, _DOM.default)(this._currentImage).hide();
    }

    this.trigger('hide');
  }
  /**
   * Returns whether the animation container is currently visible.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  isVisible() {
    if (this.element) {
      let element = this.element;

      if ((0, _utils.isDOM)(this.element) && this.element.length > 0) {
        element = this.element[0];
      }

      return element.style.display !== 'none';
    }

    if (this._currentImage) {
      return this._currentImage.style.display !== 'none';
    }

    return true;
  }
  /**
   * Updates the opacity for all raster-related data associated with the animation.
   *
   * @param {number} value
   * @memberof ImageAnimation
   */


  setOpacity(value) {
    this.dataItems().forEach(item => {
      if ((0, _utils.has)(item, 'setOpacity')) {
        item.setOpacity(value);
      }
    });
  }

  _target(key) {
    return this._targets[key];
  }
  /**
   * @ignore
   * Sets the visibility of currently active image.
   *
   * @private
   * @param {boolean} visible
   * @memberof ImageAnimation
   */


  _setImageVisible(visible) {
    if (visible) {
      (0, _DOM.default)(this._currentImage).show();
    } else {
      (0, _DOM.default)(this._currentImage).hide();
    }
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate image for the specifyed time.
   *
   * @protected
   * @param {number} time
   * @memberof ImageAnimation
   */


  _updateForTime(time) {
    if (this.canShow(this.currentTime)) {
      this.show();
    } else {
      this.hide();
    } // if (this.isAnimating() === false) return;


    if (this._visible === false) return;

    const image = this._imageClosestToTime(time);

    if (image) {
      if (image !== this._currentImage) {
        (0, _DOM.default)(image).show();

        this._setImageVisible(false);

        this._currentImage = image;
      }
    } else if (!this.isAnimating() && this.opt('showWhenStopped') === true) {
      time = this._intervalClosestToTime(time);

      if (this.canShow(time)) {
        this._isReset = false;

        this._loadInterval(time, true, null);
      }
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // } else {
    // 	this.hide();
    // }

  }
  /**
   * @ignore
   * Returns the image closest to the specified time.
   *
   * @private
   * @param {number} time
   * @returns {*}
   * @memberof ImageAnimation
   */


  _imageClosestToTime(time) {
    let image = null;
    let closest = this.from;
    let diff = Math.abs(time - closest);

    if (!this._images) {
      return null;
    }

    Object.keys(this._images).forEach(imageTime => {
      const imageDiff = Math.abs(time - +imageTime);

      if (imageDiff < diff) {
        diff = imageDiff;
        closest = +imageTime;
      }
    });

    if (closest !== this._lastImageTime && this._images[closest]) {
      image = this._images[closest];
      closest = Math.round(closest);
      this._lastImageTime = closest;
      this.trigger("advance:image"
      /* ADVANCE_IMAGE */
      , {
        time: closest,
        img: image
      });
    }

    return image;
  }
  /**
   * @ignore
   * Returns whether animation images are available.
   *
   * @private
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  _hasImages() {
    return this._totalImages() > 0;
  }
  /**
   * @ignore
   * Returns the total number of animation images.
   *
   * @private
   * @returns {number}
   * @memberof ImageAnimation
   */


  _totalImages() {
    if ((0, _utils.isUndefined)(this._images)) return 0;
    return Object.keys(this._images).filter(time => (0, _utils.isset)(this._images[time])).length;
  }
  /**
   * @ignore
   * Loads all images based on the required time intervals.
   *
   * @private
   * @returns
   * @memberof ImageAnimation
   */


  _load() {
    this._isReset = false;
    this._loading = true;
    const times = this.neededIntervals() || []; // reduce times by interval images we may already have cached

    Object.keys(this._images).forEach(key => {
      const time = parseInt(key, 10);
      const index = times.indexOf(time);

      if (index !== -1) {
        times.splice(index, 1);
      }
    });

    const onLoadComplete = () => {
      this._loading = false;
      this._hasLoaded = true;
      this.trigger("load:done"
      /* LOAD_DONE */
      );
      this.trigger("ready"
      /* READY */
      );

      if (!this.timeline) {
        this.play();
      }
    };

    if (times.length === 0) {
      onLoadComplete();
      return;
    } // set size of animation container


    if (this.element && this.opts.autosize === true && this.provider) {
      const size = this.provider.animationSizeForImage(this);
      this.element.css({
        width: `${size.width}px`,
        height: `${size.height}px`
      });
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // }


    this.trigger("load:start"
    /* LOAD_START */
    , {
      times
    });
    let loadingInterval = 0;

    const loadNextInterval = () => {
      this._loadInterval(times[loadingInterval], true, () => {
        loadingInterval += 1; // don't continue loading remaining intervals if animation was reset during load process

        if (!this._isReset) {
          if (loadingInterval >= times.length) {
            onLoadComplete(); // start refresh timer if needed

            if (this.opts.refresh > 0) {
              if (this._reloadTimer) {
                window.clearTimeout(this._reloadTimer);
              }

              this._reloadTimer = setTimeout(() => {
                this.reset();

                this._load();
              }, this.opts.refresh * 1000);
            }
          } else {
            loadNextInterval();
          }
        }
      });
    };

    loadNextInterval();
  }
  /**
   * @ignore
   * Loads a single image for the specified time.
   *
   * @private
   * @param {number} time
   * @param {boolean} cache
   * @param {() => void} callback
   * @returns
   * @memberof ImageAnimation
   */


  _loadInterval(time, cache, callback) {
    time = Math.round(time); // don't reload interval if it already exists in the DOM

    const el = document.getElementById(`${this._idPrefix}${time}`);

    if (el) {
      const $el = (0, _DOM.default)(el);
      $el.show();

      this._setImageVisible(false);

      this._currentImage = $el;

      this._setImageVisible(true);

      if (callback) {
        callback();
      }

      return;
    }

    if (!this._images) {
      this._images = {};
    }

    if (!this._loaders) {
      this._loaders = {};
    } // skip the request if we already have a cached image for this interval


    if (this._images[time]) {
      if (callback) {
        callback();
      }

      return;
    } // don't load if we already have a loader running for this interval


    if (this._loaders[time]) {
      return;
    }

    const date = new Date(time);
    let url;

    if (this.provider) {
      url = this.provider.animationUrlForDate(this, date);
    }

    const onFailure = failedTime => {
      this._images[failedTime] = new Image();
      this.trigger("load:error"
      /* LOAD_ERROR */
      , {
        date,
        interval: Object.keys(this._images).length - 1
      });

      if (callback) {
        callback();
      }
    };

    if (!url) {
      onFailure(time);
      return;
    }

    const image = new Image();
    this._loaders[time] = image;

    image.onload = () => {
      if (this._isReset) return;

      if (this._loaders[time]) {
        delete this._loaders[time];
      }

      const id = `${this._idPrefix}${time}`;
      let size = {
        width: image.width,
        height: image.height
      };

      if (this.provider) {
        size = this.provider.animationSizeForImage(this);
      }

      const img = `<img id="${id}" src="${image.src}" width="${size.width}" height="${size.height}" style="position:absolute;">`;

      if (this.element) {
        this.element.append(img);
      }

      if (cache) {
        this._images[time] = this._hasDOMTarget() ? (0, _DOM.default)(`#${id}`) : image;
      }

      this._setImageVisible(false);

      this._currentImage = this._hasDOMTarget() ? (0, _DOM.default)(`#${id}`) : image;

      if (callback) {
        callback();
      }

      const loadedCount = Object.keys(this._images).length;
      this.trigger("load:image"
      /* LOAD_IMAGE */
      , {
        date: new Date(time),
        src: image.src,
        img: image
      });
      this.trigger("load:progress"
      /* LOAD_PROGRESS */
      , {
        time,
        interval: loadedCount - 1,
        loaded: loadedCount,
        total: this.totalIntervals
      }); // if (callback) {
      // 	callback();
      // }
    };

    image.onerror = () => {
      onFailure(time);
    };

    image.src = url;
  }
  /**
   * @ignore
   * Returns whether a DOM target for the animation has been defined.
   *
   * @private
   * @returns
   * @memberof ImageAnimation
   */


  _hasDOMTarget() {
    return this.element && this.element.length > 0;
  }

}

var _default = ImageAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 225 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AERIS_ATTRIBUTION = void 0;
const AERIS_ATTRIBUTION = 'Weather data &copy; <a href="https://www.aerisweather.com/" target="_blank">AerisWeather</a>';
exports.AERIS_ATTRIBUTION = AERIS_ATTRIBUTION;

/***/ }),
/* 226 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "LeafletMapStrategy", ({
  enumerable: true,
  get: function () {
    return _LeafletMapStrategy.default;
  }
}));
Object.defineProperty(exports, "MapboxMapStrategy", ({
  enumerable: true,
  get: function () {
    return _MapboxMapStrategy.default;
  }
}));
Object.defineProperty(exports, "OpenLayersMapStrategy", ({
  enumerable: true,
  get: function () {
    return _OpenLayersMapStrategy.default;
  }
}));
Object.defineProperty(exports, "GoogleMapStrategy", ({
  enumerable: true,
  get: function () {
    return _GoogleMapStrategy.default;
  }
}));

var _LeafletMapStrategy = _interopRequireDefault(__webpack_require__(227));

var _MapboxMapStrategy = _interopRequireDefault(__webpack_require__(255));

var _OpenLayersMapStrategy = _interopRequireDefault(__webpack_require__(265));

var _GoogleMapStrategy = _interopRequireDefault(__webpack_require__(276));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 227 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapStrategy = _interopRequireDefault(__webpack_require__(228));

var _LeafletOverlayFactory = _interopRequireDefault(__webpack_require__(242));

var Leaflet = _interopRequireWildcard(__webpack_require__(243));

var _utils = __webpack_require__(254);

var _utils2 = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// / <reference path="../../../../../node_modules/@types/leaflet/index.d.ts" />

/**
 * A map strategy for working with the third-party Leaflet mapping library.
 *
 * @export
 * @class LeafletMapStrategy
 * @extends {EventDispatcher}
 * @implements {MapStrategy}
 */
class LeafletMapStrategy extends _MapStrategy.default {
  constructor(target, opts) {
    super(target, (0, _utils2.extend)({
      style: null,
      map: {
        worldCopyJump: true
      }
    }, opts));
    this._clickedMapLayer = false;
  }

  get strategy() {
    return 'leaflet';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getContainer());
  }

  loadDependencies() {
    return new Promise((resolve, reject) => {
      if (typeof L === 'undefined' || typeof L.map === 'undefined') {
        const version = '1.7.0';
        Promise.all([(0, _utils2.loadStyles)(`https://unpkg.com/leaflet@${version}/dist/leaflet.css`), (0, _utils2.loadScript)(`https://unpkg.com/leaflet@${version}/dist/leaflet.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _LeafletOverlayFactory.default();
    this._eventMapping = {
      load: 'load',
      unload: 'unload',
      resize: 'resize',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      move: 'move',
      movestart: 'move:start',
      moveend: 'move:end',
      popupopen: 'popupopen',
      popupclose: 'popupclose'
    }; // set view properties from native map options if defined

    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if (center && (0, _utils2.isset)(center.lat) && (0, _utils2.isset)(center.lng)) {
        (0, _utils2.set)(this.opts, 'center', {
          lat: center.lat,
          lon: center.lng
        });
      }

      if (zoom) {
        (0, _utils2.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of L.Map
    // if L.Map instance is provided then don't create a new map instance


    if ((0, _utils.isLeaflet)(target)) {
      this._setInitialView = false;
      this._map = target;
    } else {
      if ((0, _utils2.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils2.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils2.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      this._map = L.map(target, (0, _utils2.extend)({
        zoomControl: false
      }, this.opts.map));
      const removeZoomControl = (0, _utils2.get)(this.opts, 'map.zoomControl') === false;

      if (!removeZoomControl) {
        L.control.zoom({
          position: 'bottomleft'
        }).addTo(this._map);
      }

      if (!(0, _utils2.isset)(this.opts.center)) {
        (0, _utils2.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils2.isset)(this.opts.zoom)) {
        (0, _utils2.set)(this.opts, 'zoom', 7);
      }

      this.map.createPane('base');
      this.map.getPane('base').style.zIndex = `199`;
      const baseUrl = (0, _utils2.get)(this.opts, 'style');

      if (!(0, _utils2.isEmpty)(baseUrl)) {
        this._baseLayer = L.tileLayer(baseUrl, {
          pane: 'base'
        });
      } else {
        this._baseLayer = L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
          pane: 'base'
        });
      }

      this._baseLayer.addTo(this.map);
    } // create 'admin' pane for AMP overlays


    this.map.createPane('admin');
    this.map.getPane('admin').style.zIndex = `210`;
    setTimeout(() => {
      this.trigger('map:ready');
    }, 250);
  }
  /**
   * Updates the base layer using tiles from the provided URL.
   *
   * @param {string} url
   * @memberof LeafletMapStrategy
   */


  setBaseStyle(url) {
    if ((0, _utils2.isEmpty)(url)) return;

    if (this._baseLayer) {
      this._baseLayer.remove();
    }

    this._baseLayer = L.tileLayer(url, {
      pane: 'base'
    });

    this._baseLayer.addTo(this.map);
  }

  setBaseUrl(url) {
    this.setBaseStyle(url);
  }

  setView(center, zoom) {
    if (!this._map) return;
    this.map.setView({
      lat: center.lat,
      lng: center.lon
    }, zoom);
  }

  getCenter() {
    if (!this._map) return null;

    const coord = this._map.getCenter();

    return {
      lat: coord.lat,
      lon: coord.lng
    };
  }

  setCenter(coord) {
    if (!this._map) return;

    this._map.setView({
      lat: coord.lat,
      lng: coord.lon
    }, this.getZoom());
  }

  getZoom() {
    if (!this._map) return 0;
    return this._map.getZoom();
  }

  setZoom(zoom) {
    if (!this._map) return;

    this._map.setZoom(zoom);
  }

  getBounds() {
    if (!this._map) return null;
    const b = this.map.getBounds();
    return {
      north: b.getNorth(),
      west: b.getWest(),
      south: b.getSouth(),
      east: b.getEast()
    };
  }

  setBounds(bounds) {
    if (!this._map) return;
    const sw = new L.LatLng(bounds.south, bounds.west);
    const ne = new L.LatLng(bounds.north, bounds.east);
    this.map.fitBounds(new L.LatLngBounds(sw, ne));
  }

  fitBounds(bounds, padding = [10, 10]) {
    if (!this._map) return;
    const sw = new L.LatLng(bounds.south, bounds.west);
    const ne = new L.LatLng(bounds.north, bounds.east);
    const b = new L.LatLngBounds(sw, ne);

    if (!b.isValid()) {
      console.warn(`[Aeris] Cannot fit bounds, invalid bounds - nw: ${bounds.north}, ${bounds.west}; se: ${bounds.south}, ${bounds.east}`);
      return;
    }

    const opts = {};

    if (padding.length === 2) {
      opts.padding = L.point(padding[0], padding[1]);
    } else if (padding.length === 4) {
      opts.paddingTopLeft = L.point(padding[3], padding[0]);
      opts.paddingBottomRight = L.point(padding[1], padding[2]);
    }

    this.map.fitBounds(b, opts);
  }
  /** Sources */


  isTile(source) {
    return source instanceof Leaflet.TileSource;
  }

  isMarker(el) {
    if (el === null || el === void 0 ? void 0 : el.renderable) {
      return el.renderable instanceof L.Marker;
    }

    return el instanceof L.Marker;
  }

  isPolygon(el) {
    if ((el === null || el === void 0 ? void 0 : el.renderable) && el.renderable instanceof Leaflet.Polygon) {
      return true;
    }

    return el instanceof Leaflet.Polygon;
  }

  isPolyline(el) {
    if ((el === null || el === void 0 ? void 0 : el.renderable) && el.renderable instanceof Leaflet.Polyline) {
      return true;
    }

    return el instanceof Leaflet.Polyline;
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof L.Layer || overlay instanceof L.TileLayer) {
      overlay.addTo(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof L.Layer || overlay instanceof L.TileLayer) {
      overlay.remove();
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Leaflet.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof L.Marker) {
      marker.addTo(this.map);
    }

    super.addMarker(marker, data); // console.error(`Cannot add marker ${marker}, invalid map object`, marker);
  }

  removeMarker(marker) {
    if (marker instanceof Leaflet.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof L.Marker) {
      marker.remove();
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!options) return;

    if (marker instanceof Leaflet.Marker) {
      marker.update(options);
    }
  }

  bindCalloutToMarker(marker, content) {//
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Leaflet.Polyline || shape instanceof Leaflet.Polygon) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Leaflet.Polyline || shape instanceof Leaflet.Polygon) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    this.addShape(shape);
  }

  hideShape(shape) {
    this.removeShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    if (!coord) return null;
    const p = this.map.latLngToContainerPoint({
      lat: coord.lat,
      lng: coord.lon
    });
    return {
      x: p.x,
      y: p.y
    };
  }

  pointToCoord(point) {
    if (!point) return null;
    const c = this.map.containerPointToLatLng([point.x, point.y]);
    return {
      lat: c.lat,
      lon: c.lng
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    if ((0, _utils.isCoordObject)(target)) {
      this.map.openPopup(content, new L.LatLng(target.lat, target.lon), opts);
    } else if (this.isMarker(target)) {
      target.unbindPopup().bindPopup(content, opts).openPopup();
    }
  }

  _setupEvents() {
    super._setupEvents();

    this.map.on('movestart', e => {
      ['before:change:bounds', 'before:change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('moveend', e => {
      ['after:change:bounds', 'after:change:center', 'change:bounds', 'change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomstart', e => {
      ['before:change:zoom'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomend', e => {
      ['after:change:zoom', 'change:zoom'].forEach(name => this.trigger(name));
    });
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.latlng.lat,
            lon: event.latlng.lng
          },
          point: {
            x: event.containerPoint.x,
            y: event.containerPoint.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = LeafletMapStrategy;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 228 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _sources = __webpack_require__(229);

var _utils = __webpack_require__(17);

var _MapElement = _interopRequireDefault(__webpack_require__(232));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Dependencies = {};
/**
 * An abstract map strategy class that provides the core functionality required for a specific
 * mapping strategy. This class should be subclassed per each strategy instead of being
 * instantiated directly.
 *
 * @export
 * @class MapStrategy
 * @extends {EventDispatcher}
 */

class MapStrategy extends _EventDispatcher.default {
  constructor(target, opts) {
    super();
    this._setInitialView = true;
    this._ready = false;
    opts = (0, _utils.extend)({
      zoom: 7
    }, opts);
    this._opts = opts;
    this._sources = {};
    this._sourceOrder = []; // Dynamically inject mapping library dependencies before initializing map.
    //
    // If we have multiple instanaces of this strategy on the same page, then we want to make sure
    // we're only loading the dependencies once, otherwise we can get some weird behavior and
    // errors (like Leaflet, etc) if we load the same library more than once.

    const key = this.strategy;

    if (!Dependencies[key]) {
      Dependencies[key] = {
        loading: false,
        callbacks: []
      };
    }

    if (Dependencies[key].loading) {
      Dependencies[key].callbacks.push(() => {
        this.init(target);
      });
    } else {
      Dependencies[key].loading = true;
      this.loadDependencies().then(() => {
        Dependencies[key].loading = false;
        this.init(target);
        Dependencies[key].callbacks.forEach(fn => fn());
        Dependencies[key].callbacks = [];
        delete Dependencies[key];
      });
    }
  }

  get strategy() {
    throw new Error('[Aeris] Subclasses must override `strategy`.');
  }
  /**
   * The HTML target in which the map is rendered to.
   */


  get $el() {
    return null;
  }
  /**
   * The third-party map view instance associated with the mapping strategy.
   */


  get map() {
    return this._map;
  }
  /**
   * A factory provider that is responsible for generating the necessary map content as
   * required by the mapping strategy.
   */


  get factory() {
    return this._factory;
  }

  get sources() {
    return Object.keys(this._sources).map(k => this._sources[k]);
  }

  get opts() {
    return this._opts;
  }
  /**
   * Returns whether the map and underlying map strategy have been fully setup and initialized.
   *
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isReady() {
    return this._ready;
  }

  init(target) {
    this.setupMap(target);
    const config = {};

    if ((0, _utils.isset)(this._opts.zoom)) {
      config.zoom = this._opts.zoom;
    }

    if (this._opts.center) {
      config.center = {
        lat: this._opts.center.lat,
        lon: this._opts.center.lon
      };
    }

    if (!this._factory) {
      throw new Error('Cannot initialize map, overlay factory is undefined.');
    }

    this._setupEvents();

    if (this._setInitialView) {
      const zoom = (0, _utils.isset)(config.zoom) ? Math.max(0, config.zoom) : 8;
      const {
        lat,
        lon
      } = config.center || {};

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        this.setView({
          lat: parseFloat(lat),
          lon: parseFloat(lon)
        }, zoom);
      } else if (zoom > 0) {
        this.setZoom(zoom);
      }
    }

    this.on('map:ready', () => {
      this._ready = true;
      this.trigger('ready');
    });
  }

  loadDependencies() {
    return null;
  }

  setupMap(target) {
    throw new Error('Subclasses of MapStrategy must override setupMap()');
  }
  /**
   * Sets the current map view using the specified center coordinate and zoom level.
   *
   * @param {Coordinate} center
   * @param {number} zoom
   * @memberof MapStrategy
   */


  setView(center, zoom) {
    throw new Error('Subclasses of MapStrategy must override setView()');
  }
  /**
   * Returns the geographical center coordinate of the map view.
   *
   * @returns {Coordinate}
   * @memberof MapStrategy
   */


  getCenter() {
    throw new Error('Subclasses of MapStrategy must override getCenter()');
  }
  /**
   * Sets the geographical center coordinate of the map view.
   *
   * @param {Coordinate} coord
   * @memberof MapStrategy
   */


  setCenter(coord) {
    throw new Error('Subclasses of MapStrategy must override setCenter()');
  }
  /**
   * Returns the current zoom level of the map view.
   *
   * @returns {number}
   * @memberof MapStrategy
   */


  getZoom() {
    throw new Error('Subclasses of MapStrategy must override getZoom()');
  }
  /**
   * Sets the zoom level of the map view.
   *
   * @param {number} zoom
   * @memberof MapStrategy
   */


  setZoom(zoom) {
    throw new Error('Subclasses of MapStrategy must override setZoom()');
  }
  /**
   * Returns the geographical bounds for the visible region of the map view.
   *
   * @returns {GeoBounds}
   * @memberof MapStrategy
   */


  getBounds() {
    throw new Error('Subclasses of MapStrategy must override getBounds()');
  }
  /**
   * Sets the geographical bounds for the visible region of the map view.
   *
   * @param {GeoBounds} bounds
   * @memberof MapStrategy
   */


  setBounds(bounds) {
    throw new Error('Subclasses of MapStrategy must override setBounds()');
  }
  /**
   * Sets the minimum visible geographical bounds for the map view so that the specified bounds
   * are contained within the visible region with an optional inset.
   *
   * @param {GeoBounds} bounds
   * @param {number[]} padding
   * @memberof MapStrategy
   */


  fitBounds(bounds, padding) {
    throw new Error('Subclasses of MapStrategy must override fitBounds()');
  }
  /** Sources */

  /**
   * Adds the specified map content source to the map.
   *
   * @param {*} source
   * @memberof MapStrategy
   */


  addSource(source) {
    const id = source.identifier;
    this._sources[id] = source;

    if (this.isTile(source)) {
      this._sourceOrder.push(id);

      source.dataSource = this;
      this.addOverlay(source.overlay);
      source.on('layer:add', e => {
        this.addOverlay(e.data.layer);
      });
      source.on('layer:remove', e => {
        this.removeOverlay(e.data.layer);
      });
    } else if (this.isVector(source)) {
      source.on('markers:add', e => {
        const {
          markers,
          animation
        } = e.data;

        if (markers) {
          this.addMarkers(markers);
        }
      });
      source.on('markers:remove', e => {
        const {
          markers
        } = e.data;

        if (markers) {
          this.removeMarkers(markers);
        }
      });
      source.on('markers:update', e => {
        (e.data.markers || []).forEach(item => {
          const {
            id: markerId,
            renderable,
            value,
            style
          } = item; // eslint-disable-line object-curly-newline

          if (value) {
            this.updateMarker(renderable, {
              data: {
                value
              },
              style: style.marker || style
            }, markerId);
          }
        });
      });
      source.on('shapes:add', e => {
        const {
          shapes,
          animation
        } = e.data;

        if (shapes) {
          if (animation) {
            this.showShapes(shapes);
          } else {
            this.addShapes(shapes);
          }
        }
      });
      source.on('shapes:remove', e => {
        const {
          shapes,
          animation
        } = e.data;

        if (shapes) {
          if (animation) {
            this.hideShapes(shapes);
          } else {
            this.removeShapes(shapes);
          }
        }
      });
    }
  }
  /**
   * Removes the specified map content source from the map.
   *
   * @param {*} source
   * @memberof MapStrategy
   */


  removeSource(source) {
    const id = source.identifier;

    if (this.isTile(source)) {
      // this.removeOverlay(source.overlay);
      source.remove();

      const index = this._sourceOrder.indexOf(id);

      if (index >= 0) {
        this._sourceOrder.splice(index, 1);
      } // (<TileSource>source).destroy();

    } else if (this.isVector(source)) {
      this.removeMarkers(source.markers);
      this.removeShapes(source.shapes);
    }

    source.strategy = null;
    delete this._sources[id];
  }
  /**
   * Returns whether the element is a tile source object.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isTile(source) {
    return false;
  }
  /**
   * Returns whether the element is a vector source object.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isVector(source) {
    return source instanceof _sources.VectorSource;
  }

  isText(source) {
    return source instanceof _sources.TextSource;
  }
  /**
   * Returns whether the element is a native map marker instance.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isMarker(el) {
    return false;
  }
  /**
   * Returns whether the element is a native map polygon instance.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isPolygon(el) {
    return false;
  }
  /**
   * Returns whether the element is a native map polyline instance.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isPolyline(el) {
    return false;
  }
  /** Overlays */

  /**
   * Adds the specified overlay layer to the map. The overlay must be an instance of the type
   * required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {*} overlay
   * @param {number} index
   * @memberof MapStrategy
   */


  addOverlay(overlay) {
    throw new Error('Subclasses of MapStrategy must override addOverlay()');
  }
  /**
   * Adds a series of overlay layers to the map. The overlays must be an instance of the type
   * required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {any[]} overlays
   * @memberof MapStrategy
   */


  addOverlays(overlays) {
    (overlays || []).forEach(overlay => this.addOverlay(overlay));
  }
  /**
   * Removes the specified overlay layer from the map. The overlay must be an instance of the
   * type required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {*} overlay
   * @memberof MapStrategy
   */


  removeOverlay(overlay) {
    throw new Error('Subclasses of MapStrategy must override removeOverlay()');
  }
  /**
   * Removes a series of overlay layers from the map. The overlay must be an instance of the
   * type required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {any[]} overlays
   * @memberof MapStrategy
   */


  removeOverlays(overlays) {
    (overlays || []).forEach(overlay => this.removeOverlay(overlay));
  }
  /** Markers */

  /**
   * Adds the marker to the map view. The provided marker must be an instance type required by
   * the current mapping strategy.
   *
   * @param marker
   * @param data
   */


  addMarker(marker, data) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        if (marker.style && marker.style.callout) {
          const callout = marker.style.callout;
          const content = (0, _utils.isFunction)(callout) ? callout(marker.data) : callout;
          this.bindCalloutToMarker(marker.renderable, content);
        }

        this.addMarker(marker.renderable, marker.data);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      marker.style = marker.style || {};
      const {
        renderable,
        data: markerData,
        style: {
          callout
        }
      } = marker;

      if (renderable) {
        if (callout) {
          const content = (0, _utils.isFunction)(callout) ? callout(markerData) : callout;
          this.bindCalloutToMarker(marker.renderable, content);
        }

        this.addMarker(renderable, markerData);
      }
    }
  }
  /**
   * Adds an array of markers to the map view. The provided markers must be an instance type
   * required by the current mapping strategy.
   *
   * @param markers
   */


  addMarkers(markers) {
    (markers || []).forEach(marker => this.addMarker(marker));
  }
  /**
   * Removes the marker from the map view. The provided marker must be an instance type required
   * by the current mapping strategy.
   *
   * @param marker
   */


  removeMarker(marker) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        this.removeMarker(marker.renderable);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      const {
        renderable
      } = marker;

      if (renderable) {
        this.removeMarker(renderable);
      }
    }
  }
  /**
   * Adds an array of markers from the map view. The provided markers must be an instance type
   * required by the current mapping strategy.
   *
   * @param markers
   */


  removeMarkers(markers) {
    (markers || []).forEach(marker => this.removeMarker(marker));
  }
  /**
   * Updates an existing marker using the specified options. The provided marker must already
   * exist on the map view and must be an instance type required by the current mapping strategy.
   *
   * @param marker
   * @param options
   */


  updateMarker(marker, options, layer = null) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        this.updateMarker(marker.renderable, options, layer);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      const {
        renderable
      } = marker;

      if (renderable) {
        this.updateMarker(renderable, options, layer);
      }
    }
  }

  bindCalloutToMarker(marker, content) {// base implementation doesn't do anything...
  }
  /** Polygons & Polylines */

  /**
   * Adds a polygon or polyline to the map view. The provided shape must be an instance type
   * required by the current mapping strategy.
   *
   * @param {*} shape
   * @param {number} index
   * @memberof MapStrategy
   */


  addShape(shape, data) {
    if ((0, _utils.isArray)(shape)) {
      this.addShapes(shape, data);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.addShape(shape.renderable, shape.data || data);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        renderable,
        polygons,
        polylines,
        data: shapeData
      } = shape;

      if (polygons) {
        this.addShapes(polygons, shapeData);
      }

      if (polylines) {
        this.addShapes(polylines, shapeData);
      }

      if (renderable) {
        this.addShape(renderable, shapeData);
      }
    }
  }
  /**
   * Adds an array of polylines and/or polygons to the map view. The provided shapes must be an
   * instance type required by the current mapping strategy.
   *
   * @param {any[]} shapes
   * @memberof MapStrategy
   */


  addShapes(shapes, data) {
    (shapes || []).forEach(shape => this.addShape(shape, data));
  }
  /**
   * Removes the polyline or polygon from the map view. The provided shape must be an instance
   * type required by the current mapping strategy.
   *
   * @param {*} shape
   * @memberof MapStrategy
   */


  removeShape(shape) {
    if ((0, _utils.isArray)(shape)) {
      this.removeShapes(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.removeShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        renderable,
        polygons,
        polylines
      } = shape;

      if (polygons) {
        this.removeShapes(polygons);
      }

      if (polylines) {
        this.removeShapes(polylines);
      }

      if (renderable) {
        this.removeShape(renderable);
      }
    }
  }
  /**
   * Removes an array of polylines and/or polygons from the map view. The provided shape must be
   * an instance type required by the current mapping strategy.
   *
   * @param {any[]} shapes
   * @memberof MapStrategy
   */


  removeShapes(shapes) {
    (shapes || []).forEach(shape => this.removeShape(shape));
  }

  showShape(shape) {
    if ((0, _utils.isArray)(shape)) {
      this.showShape(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.showShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        shape: renderable,
        polygons,
        polylines
      } = shape;

      if (polygons) {
        this.showShapes(polygons);
      }

      if (polylines) {
        this.showShapes(polylines);
      }

      if (renderable) {
        this.showShape(renderable);
      }
    }
  }

  showShapes(shapes) {
    (shapes || []).forEach(shape => this.showShape(shape));
  }

  hideShape(shape) {
    if ((0, _utils.isArray)(shape)) {
      this.hideShape(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.hideShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        shape: renderable,
        polygons,
        polylines
      } = shape;

      if (polygons) {
        this.hideShapes(polygons);
      }

      if (polylines) {
        this.hideShapes(polylines);
      }

      if (renderable) {
        this.hideShape(renderable);
      }
    }
  }

  hideShapes(shapes) {
    (shapes || []).forEach(shape => this.hideShape(shape));
  }
  /** Callout */

  /**
   * Presents a callout bubble on the map from the specified target. The target can either be an
   * `Coordinate` object or a native marker object for the mapping strategy.
   *
   * @param {*} target
   * @param {*} content
   * @param {*} opts
   * @memberof MapStrategy
   */


  showCallout(marker, content, opts) {}
  /**
   * Utilities
   */

  /**
   * Converts the specified geographical coordinate to pixel coordinates within the map view's
   * container.
   *
   * @param {Coordinate} coord
   * @returns {Point}
   * @memberof MapStrategy
   */


  coordToPoint(coord) {
    throw new Error('Subclasses of MapStrategy must override coordToPoint()');
  }
  /**
   * Converts the specified pixel coordinates within the map view's container to geographical
   * coordinates on the map.
   *
   * @param {Point} point
   * @returns {Coordinate}
   * @memberof MapStrategy
   */


  pointToCoord(point) {
    throw new Error('Subclasses of MapStrategy must override pointToCoord()');
  }

  clear() {}

  _setupEvents() {
    const mapping = this._eventMapping;

    if (mapping) {
      let method = 'on';

      if (!(0, _utils.has)(this.map, method)) {
        if ((0, _utils.has)(this.map, 'addEventListener')) {
          method = 'addEventListener';
        } else if ((0, _utils.has)(this.map, 'addListener')) {
          method = 'addListener';
        }
      }

      if ((0, _utils.has)(this.map, method)) {
        Object.keys(mapping).forEach(key => {
          this.map[method](key, e => {
            const data = this._dataForMapEvent(key, e);

            const allow = this._shouldTriggerEvent(key);

            if (allow) {
              this.trigger(mapping[key], data);
            }
          });
        });
      }
    }
  }

  _shouldTriggerEvent(name) {
    return true;
  }

  _dataForMapEvent(name, event) {
    return null;
  }
  /* Data Sources */


  tileLayer(layer, date, opts) {
    if (!this.dataSource) return null;
    let index = (0, _utils.isset)(opts.zIndex) ? opts.zIndex : 1;

    const existing = this._sourceOrder.indexOf(layer);

    if (existing >= 0) {
      index = existing + 1;
    }

    let service = (0, _utils.get)(opts, 'data.service');

    if (!service) {
      service = this.dataSource.requestForMap(layer);
    }

    service.param('format', (0, _utils.get)(opts, 'style.format') || 'png');
    const source = this.factory.tileLayer(layer, service, (0, _utils.extend)((0, _utils.cloneDeep)(opts), {
      time: date,
      zIndex: index
    }));
    return source;
  }

}

var _default = MapStrategy;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 229 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "TextSource", ({
  enumerable: true,
  get: function () {
    return _TextSource.default;
  }
}));
Object.defineProperty(exports, "VectorSource", ({
  enumerable: true,
  get: function () {
    return _VectorSource.default;
  }
}));
Object.defineProperty(exports, "GeoJsonSource", ({
  enumerable: true,
  get: function () {
    return _GeoJsonSource.default;
  }
}));
Object.defineProperty(exports, "TileSource", ({
  enumerable: true,
  get: function () {
    return _TileSource.default;
  }
}));

var _TextSource = _interopRequireDefault(__webpack_require__(230));

var _VectorSource = _interopRequireDefault(__webpack_require__(231));

var _GeoJsonSource = _interopRequireDefault(__webpack_require__(239));

var _TileSource = _interopRequireDefault(__webpack_require__(240));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 230 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _VectorSource = _interopRequireDefault(__webpack_require__(231));

var _utils = __webpack_require__(17);

var _TextDataAnimator = _interopRequireDefault(__webpack_require__(237));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `TextSource` is an object that is responsible for loading data and managing a series of text
 * annotations on a map view.
 */
class TextSource extends _VectorSource.default {
  /**
   * Initializes a new point data source instance configured with the specified AMP layer code
   * and API service.
   *
   * @param layer
   * @param service
   * @param opts
   */
  constructor(key, opts) {
    var _a;

    super(key, opts);

    if ((_a = this.opts.animation) === null || _a === void 0 ? void 0 : _a.enabled) {
      this._animator = new _TextDataAnimator.default(this, this.opts.animation);
    }
  }

  processRecord(record) {
    record = (0, _utils.cloneDeep)(record);
    let keypath = (0, _utils.get)(this.opts, 'data.properties.value');

    if (!(0, _utils.isFunction)(keypath)) {
      keypath = (keypath || '').replace(/^periods\./, ''); // set initial marker text to first period value

      if (record.periods) {
        keypath = `periods[0].${keypath}`;
      }
    }

    record.value = record.value || ((0, _utils.isFunction)(keypath) ? keypath(record) : (0, _utils.get)(record, keypath));
    return record;
  }

}

var _default = TextSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 231 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _CoordinateBounds = _interopRequireDefault(__webpack_require__(198));

var _MapElement = __webpack_require__(232);

var _Feature = _interopRequireDefault(__webpack_require__(194));

var _geo = __webpack_require__(196);

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(233);

var _fetcher = __webpack_require__(234);

var _VectorDataAnimator = _interopRequireDefault(__webpack_require__(235));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getElementStyle = (style, record = {}) => {
  const result = (0, _utils.isFunction)(style) ? style(record) : style;
  return result || {};
};

const DEFAULT_STYLE = {
  marker: {
    svg: {
      shape: {
        type: 'circle',
        fill: {
          color: '#000'
        }
      }
    },
    size: [6, 6]
  },
  polygon: {
    fill: {
      color: '#000',
      opacity: 1
    },
    stroke: {
      color: '#000',
      width: 2
    }
  },
  polyline: {
    stroke: {
      color: '#000',
      width: 2
    }
  }
};
/**
 * `VectorSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view.
 */

class VectorSource extends _EventDispatcher.default {
  constructor(key, opts) {
    var _a;

    super();
    /**
     * Whether the data source requests data for the visible map bounds. If `true`, then data will
     * be reloaded whenever the map's visible region changes.
     *
     * Default value is `false`.
     *
     * @type {boolean}
     * @memberof VectorSource
     */

    this.requiresBounds = false;
    this._animateOnLoad = false;
    this.key = key;
    this.enabled = true;
    this.opts = (0, _utils.extend)({
      data: null,
      style: opts.style || Object.assign({}, DEFAULT_STYLE),
      requiresBounds: false,
      restrictToTimeline: true,
      animation: {
        key,
        enabled: false
      },
      refresh: 0
    }, opts);
    this._opacityByType = {
      marker: 1,
      polyline: 1,
      polygon: 1
    };
    this.style = this.opts.style;

    if (this.style) {
      const initialOpacity = (_a = this.style) === null || _a === void 0 ? void 0 : _a.opacity;

      if ((0, _utils.isset)(initialOpacity)) {
        this._opacity = initialOpacity;
      } // store the opacity for each element type based on the specified style if provided


      ['polyline', 'polygon'].forEach(type => {
        var _a, _b;

        const styleRef = getElementStyle(this.style[type]);
        const typeOpacity = ((_a = styleRef.fill) === null || _a === void 0 ? void 0 : _a.opacity) || ((_b = styleRef.stroke) === null || _b === void 0 ? void 0 : _b.opacity);

        if ((0, _utils.isset)(typeOpacity)) {
          this._opacityByType[type] = typeOpacity;
        }
      });
    }

    const animationOpts = this.opts.animation;

    if (animationOpts.enabled) {
      this._animator = new _VectorDataAnimator.default(this, animationOpts);
    }

    let service = (0, _utils.get)(this.opts, 'data.service');

    if ((0, _utils.isFunction)(service)) {
      service = service();
    }

    this._service = service;
    this.requiresBounds = (0, _utils.get)(this.opts, 'requiresBounds');
  }
  /**
   * Current markers being managed by the data source.
   *
   * @readonly
   * @type {*}
   * @memberof VectorSource
   */


  get markers() {
    var _a;

    return (_a = this._result) === null || _a === void 0 ? void 0 : _a.markers;
  }
  /**
   * Returns an object containing all active markers keyed by their unique identifiers.
   *
   * @readonly
   * @type {{ [id: string]: any }}
   * @memberof VectorSource
   */


  get markersById() {
    return this._markers;
  }
  /**
   * Current polygons being managed by the data source.
   *
   * @readonly
   * @type {*}
   * @memberof VectorSource
   */


  get polygons() {
    var _a;

    return (_a = this._result) === null || _a === void 0 ? void 0 : _a.polygons;
  }
  /**
   * Current polygons being managed by the data source.
   *
   * @readonly
   * @type {*}
   * @memberof VectorSource
   */


  get polylines() {
    var _a;

    return (_a = this._result) === null || _a === void 0 ? void 0 : _a.polylines;
  }
  /**
   * Current polygons and polylines being managed by the data source.
   *
   * @readonly
   * @type {ShapeDef[]}
   * @memberof VectorSource
   */


  get shapes() {
    var _a, _b;

    let elements = [];

    if ((_a = this.polygons) === null || _a === void 0 ? void 0 : _a.length) {
      if (this.polygons[0].elements) {
        this.polygons.forEach(group => {
          elements = elements.concat(group.elements);
        });
      } else {
        elements = elements.concat(this.polygons);
      }
    }

    if ((_b = this.polylines) === null || _b === void 0 ? void 0 : _b.length) {
      if (this.polylines[0].elements) {
        this.polylines.forEach(group => {
          elements = elements.concat(group.elements);
        });
      } else {
        elements = elements.concat(this.polylines);
      }
    }

    return elements;
  }
  /**
   * Map strategy the source is associated with.
   *
   * @type {MapStrategy}
   * @memberof VectorSource
   */


  get strategy() {
    return this._strategy;
  }

  set strategy(value) {
    if (value) {
      this._strategy = value;
      value.on('move:end', e => {
        this._visibleBounds = _CoordinateBounds.default.fromBounds(value.getBounds()); // this._updateVisibleMapObjects();
      });
    }
  }
  /**
   * API service used to request data for the data source.
   *
   * @readonly
   * @type {ApiRequest}
   * @memberof VectorSource
   */


  get service() {
    return this._service;
  }
  /**
   * Returns the animation associated with the static layer.
   *
   * @readonly
   * @type {DataAnimation}
   * @memberof VectorSource
   */


  get animation() {
    var _a;

    return (_a = this._animator) === null || _a === void 0 ? void 0 : _a.animation;
  }
  /**
   * Whether the data source is enabled.
   *
   * @type {boolean}
   * @memberof VectorSource
   */


  get enabled() {
    return this._enabled;
  }

  set enabled(value) {
    this._enabled = value;

    if (value === false) {
      this._stopAutoUpdate();
    } else {
      this._startAutoUpdateIfNeeded();
    }
  }

  get isLoading() {
    return this._loading;
  }

  get animationEnabled() {
    return (0, _utils.isset)(this.animation) && this.animation.isEnabled();
  }
  /**
   * Returns whether the source currently has data cached from a previous request.
   *
   * @returns {boolean}
   * @memberof VectorSource
   */


  hasData() {
    return !(0, _utils.isEmpty)(this.markers) || !(0, _utils.isEmpty)(this.polygons) || !(0, _utils.isEmpty)(this.polylines);
  }

  setData(data) {
    this._data = (0, _utils.isPlainObject)(data) ? (0, _utils.cloneDeep)(data) : data;
    this.render();
  }

  setOpacity(value = 1) {
    this._opacity = value; // update opacity for each shape element if enabled
    // opacity is applied to the initial style.opacity for that element

    this.shapes.filter(element => element.adjustOpacity).forEach(element => {
      if (element instanceof _MapElement.PolylineMapElement) {
        element.renderable.setOpacity(this._opacityByType.polyline * value);
      } else if (element instanceof _MapElement.PolygonMapElement) {
        element.renderable.setOpacity(this._opacityByType.polygon * value);
      }
    });
  }
  /**
   * Requests data for the layer based on the provided geographical map bounds and date range.
   *
   * @param bounds
   * @param from
   * @param to
   * @returns A Promise containing the resulting marker data objects.
   */


  load(params, animateOnLoad = false, appendData) {
    var _a;

    const dataConfig = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.data;

    if (!dataConfig) {
      return new Promise((resolve, reject) => {
        reject(new Error('Invalid configuration for VectorSource'));
      });
    }

    params = (0, _utils.extend)({}, (0, _utils.get)(this.opts, 'data.request.parameters'), this._lastLoadParams, params);
    this._lastLoadParams = params;
    this._animateOnLoad = animateOnLoad;
    const {
      service,
      url,
      items
    } = dataConfig;
    const {
      bounds,
      from,
      to
    } = params;

    if (this.requiresBounds && !(0, _utils.isset)(bounds)) {
      throw new Error(`[Aeris] Vector source ${this.key} requires coordinate bounds when loading but bounds were not provided.`);
    }

    if (bounds) {
      this._visibleBounds = _CoordinateBounds.default.fromBounds(bounds);
    }

    if (items) {
      return new Promise((resolve, reject) => {
        this._onLoad(items, (result, error) => {
          if (result) {
            resolve(result);
          } else {
            reject(error);
          }
        });
      });
    }

    const fetcher = (0, _fetcher.getDataFetcher)({
      service,
      url,
      dataKeypath: (0, _utils.get)(this.opts, 'data.properties.root'),
      restrictToTimeline: this.opts.restrictToTimeline,
      onLoad: (data, callback) => {
        this._onLoad(data, callback, appendData);
      },
      onError: (err, callback) => {
        this._onError(err, callback);
      }
    });

    if (service) {
      this._service = (0, _utils.isFunction)(service) ? service() : service;
    }

    if (!(0, _utils.isset)(fetcher)) {
      throw new Error(`[Aeris] Cannot load data for VectorSource with key {${this.key}} due to an invalid configuration. Check that you have provided a valid "data.service" or "data.url" in your configuration. Refer to the docs for more info: https://www.aerisweather.com/support/docs/toolkits/aeris-js-sdk/map-modules/data-sources/`);
    }

    if (!this._request) {
      this._request = (0, _utils.debounce)((b, _from, _to, _params, callback) => {
        this._loading = true;
        fetcher(b, _from, _to, _params, callback);
      }, 1500);
    }

    return new Promise((resolve, reject) => {
      if (this._request) {
        const requestFrom = (0, _utils.get)(this.opts, 'data.request.parameters.from') || from;
        const requestTo = (0, _utils.get)(this.opts, 'data.request.parameters.to') || to;
        this._loading = true;
        this.trigger('data:load:start', {
          layer: this.key
        });

        this._request(bounds, requestFrom, requestTo, this._lastLoadParams, (results, error) => {
          this.trigger('data:load:done', {
            layer: this.key
          });

          if (error) {
            reject(error);
          } else {
            resolve(results);
          }

          this._startAutoUpdateIfNeeded();
        });
      } else {
        reject(new Error('Invalid configuration for VectorSource'));
      }
    });
  }
  /**
   * Reloads the data source using the last request parameters.
   *
   * @memberof VectorSource
   */


  reload(params, appendData) {
    this.load(params, false, appendData);
  }

  render() {
    if (!(0, _utils.isset)(this._data)) return; // trigger event so existing map objects are removed from map

    let markers = this.markers;
    let shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:remove', {
        markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:remove', {
        shapes
      });
    }

    this._result = this._process(this._data); // update map elements with current opacity value

    this.setOpacity(this._opacity); // now add new map objects

    markers = this.markers;
    shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:add', {
        markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:add', {
        shapes
      });
    }
  }
  /**
   * Resets the data source by removing all map elements and clearing cached data.
   *
   * @memberof VectorSource
   */


  reset() {
    const markers = this.markers;
    const shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:remove', {
        markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:remove', {
        shapes
      });
    }

    if (this.animation) {
      this.animation.reset();
    }

    this._loading = false;
    this._result = {};
    this.trigger('data:load:done', {
      layer: this.key
    });
    this.trigger('reset');
  }
  /**
   * Reloads the data source by updating the data configuration.
   *
   * @param {*} [data]
   * @memberof VectorSource
   * @see VectorSourceOptions
   */


  update(data) {
    if (data) {
      this.opts.data = (0, _utils.extend)(this.opts.data, data);
      this._request = null;
    }

    this.reload();
  } // protected _updateVisibleMapObjects() {
  // 	const { markers: visibleMarkers, shapes: visibleShapes } = this._lastVisibleMapObjects;
  // 	const { markers, shapes } = this._visibleMapObjects();
  // 	console.log('VECTOR', this._visibleBounds, 'VISIBLE', markers, shapes);
  // 	let markersToRemove = visibleMarkers.filter((marker) => markers.indexOf(marker) === -1);
  // 	let shapesToRemove = visibleShapes.filter((shape) => shapes.indexOf(shape) === -1);
  // 	if (!isEmpty(markersToRemove)) {
  // 		this.trigger('markers:remove', { markersToRemove });
  // 	}
  // 	if (!isEmpty(shapesToRemove)) {
  // 		this.trigger('shapes:remove', { shapesToRemove });
  // 	}
  // 	if (!isEmpty(markers)) {
  // 		this.trigger('markers:add', { markers });
  // 	}
  // 	if (!isEmpty(shapes)) {
  // 		this.trigger('shapes:add', { shapes });
  // 	}
  // 	console.log(markersToRemove, shapesToRemove);
  // 	this._lastVisibleMapObjects = { markers, shapes };
  // }


  _onLoad(data, callback, appendData) {
    if (this.enabled === false) {
      return;
    }

    if (data) {
      if (appendData) {
        if ((0, _utils.isArray)(data)) {
          data = [...appendData, ...data];
        } else if ((0, _utils.isPlainObject)(data)) {
          data = Object.assign(Object.assign({}, appendData), data);
        }
      }

      this.setData(data);
    }

    this._loading = false;
    this.trigger('data:load', {
      layer: this.key,
      results: data
    });

    if ((0, _utils.isFunction)(callback)) {
      callback(this._result, null);
    }

    if (this._animateOnLoad && this.animation) {
      this.animation.reset();
      this.animation.play();
    }

    this._animateOnLoad = false;
  }

  _onError(e, callback) {
    console.error('[Aeris] Vector source request failed', e);

    if (e.stack) {
      console.log(e.stack); // eslint-disable-line no-console
    }

    this._loading = false;
    this.trigger('data:error', {
      error: e
    });

    if (callback) {
      callback(null, e);
    }
  }

  _visibleMapObjects() {
    let markers = this.markers;
    let shapes = this.shapes;
    markers = markers.filter(marker => {
      const coord = marker.coord;

      if (coord) {
        return this._visibleBounds.contains(coord);
      }

      return true;
    });
    shapes = shapes.filter(shape => {
      const bounds = shape.bounds;

      if (bounds) {
        return this._visibleBounds.contains(bounds);
      }

      return true;
    });
    return {
      markers,
      shapes
    };
  }

  _mapObjects() {
    let existing = [];

    if (this.polygons) {
      existing = existing.concat(this.polygons);
    }

    if (this.polylines) {
      existing = existing.concat(this.polylines);
    }

    if (existing.length === 0) {
      return null;
    }

    const results = Object.keys(existing).reduce((prev, key) => prev.concat(existing.map(item => {
      if (item.polygons) {
        return item.polygons.map(p => p.polygon);
      }

      if (item.polylines) {
        return item.polylines.map(p => p.polyline);
      }

      if (item.polygon) {
        return item.polygon;
      }

      if (item.polyline) {
        return item.polyline;
      }

      return item;
    })), []);
    return (0, _utils.flatten)(results);
  }
  /**
   * Generates and returns map vector objects from the specified data.
   * @param data
   */


  _process(data, parentId) {
    if (!this.strategy) throw new Error('No map strategy defined for VectorSource but one is required.');
    data = data || {};
    const dataFormatter = (0, _utils.get)(this.opts, 'data.formatter');

    if (dataFormatter) {
      data = dataFormatter(data);
    }

    const markers = {};
    const polygons = {};
    const polylines = {};

    if ((0, _utils.isPlainObject)(data) && data.type === 'FeatureCollection') {
      console.warn(`[Aeris] Data for layer {${this.key}} is in GeoJSON format. Use GeoJsonSource (or "geojson" type) for this layer instead.`);
      return null;
    }

    if ((0, _utils.isArray)(data)) {
      const {
        marker: markerStyle,
        polygon: polygonStyle,
        polyline: polylineStyle
      } = this.style;
      const coords = [];
      const props = (0, _utils.get)(this.opts, 'data.properties') || {};
      const geomFn = (0, _utils.get)(this.opts, 'data.geometry');
      data.forEach((item, index) => {
        let id = `awxjs-shape-${this.key}-${index}`;
        let category;
        let path;
        let points;

        if (props) {
          if (props.id) {
            id = (0, _utils.get)(item, props.id);
          }

          if (props.category && /^\[path\]/.test(props.category) === false) {
            category = (0, _utils.get)(item, props.category);
          }

          if (props.path) path = (0, _utils.get)(item, props.path);

          if (markerStyle) {
            if (props.points) {
              const key = props.points;

              if (!parentId && (0, _utils.isArray)(key)) {
                points = [];
                key.forEach(k => {
                  const result = (0, _utils.get)(item, k);

                  if (result && (0, _utils.isArray)(result)) {
                    points = points.concat(result);
                  }
                });
              } else {
                points = (0, _utils.get)(item, key);
              }
            } else {
              points = [item];
            }
          }
        } // process markers


        if (points && markerStyle) {
          const coordFn = (0, _utils.get)(this.opts, 'data.coordinate');
          points.forEach(element => {
            const record = this._processRecord(element);

            const loc = record.loc || (coordFn && (0, _utils.isFunction)(coordFn) ? coordFn(record) : {});

            if (loc) {
              const coord = {
                lat: loc.lat,
                lon: loc.long || loc.lon
              };
              const style = (0, _utils.isFunction)(markerStyle) ? markerStyle(record) : markerStyle;
              record.id = record.id || `${this.key}-${id}-${coord.lat}_${coord.lon}`; // determine if we should add this marker based on the spacing configuration from the style

              let allow = true;

              if (style && style.spacing > 0) {
                const point = this.strategy.coordToPoint(coord);
                coords.forEach(c => {
                  const p = this.strategy.coordToPoint(c);
                  const dist = Math.sqrt(Math.pow(point.x - p.x, 2) + Math.pow(point.y - p.y, 2));

                  if (dist < style.spacing) {
                    allow = false;
                  }
                });
              }

              if (allow) {
                // convert record to Feature
                const feature = new _Feature.default({
                  type: 'Point',
                  coordinates: [coord.lon, coord.lat]
                });
                feature.properties = record;
                const geometry = feature.geometry;

                if (geometry instanceof _geo.Point) {
                  if ((0, _utils.isValidCoord)(geometry.coordinates)) {
                    const result = (0, _utils2.generateMarker)(this.key, feature.properties, geometry.coordinates, style, this.strategy.factory);

                    if (result) {
                      markers[record.id] = result;
                      coords.push(coord);
                    }
                  }
                }
              }
            }
          });
        } // process polygons


        if (path && (polygonStyle || polylineStyle)) {
          const reversedCoord = (0, _utils.get)(this.opts, 'data.reversedCoord') || false;
          let paths = path;

          if (!(0, _utils.isArray)(paths)) {
            paths = [paths];
          } else if (paths.length > 0 && (0, _utils.isArray)(paths[0]) && paths[0].length === 2 && (0, _utils.isNumber)(paths[0][0])) {
            // handle case where a path definition is provided as an array of
            // LatLon arrays, in which case we need to wrap it into another array
            // e.g. [[lat, lon], [lat, lon]]
            paths = [paths];
          } // if a geometry function is defined, update the path definition
          // this is used to handle cases where the actual geometry is provided on a subproperty
          // under the layer's primary `path` property key


          if (geomFn && (0, _utils.isFunction)(geomFn)) {
            paths = paths.map(element => ({
              type: 'Feature',
              properties: element,
              geometry: geomFn(element)
            }));
          }

          const features = paths.map(featurePath => {
            // convert an array of coordinates to a Polygon geometry instance
            if ((0, _utils.isArray)(featurePath) && featurePath[0].length === 2) {
              const featureCoords = reversedCoord ? path.map(p => [p[1], p[0]]) : featurePath;
              featurePath = {
                type: 'Polygon',
                coordinates: [featureCoords]
              };
            }

            const feature = new _Feature.default(featurePath);
            feature.properties = (0, _utils.extend)({}, item, feature.properties);
            return feature;
          });
          features.forEach(feature => {
            let geometry = feature.geometry;
            let groupKeyPath = props.category;
            let group = category; // if no parent category, check if the individual path definitions have the category defined

            if (!group && groupKeyPath) {
              groupKeyPath = groupKeyPath.replace(/^\[path\]\./, '');
              group = (0, _utils.get)(feature.properties, groupKeyPath);
            } // convert single geometries to arrays


            if (geometry instanceof _geo.Polygon) {
              geometry = new _geo.MultiPolygon([geometry.toArray(true)]);
            } else if (geometry instanceof _geo.LineString) {
              geometry = new _geo.MultiLineString([geometry.toArray(true)]);
            } // create map elements for each geometry


            if (geometry instanceof _geo.MultiPolygon) {
              const recordId = `${feature.properties.id || id}`;
              const record = Object.assign(Object.assign({}, feature.properties), {
                id: recordId
              });
              const element = (0, _utils2.generatePolygon)(this.key, record, geometry, polygonStyle, this.strategy.factory);

              if (group) {
                let groupStore = polygons[group];

                if (!groupStore) {
                  const groupData = (0, _utils.set)({}, groupKeyPath, group);
                  groupStore = {
                    data: Object.assign(Object.assign(Object.assign({}, groupData), record), {
                      awxjs_source: this.key
                    }),
                    elements: []
                  };
                  polygons[group] = groupStore;
                }

                groupStore.elements.push(element);
              } else if (id) {
                polygons[id] = element;
              }
            } else if (geometry instanceof _geo.MultiLineString) {
              geometry.lines.forEach((line, idx) => {
                const record = Object.assign(Object.assign({}, feature.properties), {
                  id: `${feature.properties.id || id}-${idx}`
                });
                const element = (0, _utils2.generatePolyline)(this.key, record, line.coordinates, polylineStyle, this.strategy.factory);

                if (group) {
                  let groupStore = polygons[group];

                  if (!groupStore) {
                    const groupData = (0, _utils.set)({}, groupKeyPath, group);
                    groupStore = {
                      data: Object.assign(Object.assign({}, groupData), {
                        awxjs_source: this.key
                      }),
                      elements: []
                    };
                    polylines[group] = groupStore;
                  }

                  groupStore.elements.push(element);
                } else if (id) {
                  polylines[id] = element;
                }
              });
            }
          });
        } // process polylines


        if (points && polylineStyle) {
          const segments = (0, _utils2.generateLineSegments)(points, (0, _utils.get)(this.opts, 'data.properties.category'), (0, _utils.get)(this.opts, 'data.coordinate'));
          segments.forEach(segment => {
            const result = (0, _utils2.generatePolyline)(this.key, segment.data, segment.coords, polylineStyle, this.strategy.factory);
            polylines[result.id] = result;
          });
        }
      });
    }

    this._markers = markers;
    this._polygons = polygons;
    this._polylines = polylines;
    return {
      markers: Object.keys(markers).map(key => markers[key]),
      polygons: Object.keys(polygons).map(key => polygons[key]),
      polylines: Object.keys(polylines).map(key => polylines[key])
    };
  }

  _processRecord(record) {
    return record;
  }

  _startAutoUpdateIfNeeded() {
    this._stopAutoUpdate(); // setup update timer if auto-refresh is enabled


    const refresh = (0, _utils.get)(this.opts, 'refresh');

    if (this.enabled && refresh > 0) {
      this._refreshTimer = setTimeout(() => {
        this.reload();
      }, refresh * 1000);
    }
  }

  _stopAutoUpdate() {
    if (this._refreshTimer) {
      clearTimeout(this._refreshTimer);
      this._refreshTimer = null;
    }
  }

}

var _default = VectorSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 232 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.PolygonMapElement = exports.PolylineMapElement = exports.MarkerMapElement = void 0;

var _utils = __webpack_require__(17);

/**
 * An object that represents a map element and contains the data, style and renderable object
 * associated with the element.
 */
class MapElement {
  constructor(data, style, renderable) {
    this.data = data;
    this.style = style;
    this.renderable = renderable;

    if (data.id) {
      this.id = data.id;
    }
  }
  /**
   * Returns the coordinate bounds that contains the element's geometry.
   *
   * @readonly
   * @type {CoordinateBounds}
   * @memberof MapElement
   */


  get bounds() {
    if (this.geometry && (0, _utils.has)(this.geometry, 'bounds')) {
      return this.geometry.bounds();
    }

    return null;
  }
  /**
   * A Boolean value indicating whether the element should adjust its opacity when the parent data
   * source's opacity changes. Default value is `true`.
   *
   * @readonly
   * @type {boolean}
   * @memberof MapElement
   */


  get adjustOpacity() {
    var _a;

    const adjust = (_a = this.style) === null || _a === void 0 ? void 0 : _a.adjustOpacity;
    return (0, _utils.isset)(adjust) ? adjust : true;
  }

}
/**
 * A marker map element.
 */


class MarkerMapElement extends MapElement {}
/**
 * A polyline map element.
 */


exports.MarkerMapElement = MarkerMapElement;

class PolylineMapElement extends MapElement {}
/**
 * A polygon map element.
 */


exports.PolylineMapElement = PolylineMapElement;

class PolygonMapElement extends MapElement {}

exports.PolygonMapElement = PolygonMapElement;
var _default = MapElement;
exports["default"] = _default;

/***/ }),
/* 233 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generateLineSegments = exports.generatePolygon = exports.generatePolyline = exports.generateMarker = void 0;

var _utils = __webpack_require__(17);

var _geo = __webpack_require__(196);

var _MapElement = __webpack_require__(232);

const generateMarker = (key, record, coord, style, factory) => {
  const marker = factory.marker(key, {
    lat: coord.lat,
    lon: coord.lon
  }, style); // don't create map element if returned marker instance is null

  if (!marker) {
    return null;
  }

  const data = Object.assign(Object.assign({}, record), {
    awxjs_source: key
  });
  const element = new _MapElement.MarkerMapElement(data, style, marker);
  element.geometry = new _geo.Point([coord.lon, coord.lat]);
  return element;
};

exports.generateMarker = generateMarker;

const generatePolyline = (key, record, points, style, factory) => {
  const elementStyle = (0, _utils.isFunction)(style) ? style(record) : style;
  const polyline = factory.polyline(record.id, points, elementStyle);
  const data = Object.assign(Object.assign({}, record), {
    awxjs_source: key
  });
  const element = new _MapElement.PolylineMapElement(data, elementStyle, polyline); // element.geometry = geometry;

  return element;
};

exports.generatePolyline = generatePolyline;

const generatePolygon = (key, record, geometry, style, factory) => {
  const generateDef = geometries => geometries.map((geom, index) => ({
    id: `${record.id}-${index}`,
    outer: geom.outer.coordinates,
    inner: geom.inner.map(inner => inner.coordinates)
  }));

  let shapes = [];

  if (geometry instanceof _geo.MultiPolygon) {
    shapes = generateDef(geometry.polygons);
  } else if (geometry instanceof _geo.Polygon) {
    shapes = generateDef([geometry]);
  } // const shape: PolygonDef = {
  // 	id: record.id,
  // 	outer: geometry.outer.coordinates,
  // 	inner: geometry.inner.map((inner) => inner.coordinates)
  // };


  const elementStyle = (0, _utils.isFunction)(style) ? style(record) : style;
  const polygon = factory.polygon(key, shapes, elementStyle);
  const data = Object.assign(Object.assign({}, record), {
    awxjs_source: key
  });
  const element = new _MapElement.PolygonMapElement(data, elementStyle, polygon);
  element.geometry = geometry;
  return element;
};

exports.generatePolygon = generatePolygon;

const generateLineSegments = (points, groupKeyPath, coordFn) => {
  // determines if segments in the same category should be joined into a single line
  const joinLines = false;
  const segments = [];
  let segmentBounds;
  let segmentCoords = [];
  let segmentData;
  let lastGroup;
  let lastCoord;
  points.forEach((point, index) => {
    const loc = point.loc || (coordFn && (0, _utils.isFunction)(coordFn) ? coordFn(point) : {});
    const coord = (0, _utils.isEmpty)(loc) && point.lat && point.lon ? point : {
      lat: loc.lat,
      lon: loc.long || loc.lon
    };
    const group = groupKeyPath ? point[groupKeyPath] : 'none';

    if (!(0, _utils.isset)(lastCoord) || coord.lat !== lastCoord.lat || coord.lon !== lastCoord.lon) {
      segmentCoords.push(coord);

      if (index === 0) {
        segmentBounds = {
          north: coord.lat,
          south: coord.lat,
          west: coord.lon,
          east: coord.lon
        };
      } else {
        segmentBounds.north = Math.max(segmentBounds.north, coord.lat);
        segmentBounds.south = Math.min(segmentBounds.south, coord.lat);
        segmentBounds.west = Math.min(segmentBounds.west, coord.lon);
        segmentBounds.east = Math.max(segmentBounds.east, coord.lon);
      }

      let resetSegment = true;

      if (joinLines) {
        if (index === 0) {
          segmentData = point;
          resetSegment = true;
        } else if (index === points.length - 1) {
          segments.push({
            coords: segmentCoords,
            data: point,
            bounds: segmentBounds
          });
        } else if (group !== lastGroup) {
          segments.push({
            coords: segmentCoords,
            data: segmentData,
            bounds: segmentBounds
          });
          segmentData = point;
          resetSegment = true;
        }
      } else {
        segments.push({
          coords: segmentCoords,
          data: point,
          bounds: segmentBounds
        });
        resetSegment = true;
      }

      if (resetSegment) {
        segmentCoords = [];
        segmentCoords.push(coord);
        segmentBounds = {
          north: coord.lat,
          south: coord.lat,
          west: coord.lon,
          east: coord.lon
        };
      }
    }

    lastGroup = group;
    lastCoord = coord;
  });
  return segments;
};

exports.generateLineSegments = generateLineSegments;

/***/ }),
/* 234 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getDataFetcher = void 0;

var _ApiRequest = _interopRequireDefault(__webpack_require__(100));

var _Http = _interopRequireDefault(__webpack_require__(101));

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getDataFetcher = ({
  service,
  url,
  dataKeypath,
  restrictToTimeline = true,
  onLoad = () => {},
  onError = () => {}
}) => {
  let fetcher;

  if (service) {
    fetcher = (b, from, to, params, callback) => {
      const request = (0, _utils.isFunction)(service) ? service() : service;

      if (!(0, _utils.isset)(request) || request instanceof _ApiRequest.default === false) {
        console.error('[Aeris] Invalid ApiRequest returned for data source');
        return;
      }

      const limit = request.param('limit') || 300;
      const sort = request.param('sort') || 'dt:-1'; // update request params if provided before setting primary source params

      if (params) {
        request.setParams(params);
      } // set action if not defined already on the request


      const action = request.getAction();

      if (!action) {
        request.action("within"
        /* WITHIN */
        );
      } // only set place using bounds if a `within` action


      if (request.getAction() === "within"
      /* WITHIN */
      ) {
          if (b) {
            request.place((0, _strings.toBounds)(b));
          } else {
            return;
          }
        }

      if (restrictToTimeline) {
        request.from(from).to(to).limit(limit).sort(sort);
      }

      request.get().then(result => {
        onLoad((0, _utils.get)(result.data, dataKeypath) || result.data, callback);
      }).catch(e => onError(e, callback));
    };
  } else if (url) {
    fetcher = (b, from, to, params, callback) => {
      const requestUrl = (0, _utils.isFunction)(url) ? url(params) : url;

      _Http.default.request(requestUrl).then(res => {
        onLoad((0, _utils.get)(res.data, dataKeypath) || res.data, callback);
      }).catch(e => onError(e, callback));
    };
  }

  return fetcher;
};

exports.getDataFetcher = getDataFetcher;

/***/ }),
/* 235 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _DataAnimation = _interopRequireDefault(__webpack_require__(236));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class VectorDataAnimator {
  constructor(source, opts) {
    this._animatableData = [];
    this._nonAnimatableData = [];
    this.source = source;

    const groupElements = elements => {
      const markers = elements.filter(item => {
        if (item.renderable) {
          return source.strategy.isMarker(item.renderable);
        }

        return source.strategy.isMarker(item);
      });
      const shapes = elements.filter(item => {
        if (item.renderable) {
          return source.strategy.isPolygon(item.renderable) || source.strategy.isPolyline(item.renderable);
        }

        return source.strategy.isPolygon(item) || source.strategy.isPolyline(item);
      });
      return {
        markers,
        shapes
      };
    };

    const anim = new _DataAnimation.default();
    anim.provider = this;
    anim.on('play', () => {
      const {
        markers,
        shapes
      } = groupElements(this._nonAnimatableData);

      if (markers.length > 0) {
        source.trigger('markers:remove', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:remove', {
          shapes,
          animation: anim
        });
      }
    });
    anim.on('stop', () => {
      const {
        markers,
        shapes
      } = groupElements(this._nonAnimatableData);

      if (markers.length > 0) {
        source.trigger('markers:add', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:add', {
          shapes,
          animation: anim
        });
      }
    });
    anim.on('reset', () => {
      if (source.enabled) {
        if (source.markers) {
          source.trigger('markers:add', {
            markers: source.markers,
            animation: anim
          });
        }

        if (source.shapes) {
          source.trigger('shapes:add', {
            shapes: source.shapes,
            animation: anim
          });
        }
      }

      this._animatableData = [];
      this._nonAnimatableData = [];
    });
    anim.on('data:add', e => {
      const {
        markers,
        shapes
      } = groupElements(e.data.items);

      if (markers.length > 0) {
        source.trigger('markers:add', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:add', {
          shapes,
          animation: anim
        });
      }
    });
    anim.on('data:remove', e => {
      const {
        markers,
        shapes
      } = groupElements(e.data.items);

      if (markers.length > 0) {
        source.trigger('markers:remove', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:remove', {
          shapes,
          animation: anim
        });
      }
    });
    this.animation = anim;
  }
  /**
   * Animation Provider
   */


  animationData(animation) {
    const source = this.source;

    const processAnimationData = () => {
      // const { markers, shapes } = this._visibleMapObjects();
      const markers = Object.keys(source.markersById).map(key => source.markersById[key]);
      const shapes = source.shapes;
      let result = [];

      if (markers) {
        const elements = markers.map(item => {
          var _a, _b;

          const {
            data,
            renderable,
            style
          } = item;

          if (!data || !renderable) {
            return null;
          }

          let timestamp;
          const tsKey = ((_b = (_a = source.opts.data) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.timestamp) || 'timestamp';

          if ((0, _utils.has)(data, tsKey)) {
            timestamp = (0, _utils.get)(data, tsKey) * 1000;
          } else {
            this._nonAnimatableData.push(renderable);
          }

          return {
            timestamp,
            renderable,
            style,
            data
          };
        }).filter(item => item && Number.isNaN(item.timestamp) === false);

        if (elements) {
          result = result.concat(elements);
        }
      }

      if (shapes) {
        const processShapes = elements => elements.map(item => {
          var _a, _b;

          const {
            data,
            renderable,
            style
          } = item;

          if (!data) {
            return null;
          }

          const keypath = ((_b = (_a = source.opts.data) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.timestamp) || 'timestamp';
          let timestamp;
          let tsKey;

          if (typeof keypath === 'object' && keypath.from) {
            tsKey = keypath.from;
          } else if (typeof keypath === 'string') {
            tsKey = keypath;
          }

          if ((0, _utils.has)(data, tsKey)) {
            timestamp = (0, _utils.get)(data, tsKey) * 1000;
          } else {
            this._nonAnimatableData.push(renderable);
          }

          return {
            timestamp,
            renderable,
            style,
            data
          };
        }).filter(item => item && Number.isNaN(item.timestamp) === false);

        shapes.forEach(shape => {
          const _shapes = shape.polygons;

          if ((0, _utils.isset)(_shapes)) {
            const elements = processShapes(_shapes);

            if (elements) {
              result = result.concat(elements);
            }
          } else {
            const elements = processShapes([shape]);

            if (elements) {
              result = result.concat(elements);
            }
          }
        });
      }

      this._animatableData = result;
      return result;
    };

    return new Promise((resolve, reject) => {
      if (source.isLoading) {
        source.once('data:load', () => {
          const result = processAnimationData();
          resolve(result);
        });
      } else if (this._animatableData && this._animatableData.length > 0) {
        resolve(this._animatableData);
      } else if (!source.markers) {
        resolve(null);
      } else {
        const result = processAnimationData();
        resolve(result);
      }
    });
  }

}

var _default = VectorDataAnimator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 236 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Animation = _interopRequireDefault(__webpack_require__(222));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `DataAnimation` object is a subclass of `Animation` that is responsible for managing data
 * required for animation playback.
 */
class DataAnimation extends _Animation.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof DataAnimation
   */
  constructor(opts = null) {
    opts = (0, _utils.extend)({}, {
      refresh: 0
    }, opts);
    super(opts);
    this.itemsByTime = {};
    this.lastInterval = 0;
    this.dataBeyondBounds = {
      before: [],
      after: []
    }; // add event handler to re-add all data elements that fall after the end of the timeline
    // range when the animation is stopped

    this.on('stop', () => {
      this.trigger("data:add"
      /* DATA_ADD */
      , {
        items: this.dataBeyondBounds.after.filter(item => item !== undefined)
      }); // eslint-disable-line max-len
    });
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof DataAnimation
   */


  dataByTime() {
    return this.itemsByTime;
  }
  /**
   * Updates the data for the animation.
   *
   * @param {*} data
   * @memberof DataAnimation
   */


  setData(data) {
    this.data = data;

    this._prepareDataItems(data);
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * If data is not yet available for playback, then it will be requested from the animation
   * data provider.
   *
   * @returns
   * @memberof DataAnimation
   */


  play() {
    if (!this.canAnimate() && this.provider) {
      this.provider.animationData(this).then(data => {
        this.setData(data);
        this.lastInterval = this.to;
      });
      return;
    }

    super.play();
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate data for the specifyed time interval.
   *
   * @protected
   * @param {*} time
   * @returns
   * @memberof DataAnimation
   */


  _updateForTime(time) {
    if (!this.dataByTime()) return;
    if (!this.lastInterval) this.lastInterval = this.from;
    const interval = this.currentTime;
    if (interval === this.lastInterval) return;
    const from = Math.min(this.lastInterval, interval);
    const to = Math.max(this.lastInterval, interval); // let data = this._elementsInIntervalRange(from, to);

    let data;
    let remove = interval < this.lastInterval;

    if (interval === this.from) {
      // remove all items in range if we're restarting from the beginning
      remove = true;
      data = this._elementsInIntervalRange(this.from, this.to);
    } else {
      // otherwise get the elements within the new from/to range, unless we're removing in
      // which case we remove all elements within the `from` to bounds end
      data = this._elementsInIntervalRange(from, remove ? this.to : to);
    }

    if (data.length > 0) {
      if (remove) {
        const itemsToRemove = [].concat(this.itemsByTime[this.from]);
        itemsToRemove.forEach(item => {
          const index = data.indexOf(item);

          if (index !== -1) {
            data.splice(index, 1);
          }
        }); // add all elements that fall after end of timeline range so they get removed

        data = data.concat(this.dataBeyondBounds.after);
        this.trigger("data:remove"
        /* DATA_REMOVE */
        , {
          items: data.filter(item => item !== undefined)
        }); // eslint-disable-line max-len
      } else {
        this.trigger("data:add"
        /* DATA_ADD */
        , {
          items: data.filter(item => item !== undefined)
        }); // eslint-disable-line max-len
      }
    }

    this.lastInterval = interval;
  }

  restart() {
    this.lastInterval = this.to;
    super.restart();
  }
  /**
   * Resets the animation to its original state.
   *
   * All cached animation data will be removed and new data will have to be requested from the
   * data provider again when playback begins.
   *
   * @memberof DataAnimation
   */


  reset() {
    this.data = null;
    this.itemsByTime = {};
    super.reset();
  }
  /**
   * Returns whether the animation element is currently visible.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  isVisible() {
    return true;
  }
  /**
   * Returns whether the animation is ready for playback.
   *
   * A data animation is only ready once required data has been set.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  isReady() {
    return (0, _utils.isset)(this.data);
  }

  needsData() {
    return (0, _utils.isset)(this.data) === false;
  }
  /**
   * Returns whether the animation can animated based on whether or not data has been loaded
   * and already cached for playback.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  canAnimate() {
    const can = super.canAnimate();
    return can && this.dataByTime() && Object.keys(this.dataByTime()).length > 0;
  }
  /**
   * @ignore
   * Called when the animation `from` or `to` values have changed so that the animation intervals
   * can be recalculated and data processed into the corresponding time interval blocks.
   *
   * @protected
   * @memberof DataAnimation
   */


  _handleTimingChange() {
    if (this.data) {
      this._prepareDataItems(this.data);
    }
  }
  /**
   * @ignore
   * Prepares the data for animating by assigning each data element into the corresponding time
   * interval block.
   *
   * @protected
   * @param {*} items
   * @returns
   * @memberof DataAnimation
   */


  _prepareDataItems(items) {
    if (this.increment <= 0 || !(0, _utils.isArray)(items)) return;

    const intervals = this._prepareIntervals();

    const data = items;
    const timeKey = 'timestamp';
    this.dataBeyondBounds = {
      before: [],
      after: []
    }; // add data to interval arrays

    (data || []).forEach(item => {
      if ((0, _utils.has)(item, timeKey)) {
        const itemTime = (0, _utils.get)(item, timeKey);

        if (itemTime < this.from) {
          this.dataBeyondBounds.before.push(item);
        } else if (itemTime > this.to) {
          this.dataBeyondBounds.after.push(item);
        } else {
          const interval = this.dataIntervalClosestToTime(itemTime);

          if (itemTime < this.to && intervals[interval]) {
            intervals[interval].push(item);
          }
        }
      }
    });
    this.trigger("load:done"
    /* LOAD_DONE */
    );
    this.trigger("ready"
    /* READY */
    );
  }
  /**
   * @ignore
   * Calculates the time intervals required by the animation based on the animation time range
   * and step increment.
   *
   * @protected
   * @returns {{ [time: number]: any }}
   * @memberof DataAnimation
   */


  _prepareIntervals() {
    let time = this.from;
    const to = this.to; // setup intervals object and arrays

    const intervals = {};

    while (time < to) {
      intervals[Math.round(time)] = [];
      time += this.increment;
    }

    this.itemsByTime = intervals;
    return this.dataByTime();
  }
  /**
   * @ignore
   * Returns the data closest to the specified time interval.
   *
   * @protected
   * @param {number} time
   * @returns {number}
   * @memberof DataAnimation
   */


  dataIntervalClosestToTime(time) {
    const intervals = Object.keys(this.dataByTime()).sort().reverse().map(o => parseInt(o, 10)); // eslint-disable-line max-len

    let interval = 0;

    if (time < this.from || time > this.to) {
      interval = time;
    } else {
      intervals.forEach(value => {
        if (time >= value && interval === 0) {
          interval = value;
        }
      });
    } // the following will add data that falls before the start of the animation to the first
    // interval, which isn't necessarily what is wanted for now
    // if (interval === 0 && time < intervals[0]) {
    // 	interval = intervals[0];
    // }


    return interval;
  }
  /**
   * @ignore
   * Returns the data for the specified time range.
   *
   * @protected
   * @param {number} from
   * @param {number} to
   * @returns {any[]}
   * @memberof DataAnimation
   */


  _elementsInIntervalRange(from, to) {
    if (from === to) return [];
    let result = [];
    const intervals = Object.keys(this.dataByTime()).sort().map(o => parseInt(o, 10));
    const include = [];
    intervals.forEach(interval => {
      let add = false;

      if (to < from) {
        if (interval >= to && interval < from) {
          add = true;
        }
      } else if (interval === from && interval === to) {
        add = true;
      } else if (interval >= from && interval < to || interval === to) {
        add = true;
      } // make sure we aren't re-adding the same interval multiple times


      if (add && include.indexOf(interval) === -1) {
        include.push(interval);
        result = (result || []).concat(this.dataByTime()[interval]);
      }
    });
    return result;
  }

}

var _default = DataAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 237 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _TextAnimation = _interopRequireDefault(__webpack_require__(238));

var _MapElement = __webpack_require__(232);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class TextDataAnimator {
  constructor(source, opts) {
    this.source = source;
    const anim = new _TextAnimation.default();
    anim.provider = this;
    anim.on('data:add', e => source.trigger('markers:add', {
      markers: e.data.items
    }));
    anim.on('data:remove', e => source.trigger('markers:remove', {
      markers: e.data.items
    }));
    anim.on('data:update', e => source.trigger('markers:update', {
      markers: e.data.items
    }));
    this.animation = anim;
    source.on('data:load:start reset', () => {
      this._animationMarkers = null;
    });
  }
  /**
   * Requests data required for animating text values across an animation's time range. This data
   * set is usually different than that returned by `load()`.
   *
   * @returns A Promise containing the resulting marker data objects.
   */


  _loadAnimationData() {
    const source = this.source;
    return new Promise((resolve, reject) => {
      const limit = source.service.param('limit') || 300;
      const plimit = source.service.param('plimit');
      const sort = source.service.param('sort') || 'dt:-1';
      const style = source.style.marker || source.style;
      source.service.action("within"
      /* WITHIN */
      ).plimit(100).limit(limit).sort(sort).get().then(result => {
        source.service.plimit(plimit);
        const elements = {};
        const results = (0, _utils.get)(result, 'data') || [];

        if ((0, _utils.isArray)(results)) {
          // use existing marker references but use the multi-period data instead
          results.forEach(item => {
            const record = source.processRecord(item);
            const loc = record.loc || {};
            const coord = {
              lat: loc.lat,
              lon: loc.long || loc.lon
            };
            const id = record.id || `${coord.lat},${coord.long}`;
            const el = source.markersById ? source.markersById[id] : null;
            const itemStyle = (0, _utils.isFunction)(style) ? style(record) : style;

            if (el) {
              elements[id] = new _MapElement.MarkerMapElement((0, _utils.extend)({}, el.data, record), el.style, el.renderable);
            } else if ((0, _utils.isset)(itemStyle.spacing) === false) {
              const marker = source.strategy.factory.marker(source.key, {
                lat: coord.lat,
                lon: coord.lon
              }, itemStyle);
              elements[id] = new _MapElement.MarkerMapElement(Object.assign(Object.assign({}, record), {
                awxjs_source: source.key
              }), itemStyle, marker);
            }
          });
        }

        resolve(elements);
      }).catch(e => {
        console.error('Error requesting animation data for TextSource', e); // eslint-disable-line no-console

        reject(e);
      });
    });
  }
  /**
   * Animation Provider
   */


  animationData(animation) {
    return __awaiter(this, void 0, void 0, function* () {
      const source = this.source;

      const processAnimationData = () => {
        const markers = this._animationMarkers;
        const timeProp = ((0, _utils.get)(source.opts, 'data.properties.timestamp') || '').replace(/^periods\./, '');
        let valueProp = (0, _utils.get)(source.opts, 'data.properties.value');

        if (!(0, _utils.isFunction)(valueProp)) {
          valueProp = (valueProp || '').replace(/^periods\./, '');
        }

        const items = Object.keys(markers).reduce((result, id) => {
          const {
            data,
            renderable
          } = markers[id];

          if (data && data.periods) {
            let lastVal;
            const periods = data.periods.reduce((p, record) => {
              const ts = (0, _utils.get)(record, timeProp) * 1000;
              let val = '';

              if ((0, _utils.isFunction)(valueProp)) {
                val = valueProp(record);
              } else {
                val = (0, _utils.get)(record, valueProp);
              }

              if (val !== lastVal) {
                p[ts] = val;
                lastVal = val;
              }

              return p;
            }, {});
            result[id] = {
              data: periods,
              renderable,
              style: source.style
            };
            return result;
          }

          return null;
        }, {});
        return items;
      };

      const loadAnimationData = () => new Promise((resolve, reject) => {
        this._loadAnimationData().then(items => {
          this._animationMarkers = items;
          resolve(items);
        });
      });

      return new Promise((resolve, reject) => {
        if (!this._animationMarkers) {
          if (source.isLoading) {
            source.once('data:load', () => {
              loadAnimationData().then(items => {
                const result = processAnimationData();
                resolve(result);
              });
            });
          } else {
            loadAnimationData().then(items => {
              const result = processAnimationData();
              resolve(result);
            });
          }
        } else {
          const result = processAnimationData();
          resolve(result);
        }
      });
    });
  }

}

var _default = TextDataAnimator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 238 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DataAnimation = _interopRequireDefault(__webpack_require__(236));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `TextAnimation` object is a subclass of `DataAnimation` that is responsible for managing a
 * series of text annotations required for animation playback.
 */
class TextAnimation extends _DataAnimation.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof TextAnimation
   */
  constructor(opts = null) {
    opts = (0, _utils.extend)({}, {
      refresh: 0
    }, opts);
    super(opts);
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate data for the specifyed time interval.
   *
   * @protected
   * @param {*} time
   * @returns
   * @memberof TextAnimation
   */


  _updateForTime(time) {
    if (!this.dataByTime()) return;
    if (!this.lastInterval) this.lastInterval = this.from;
    const interval = this.currentTime; // if (interval === this.lastInterval) return;

    const from = Math.min(this.lastInterval, interval);
    const to = Math.max(this.lastInterval, interval);
    let elements; // if animation is restarting, we need to update all text elements with their initial value
    // so we need to grab the starting value by unique identifier to update the text values with

    if (interval < this.lastInterval) {
      const ids = [];
      const results = [];
      const intervals = Object.keys(this.dataByTime()).sort().map(o => parseInt(o, 10));
      intervals.forEach(t => {
        const items = this.dataByTime()[t];
        items.forEach(item => {
          if (ids.indexOf(item.id) === -1) {
            results.push(item);
            ids.push(item.id);
          }
        });
      });
      elements = results;
    } else {
      elements = this._elementsInIntervalRange(from, to);
    }

    if (elements.length > 0) {
      this.trigger("data:update"
      /* DATA_UPDATE */
      , {
        items: elements
      });
    }

    this.lastInterval = interval;
  }
  /**
   * @ignore
   * Prepares the data for animating by assigning each data element into the corresponding time
   * interval block.
   *
   * @protected
   * @param {*} items
   * @returns
   * @memberof TextAnimation
   */


  _prepareDataItems(items) {
    if (this.increment <= 0 || !(0, _utils.isPlainObject)(items)) return;

    const intervals = this._prepareIntervals();

    const data = items; // add data to interval arrays

    Object.keys(data).forEach(id => {
      const {
        renderable,
        data: item,
        style
      } = items[id];
      Object.keys(item).forEach(timestamp => {
        const ts = parseInt(timestamp, 10);
        const interval = this.dataIntervalClosestToTime(ts);

        if (ts < this.to && intervals[interval]) {
          intervals[interval].push({
            id,
            value: item[ts],
            renderable,
            style
          });
        }
      });
    });
    this.trigger("ready"
    /* READY */
    );
    this.trigger("load:done"
    /* LOAD_DONE */
    );
  }

}

var _default = TextAnimation;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 239 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _VectorSource = _interopRequireDefault(__webpack_require__(231));

var _FeatureCollection = _interopRequireDefault(__webpack_require__(205));

var Geo = _interopRequireWildcard(__webpack_require__(196));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(233);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `GeoJsonSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view from GeoJSON data.
 */
class GeoJsonSource extends _VectorSource.default {
  _process(data, parentId) {
    if (!this.strategy) throw new Error('No map strategy defined for VectorSource but one is required.');
    data = data || {};
    const dataFormatter = (0, _utils.get)(this.opts, 'data.formatter');

    if (dataFormatter) {
      data = dataFormatter(data);
    }

    const markers = {};
    const polygons = {};
    const polylines = {};

    if ((0, _utils.isArray)(data)) {
      if (data[0] && data[0].type === 'FeatureCollection') {
        data = data[0];
      } else {
        data = {
          type: 'FeatureCollection',
          features: data
        };
      }
    } // make sure final data is in the format of FeatureCollection for parsing


    if (data.type === 'Feature') {
      data = {
        type: 'FeatureCollection',
        features: [data]
      };
    } else if (data.type === 'GeometryCollection') {
      data = {
        type: 'FeatureCollection',
        features: (data.geometries || []).map(geometry => ({
          type: 'Feature',
          geometry
        }))
      };
    }

    if (!(0, _utils.isset)(data.type)) {
      console.warn(`Invalid data provided for GeoJsonSource with key ${this.key}, not a valid GeoJSON format`);
      return null;
    }

    const factory = this.strategy.factory;
    const collection = new _FeatureCollection.default(data);
    const {
      marker: markerStyle,
      polygon: polygonStyle,
      polyline: polylineStyle
    } = this.style; // convert features to map elements

    const features = collection.features || [];
    features.forEach((feature, featureIndex) => {
      const geometry = feature.geometry;
      const record = feature.properties || {};
      let group;
      const idKey = (0, _utils.get)(this.opts, 'data.properties.id');
      const groupKey = (0, _utils.get)(this.opts, 'data.properties.category'); // update id based on property if defined

      if ((0, _utils.isset)(idKey)) {
        feature.id = (0, _utils.get)(record, idKey);
      } // determine group the feature belongs in if defined


      if ((0, _utils.isset)(groupKey)) {
        group = (0, _utils.get)(record, groupKey);
        const groupData = (0, _utils.set)({}, groupKey, group);

        if (!polygons[group]) {
          polygons[group] = {
            data: Object.assign(Object.assign({}, groupData), {
              awxjs_source: this.key
            }),
            elements: []
          };
        }

        if (!polylines[group]) {
          polylines[group] = {
            data: Object.assign(Object.assign({}, groupData), {
              awxjs_source: this.key
            }),
            elements: []
          };
        }
      }

      record.id = `${this.key}`;

      if (feature.id) {
        record.id = `${record.id}-${feature.id}`;
      } else {
        record.id = `${record.id}-${featureIndex}`;
      }

      if (geometry instanceof Geo.Point) {
        const style = (0, _utils.isFunction)(markerStyle) ? markerStyle(record) : markerStyle;
        const result = (0, _utils2.generateMarker)(this.key, record, geometry.coordinates, style, factory);
        markers[record.id] = result;
      } else if (geometry instanceof Geo.MultiPoint) {
        geometry.coordinates.forEach((coord, index) => {
          const markerRecord = Object.assign(Object.assign({}, record), {
            id: `${record.id}-${index}`
          });
          const style = (0, _utils.isFunction)(markerStyle) ? markerStyle(markerRecord) : markerStyle;
          const result = (0, _utils2.generateMarker)(this.key, markerRecord, coord, style, factory);
          markers[record.id] = result;
        });
      } else if (geometry instanceof Geo.LineString) {
        const result = (0, _utils2.generatePolyline)(this.key, record, geometry.coordinates, polylineStyle, factory);

        if (group) {
          polylines[group].elements.push(result);
        } else {
          polylines[record.id] = result;
        }
      } else if (geometry instanceof Geo.MultiLineString) {
        geometry.coordinates.forEach((lineCoord, index) => {
          const elementRecord = Object.assign(Object.assign({}, record), {
            id: `${record.id}-${index}`
          });
          const result = (0, _utils2.generatePolyline)(this.key, elementRecord, lineCoord, polylineStyle, factory);

          if (group) {
            polylines[group].elements.push(result);
          } else {
            polylines[record.id] = result;
          }
        });
      } else if (geometry instanceof Geo.Polygon) {
        const result = (0, _utils2.generatePolygon)(this.key, record, geometry, polygonStyle, factory);

        if (group) {
          polylines[group].elements.push(result);
        } else {
          polygons[record.id] = result;
        }
      } else if (geometry instanceof Geo.MultiPolygon) {
        // geometry.polygons.forEach((polygon, index) => {
        // 	const elementRecord = {...record, id: `${record.id}-${index}`};
        // 	const result = this._generatePolygon(elementRecord, polygon, polygonStyle);
        // 	if (group) {
        // 		polygons[group].polygons.push(result);
        // 	} else {
        // 		polygons[result.id] = result;
        // 	}
        // });
        // const elementRecord = {...record, id: `${record.id}-${index}`};
        const result = (0, _utils2.generatePolygon)(this.key, record, geometry, polygonStyle, factory);

        if (group) {
          polylines[group].elements.push(result);
        } else {
          polygons[record.id] = result;
        }
      }
    });
    return {
      markers: Object.keys(markers).map(key => markers[key]),
      polygons: Object.keys(polygons).map(key => polygons[key]),
      polylines: Object.keys(polylines).map(key => polylines[key])
    };
  }

}

var _default = GeoJsonSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 240 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _TileDataAnimator = _interopRequireDefault(__webpack_require__(241));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `TileSource` is an abstract object that is responsible for managing a single tile layer on a map view and providing
 * additional functionality for the layer, such as controlling a layer's opacity and loading and running animations.
 *
 * This class is intended to be subclassed by each supported mapping strategy in order to configure the appropriate underlying
 * layer instance that is added to the strategy's map view.
 */
class TileSource extends _EventDispatcher.default {
  /**
   * Initializes a new tile source instance configured with the specified AMP layer code and tile url template string.
   *
   * @param {string} layer
   * @param {string} url
   * @param {TileSourceOptions} [opts]
   * @memberof TileSource
   */
  constructor(key, service, opts) {
    var _a;

    super();
    this.isAnimationFrame = false;
    this._hidden = false;
    this.key = key;
    this.enabled = true;
    opts = (0, _utils.extend)({
      id: undefined,
      type: 'tile',
      subdomains: ['1', '2', '3', '4'],
      time: 0,
      offset: undefined,
      opacity: 1.0,
      future: false,
      alwaysShow: false,
      animation: {
        enabled: true,
        type: 'tile'
      }
    }, opts);

    if (opts.time) {
      if (!(0, _utils.isDate)(opts.time) && (0, _utils.isNumber)(opts.time)) {
        opts.time = new Date(new Date().getTime() + opts.time);
      }
    } // disable animation if a static offset is defined


    if ((0, _utils.isset)(opts.offset)) {
      opts.animation.enabled = false;
    }

    if ((0, _utils.isset)(service)) {
      service.offset(0);
    }

    this.key = key;
    this._service = service;
    this._opts = opts;
    const style = opts.style || {};
    this._opacity = style.opacity || 1;
    const animationEnabled = ((_a = opts.animation) === null || _a === void 0 ? void 0 : _a.enabled) === true;

    if (animationEnabled) {
      const animationOpts = (0, _utils.extend)({
        key,
        type: 'tile',
        enabled: true,
        future: false,
        alwaysShow: false,
        showWhenStopped: false
      }, (0, _utils.pick)(opts, ['future', 'alwaysShow']), opts.animation);
      this._animator = new _TileDataAnimator.default(this, animationOpts);
    }

    this.on('overlay:ready', () => {
      this.timestamp = this._opts.time;
    });
    this._overlay = this.createOverlay(service, opts);
    this.trigger('overlay:ready');
  }
  /**
   * Identifier associated with the data source.
   *
   * @type {string}
   * @memberof TileSource
   */


  get identifier() {
    return this._opts.id || this.key;
  }

  set identifier(value) {
    this._opts.id = value;
  }
  /** Tile template URL */


  get url() {
    return this.service.url();
  }
  /** Underlying map layer instance that is added to a map view */


  get overlay() {
    return this._overlay;
  }
  /** Current timestamp to use when requesting tile data */


  get timestamp() {
    return this._timestamp;
  }

  set timestamp(value) {
    this._timestamp = value;
  }

  get service() {
    return this._service;
  }
  /**
   * Returns the animation associated with the static layer.
   */


  get animation() {
    var _a;

    return (_a = this._animator) === null || _a === void 0 ? void 0 : _a.animation;
  }
  /**
   * Returns the url template string to use for tile requests based on the current timestamp.
   */


  urlTemplate() {
    if ((0, _utils.isset)(this._opts.offset)) {
      this.service.offset(`${this._opts.offset}`.replace(/\s/g, ''));
    } else {
      // convert date to GMT for timestamp
      let date = new Date(this._timestamp);
      date = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
      this.service.offset((0, _utils.formatDate)(date, 'yyyyMMddHHmm00'));
    }

    return this.service.url();
  }

  isFuture() {
    return this._opts.future;
  }

  updateVisibility() {
    if (this.canShow()) {
      this.show();
    } else {
      this.hide();
    }
  }

  canShow() {
    const now = new Date().getTime();

    const time = this._timestamp.getTime();

    const delta = time - now;

    if (this._opts.alwaysShow) {
      return true;
    }

    return this.isFuture() && time > now || !this.isFuture() && time <= now;
  }

  isAnimationActive() {
    return this.animation && (this.animation.canAnimate() || this.animation.isAnimating());
  }

  isAnimating() {
    return this.animation && this.animation.isAnimating();
  }
  /**
   * Shows the tile layer.
   */


  show() {
    throw new Error('Implementation must override abstract `show`');
  }
  /**
   * Hides the tile layer.
   */


  hide() {
    throw new Error('Implementation must override abstract `hide`');
  }

  remove() {
    throw new Error('Implementation must override abstract `remove`');
  }
  /**
   * Returns whether the source is currently visible.
   *
   * @returns {boolean}
   * @memberof TileSource
   */


  isVisible() {
    return this._hidden === false;
  }
  /**
   * Updates the opacity of the tile layer.
   * @param value
   */


  setOpacity(value, update = true) {
    throw new Error('Implementation must override abstract `setOpacity:`');
  }
  /**
   * Updates the z-index order of the tile layer on the parent map view.
   * @param value
   */


  setOrder(value) {
    throw new Error('Implementation must override abstract `setOrder:`');
  }

  destroy() {
    this._overlay = null;
    this._service = null;
  }

  createOverlay(service, opts = {}) {
    return null;
  }
  /** Animation Provider */


  animationLayerForDate(animation, date, wait = true) {
    // throw new Error('Implementation must override abstract `animationLayerForDate:`');
    return null;
  }

}

var _default = TileSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 241 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ImageAnimation = _interopRequireDefault(__webpack_require__(224));

var _TileAnimation = _interopRequireDefault(__webpack_require__(223));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TileDataAnimator {
  constructor(source, opts) {
    this.source = source;
    const anim = opts.type === 'image' ? new _ImageAnimation.default(null, opts) : new _TileAnimation.default(opts);
    anim.provider = this;
    anim.on('stop reset', e => {
      anim.hide();
      source.updateVisibility();
    });

    if (opts.type === 'tile') {
      anim.on('load:progress', e => {
        if (anim.showWhenLoading) {
          source.hide();
        }
      }).on('play', e => {
        source.hide();
      });
      anim.on("advance:image"
      /* ADVANCE_IMAGE */
      , () => {});
    }

    this.animation = anim;
    source.on('overlay:ready', () => {
      if (anim instanceof _ImageAnimation.default || anim instanceof _TileAnimation.default) {
        anim.provider = this;
      }
    });
  }
  /** Animation Provider */


  animationLayerForDate(animation, date, wait = true) {
    return this.source.animationLayerForDate(animation, date, wait);
  }

}

var _default = TileDataAnimator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 242 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var Leaflet = _interopRequireWildcard(__webpack_require__(243));

var _SVG = __webpack_require__(252);

var _utils = __webpack_require__(251);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// /<reference path="../../../../../node_modules/@types/leaflet/index.d.ts" />

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class LeafletOverlayFactory
 * @implements {OverlayFactory}
 * @implements {PointDataSource}
 */
class LeafletOverlayFactory {
  /**
   * Returns a map tile source instance configured with the specified layer code and url template
   * string.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {OSMTileSource}
   * @memberof OSMOverlayFactory
   */
  tileLayer(layer, service, opts) {
    return new Leaflet.TileSource(layer, service, opts);
  }
  /**
   * Returns a map annotation instance at the provided coordinate and configured for the
   * specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Coordinate} coord
   * @param {IMarker} config
   * @returns {L.Marker}
   * @memberof OSMOverlayFactory
   */


  marker(layer, coord, style) {
    if (style) {
      // if skipped via the style, then return null
      if (style.skip && style.skip === true) {
        return null;
      }
    }

    return new Leaflet.Marker(coord, null, {
      style
    });
  }
  /**
   * Returns an annotation icon based on the provided configuration.
   *
   * @param {IMarker} config
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  markerIcon(style) {
    if (style.html) {
      return L.divIcon({
        html: style.html,
        iconSize: style.size,
        className: style.className || ''
      });
    }

    if (style.svg) {
      const [width, height] = style.size || [12, 12];
      return L.divIcon({
        html: _SVG.SVG.draw(width, height, style.svg),
        iconSize: style.size,
        className: style.className || ''
      });
    }

    if (style.icon) {
      const icon = style.icon;
      return L.icon({
        iconUrl: icon.url,
        iconRetinaUrl: icon.retinaUrl,
        iconSize: style.size,
        iconAnchor: icon.anchor,
        className: style.className || ''
      });
    }

    return null;
  }
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  polygon(layer, shapes, style) {
    // generate Leaflet options from config
    let opts;

    if (style) {
      opts = (0, _utils.formatLayerOptions)(style);
    }

    return new Leaflet.Polygon(layer, shapes, opts);
  }

  polyline(layer, points, style) {
    let opts;

    if (style) {
      opts = (0, _utils.formatLayerOptions)(style);
    }

    const p = points.map(point => [point.lat, point.lon]);
    return new Leaflet.Polyline(layer, p, opts);
  }

}

var _default = LeafletOverlayFactory;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 243 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Polygon", ({
  enumerable: true,
  get: function () {
    return _PolygonLayer.default;
  }
}));
Object.defineProperty(exports, "Polyline", ({
  enumerable: true,
  get: function () {
    return _PolylineLayer.default;
  }
}));
Object.defineProperty(exports, "Tile", ({
  enumerable: true,
  get: function () {
    return _TileLayer.default;
  }
}));
Object.defineProperty(exports, "Marker", ({
  enumerable: true,
  get: function () {
    return _Marker.default;
  }
}));
Object.defineProperty(exports, "TileSource", ({
  enumerable: true,
  get: function () {
    return _LeafletTileSource.default;
  }
}));

var _PolygonLayer = _interopRequireDefault(__webpack_require__(244));

var _PolylineLayer = _interopRequireDefault(__webpack_require__(247));

var _TileLayer = _interopRequireDefault(__webpack_require__(248));

var _Marker = _interopRequireDefault(__webpack_require__(249));

var _LeafletTileSource = _interopRequireDefault(__webpack_require__(253));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 244 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(245));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LeafletPolygonLayer extends _Layer.default {
  constructor(layer, polygons, opts = {}, id = undefined) {
    super(layer, opts, id);
    this.setOpacity(opts.fillOpacity);
    this._polygons = polygons;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.renderable) {
      // opacity gets applied to the original fill/stroke opacity separately
      this.renderable.setStyle(Object.assign(Object.assign({}, this.opts), {
        fillOpacity: this.opts.fillOpacity * value,
        opacity: this.opts.opacity * value
      }));
    }
  }

  addToMap(map, index) {
    this.renderable.off();
    this.renderable.on('click', () => this.trigger('click', {
      data: this.data,
      shape: this.renderable
    }));
    this.renderable.on('mouseover', () => this.trigger('mouseover', {
      data: this.data,
      shape: this.renderable
    }));
    this.renderable.on('mouseout', () => this.trigger('mouseout', {
      data: this.data,
      shape: this.renderable
    }));
    super.addToMap(map, index);
  }

  removeFromMap(map) {
    this.renderable.off();
    this.renderable.remove();
  }

  createRenderable() {
    const groups = []; // need to combine all polygon coordinate paths into a single grouped array for the multi
    // polygon layer

    this._polygons.forEach(shape => {
      const outer = shape.outer;
      const inner = shape.inner ? shape.inner : [];
      groups.push([outer, ...inner]);
    });

    return L.polygon(groups, Object.assign(Object.assign({}, this.opts), {
      fillOpacity: this.opts.fillOpacity * this.opacity,
      opacity: this.opts.opacity * this.opacity
    }));
  }

}

var _default = LeafletPolygonLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 245 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapLayer = _interopRequireDefault(__webpack_require__(246));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `LeafletLayer` is a container class that is responsible for creating and managing a Leaflet
 * layer representation on a Leaflet map.
 */
class LeafletLayer extends _MapLayer.default {
  invalidate() {}

  createRenderable() {
    return undefined;
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    if (this.renderable) {
      this.renderable.addTo(map);
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      this.renderable.remove();
    }
  }

}

var _default = LeafletLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 246 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `MapLayer` is a container class that is responsible for creating and managing a layer representation
 * on an interactive map.
 */
class MapLayer extends _EventDispatcher.default {
  constructor(layer, opts, id = undefined) {
    super();
    this._opacity = 1;
    this._hidden = false;
    this._events = ['click', 'mouseover', 'mouseout'];
    this._idPrefix = `aeriswx`;
    this.id = id || layer;
    this._opts = (0, _utils.cloneDeep)(opts);
    this._opacity = (0, _utils.isset)(opts.opacity) ? opts.opacity : 1;
  }

  get opts() {
    return this._opts;
  }
  /**
   * Layer identifier on the map.
   *
   * @readonly
   * @type {string}
   * @memberof MapLayer
   */


  get layerId() {
    const id = this.id ? `-${this.id}` : '';
    return `${this._idPrefix}${id}`;
  }
  /**
   * Map currently associated with the layer.
   *
   * @readonly
   * @type {Map}
   * @memberof MapLayer
   */


  get map() {
    return this._map;
  }
  /**
   * Native map object(s) that gets rendered to the map.
   *
   * @readonly
   * @type {S}
   * @memberof MapLayer
   */


  get renderable() {
    return this._renderable;
  }
  /**
   * Returns the current layer opacity.
   *
   * @readonly
   * @type {number}
   * @memberof MapLayer
   */


  get opacity() {
    return this._opacity;
  }
  /**
   * Returns whether the layer is currently hidden.
   *
   * @readonly
   * @type {boolean}
   * @memberof MapLayer
   */


  get isHidden() {
    return this._hidden;
  }
  /**
   * Adds the layer to the specified map.
   *
   * @param {Map} map
   * @param {number} index
   * @memberof MapLayer
   */


  addTo(map, index) {
    if (this.map === map) return;
    this._map = map;
    this._targetIndex = index;
    this._renderable = this.createRenderable();
    this.addToMap(map, index);
    this.trigger('map:add', {
      map,
      index
    });
  }
  /**
   * Removes the layer from the map it is currently active on.
   *
   * @returns
   * @memberof MapLayer
   */


  remove() {
    if (!this.map) return;
    this.removeFromMap(this.map);
    this._map = null;
    this.trigger('map:remove');
  }
  /**
   * Shows the layer on the map.
   *
   * @memberof MapLayer
   */


  show() {
    this._hidden = false;
    this.updateVisibility(true);
  }
  /**
   * Hides the layer on the map.
   *
   * @memberof MapLayer
   */


  hide() {
    this._hidden = true;
    this.updateVisibility(false);
  }
  /**
   * Changes the opacity of the layer.
   *
   * @param {number} value
   * @memberof MapLayer
   */


  setOpacity(value) {
    this._opacity = value;
  }

  setZIndex(index) {
    throw new Error('Subclasses of MapLayer should override setZIndex()');
  }
  /**
   * Returns whether the layer currently exists on the map.
   *
   * @returns {boolean}
   * @memberof MapLayer
   */


  exists() {
    const map = this.map;

    if (!map) {
      return false;
    }

    return false;
  }

}

var _default = MapLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 247 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(245));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */
class LeafletPolylineLayer extends _Layer.default {
  constructor(layer, points, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._points = points;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.renderable) {
      this.renderable.setStyle(Object.assign(Object.assign({}, this.opts), {
        opacity: value
      }));
    }
  }

  addToMap(map, index) {
    this.renderable.off();
    this.renderable.on('click', () => this.trigger('click', {
      data: this.data,
      shape: this.renderable
    }));
    this.renderable.on('mouseover', () => this.trigger('mouseover', {
      data: this.data,
      shape: this.renderable
    }));
    this.renderable.on('mouseout', () => this.trigger('mouseout', {
      data: this.data,
      shape: this.renderable
    }));
    super.addToMap(map, index);
  }

  removeFromMap(map) {
    this.renderable.off();
    this.renderable.remove();
  }

  createRenderable() {
    return L.polyline(this._points, Object.assign(Object.assign({}, this.opts), {
      opacity: this.opacity
    }));
  }

}

var _default = LeafletPolylineLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 248 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(245));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */
class LeafletTileLayer extends _Layer.default {
  constructor(layer, service, opts = undefined, id = undefined) {
    super(layer, opts, id);
    this._service = service;
  }
  /**
   * Updates the tile or image url for the layer.
   *
   * @param {string} url
   * @memberof TileLayer
   */


  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }

  setOpacity(value) {
    super.setOpacity(value);
    this.renderable.setOpacity(value);
  }

  setZIndex(index) {
    this.renderable.setZIndex(index);
  }

  updateVisibility(visible) {
    if (this.renderable) {
      this.renderable.setOpacity(visible ? this.opacity : 0);
    }
  }

  createRenderable() {
    const service = this._service;
    const overlay = L.tileLayer(service.url(), (0, _utils.extend)({}, this.opts, {
      subdomains: service.range().join('')
    })); // overlay.on('add', () => {
    // 	this._exists = true;
    // }).on('remove', () => {
    // 	this._exists = false;
    // });

    return overlay;
  }

}

var _default = LeafletTileLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 249 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _MapMarker = _interopRequireDefault(__webpack_require__(250));

var _utils2 = __webpack_require__(251);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */
class LeafletMarker extends _MapMarker.default {
  update(opts) {
    var _a;

    if (!(0, _utils.isset)(opts)) return;
    const value = (_a = opts.data) === null || _a === void 0 ? void 0 : _a.value;
    let style = opts.style || {};

    if ((0, _utils.isFunction)(style)) {
      style = style({
        value
      });
    }

    this.setStyle(style);
  }

  setStyle(style) {
    const icon = (0, _utils2.markerIconFromStyle)(style);

    if (icon) {
      this.renderable.setIcon(icon);
    }
  }

  createRenderable() {
    const {
      style
    } = this.opts;
    const coord = this.coordinate;
    const opts = {};

    if (style) {
      opts.icon = (0, _utils2.markerIconFromStyle)(style);

      if (style.zIndex) {
        opts.zIndexOffset = style.zIndex;
      }
    }

    const renderable = L.marker([coord.lat, coord.lon], opts);

    if (style.callout) {
      let content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        const fn = style.callout;
        content = fn();
      }

      const popup = L.popup().setContent(content);
      renderable.bindPopup(popup);
    }

    return renderable;
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    this.renderable.off();
    this.renderable.on('click', () => this.trigger('click', {
      data: this.data,
      marker: this.renderable
    }));
    this.renderable.on('mouseover', () => this.trigger('mouseover', {
      data: this.data,
      marker: this.renderable
    }));
    this.renderable.on('mouseout', () => this.trigger('mouseout', {
      data: this.data,
      marker: this.renderable
    }));
    this.renderable.addTo(map);
  }

  removeFromMap(map) {
    this.renderable.off();
    this.renderable.remove();
  }

}

var _default = LeafletMarker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 250 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `MapMarker` is a container class that is responsible for creating and managing a map marker
 * representation on an interactive map.
 */
class MapMarker extends _EventDispatcher.default {
  constructor(coord, data, opts, id = undefined) {
    super();
    this._hidden = false;
    this._events = ['click', 'mouseover', 'mouseout'];
    this.id = id;
    this.coordinate = coord;
    this.data = data;
    this.opts = Object.assign({}, opts);
  }
  /**
   * Map currently associated with the marker.
   *
   * @readonly
   * @type {Map}
   * @memberof MapMarker
   */


  get map() {
    return this._map;
  }
  /**
   * Native map object(s) that gets rendered to the map.
   *
   * @readonly
   * @type {S}
   * @memberof MapMarker
   */


  get renderable() {
    return this._renderable;
  }
  /**
   * Returns whether the marker is currently hidden.
   *
   * @readonly
   * @type {boolean}
   * @memberof MapMarker
   */


  get isHidden() {
    return this._hidden;
  }
  /**
   * Adds the marker to the specified map.
   *
   * @param {Map} map
   * @param {number} index
   * @memberof MapMarker
   */


  addTo(map, index) {
    if (this.map === map) return;
    this._map = map;

    if (!this._renderable) {
      this._renderable = this.createRenderable();
    }

    this.addToMap(map, index);
    this.trigger('map:add', {
      map,
      index
    });
  }
  /**
   * Removes the marker from the map it is currently active on.
   *
   * @returns
   * @memberof MapMarker
   */


  remove() {
    if (!this.map) return;
    this.removeFromMap(this.map);
    this._map = null;
    this.trigger('map:remove');
  }

  update(opts) {}

  setStyle(style) {}

  invalidate() {
    const map = this.map;
    this.remove();
    this._renderable = this.createRenderable();
    this.addTo(map);
  }

}

var _default = MapMarker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 251 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.markerIconFromStyle = exports.formatLayerOptions = void 0;

var _SVG = __webpack_require__(252);

var _utils = __webpack_require__(17);

const formatLayerOptions = opts => {
  const formatted = {
    stroke: false,
    fill: false
  };

  if (opts.stroke) {
    formatted.stroke = true;
    formatted.color = opts.stroke.color;
    formatted.opacity = opts.stroke.opacity;
    formatted.weight = opts.stroke.width;
    formatted.lineCap = opts.stroke.lineCap;
    formatted.lineJoin = opts.stroke.lineJoin;
    formatted.dashArray = opts.stroke.dashArray;
    formatted.dashOffset = opts.stroke.dashOffset;
  }

  if (opts.fill) {
    formatted.fill = true;
    formatted.fillColor = opts.fill.color;
    formatted.fillOpacity = opts.fill.opacity;
    formatted.fillRule = opts.fill.rule || 'nonzero';
  }

  if (formatted.fill && !(0, _utils.isset)(opts.fillOpacity)) opts.fillOpacity = 1;
  if (formatted.stroke && !(0, _utils.isset)(opts.strokeOpacity)) opts.strokeOpacity = 1;
  return formatted;
};

exports.formatLayerOptions = formatLayerOptions;

const markerIconFromStyle = style => {
  if (style.html) {
    return L.divIcon({
      html: style.html,
      iconSize: style.size,
      className: style.className || ''
    });
  }

  if (style.svg) {
    const [width, height] = style.size || [12, 12];
    return L.divIcon({
      html: _SVG.SVG.draw(width, height, style.svg),
      iconSize: style.size,
      className: style.className || ''
    });
  }

  if (style.icon) {
    const icon = style.icon;
    return L.icon({
      iconUrl: icon.url,
      iconRetinaUrl: icon.retinaUrl,
      iconSize: style.size,
      iconAnchor: icon.anchor,
      className: style.className || ''
    });
  }

  return null;
};

exports.markerIconFromStyle = markerIconFromStyle;

/***/ }),
/* 252 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVG = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
 */
const getPosition = (pos, size, container, translate) => {
  let x = 0;
  let y = 0;
  translate = (0, _utils.extend)({
    x: 0,
    y: 0
  }, translate);

  if ((0, _utils.isString)(pos)) {
    const anchor = pos;
    x = (container.width - size.width) / 2;
    y = (container.height - size.height) / 2;

    if (/^top/.test(anchor)) {
      y = 0;
    } else if (/^bottom/.test(anchor)) {
      y = container.height - size.height;
    }

    if (/left$/.test(anchor)) {
      x = 0;
    } else if (/right$/.test(anchor)) {
      x = container.width - size.width;
    }
  } else {
    const p = pos;
    x = p.x;
    y = p.y;
  }

  x += translate.x;
  y += translate.y;
  return {
    x,
    y
  };
};
/**
 * @private
 */


const getStyleAttributes = opts => {
  const strokeOpts = opts.stroke ? Object.keys(opts.stroke).reduce((value, key) => {
    const val = opts.stroke[key];

    if ((0, _utils.isset)(val)) {
      if (key === 'width') value += ` stroke-width="${val}"`;
      if (key === 'color') value += ` stroke="${val}"`;
      if (key === 'opacity') value += ` stroke-opacity="${val}"`;
    }

    return value;
  }, '') : '';
  const fillOpts = opts.fill ? Object.keys(opts.fill).reduce((value, key) => {
    const val = opts.fill[key];

    if ((0, _utils.isset)(val)) {
      if (key === 'color') value += ` fill="${val}"`;
      if (key === 'opacity') value += ` fill-opacity="${val}"`;
    }

    return value;
  }, '') : '';
  return fillOpts || strokeOpts ? `${fillOpts}${strokeOpts}` : '';
};
/**
 * The `SVG` module provides utility functions for generating the necessary HTML for various SVG
 * elements based on certain configurations and styles.
 */


var SVG;
exports.SVG = SVG;

(function (SVG) {
  SVG.calculateTextSize = (str, fontSize, fontStyle, padding) => {
    let width = 0;
    let height = 0;
    padding = padding || [0, 0];
    fontSize = fontSize || 12; // calculate bounding box of actual text if we have a document object

    if (window && window.document) {
      const doc = window.document;
      const el = doc.createElement('text');
      el.style.fontSize = (0, _utils.isString)(fontSize) ? `${fontSize}` : `${fontSize}px`;
      el.style.fontWeight = fontStyle || 'normal';
      el.style.visibility = 'hidden';
      el.innerHTML = str;
      doc.body.appendChild(el);
      const bbox = el.getBoundingClientRect();
      doc.body.removeChild(el);

      if (bbox.width > 0) {
        width = bbox.width;
      }

      if (bbox.height > 0) {
        height = bbox.height;
      }
    } // adjust size by text padding amounts


    const [ph, pv] = padding;
    width += ph * 2;
    height += pv * 2;
    return [width, height];
  };
  /**
   * Returns the SVG path string using the specified path value string and style options.
   *
   * @param {string} value
   * @param {SVGPathOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.path = (value, opts) => {
    opts = (0, _utils.extend)({
      stroke: {
        opacity: 1
      },
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    const attr = getStyleAttributes(opts);
    return `<g${opts.transform ? ` transform="${opts.transform}"` : ``}><path d="${value}"${attr} /></g>`;
  };
  /**
   * Returns the SVG rectangle string for the specified width, height and style options.
   *
   * @param {number} width
   * @param {number} height
   * @param {SVGRectOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.rect = (width, height, opts) => {
    opts = (0, _utils.extend)({
      margin: 0,
      radius: 0,
      stroke: null,
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    const {
      margin,
      radius
    } = opts;
    let offset = margin;

    if (opts.stroke && opts.stroke.width > 0) {
      offset += opts.stroke.width / 2;
      width -= opts.stroke.width;
      height -= opts.stroke.width;
    }

    let p = `M${offset + radius},${offset} `;
    p += `L${offset + width - radius},${offset} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset + width},${offset + radius} `;
    p += `L${offset + width},${offset + height - radius} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset + width - radius},${offset + height} `;
    p += `L${offset + radius},${offset + height} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset},${offset + height - radius} `;
    p += `L${offset},${offset + radius} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset + radius},${offset} `;
    p += 'Z';
    return SVG.path(p, opts);
  };
  /**
   * Returns the SVG circle string for the specified style options.
   *
   * @param {SVGCircleOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.circle = (container, opts) => {
    opts = (0, _utils.extend)({
      position: 'center',
      translate: {
        x: 0,
        y: 0
      },
      radius: 0,
      stroke: null,
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    const radius = opts.radius || 8;
    const size = (radius + ((0, _utils.get)(opts, 'stroke.width') || 0) + 1) * 2;
    const pos = getPosition(opts.position, {
      width: size,
      height: size
    }, container, opts.translate);
    const attr = getStyleAttributes(opts); // shift position values to the center

    pos.x += size / 2;
    pos.y += size / 2;
    return `<circle${opts.transform ? ` transform="${opts.transform}"` : ``} cx="${pos.x}" cy="${pos.y}" r="${opts.radius}"${attr} />`;
  };
  /**
   * Returns the SVG text string for the specified value and style options.
   *
   * @param {string | number} value
   * @param {SVGTextOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.text = (value, container, opts) => {
    opts = (0, _utils.extend)({
      position: 'center',
      translate: {
        x: 0,
        y: 0
      },
      anchor: 'start',
      size: 12,
      font: "'Helvetica','Arial',sans-serif",
      style: 'bold',
      color: '#222222'
    }, opts);
    value = value || opts.value;
    const [w, h] = SVG.calculateTextSize(`${value}`, opts.size, opts.style, opts.padding); // svg text is positioned relative to the baseline, so add the height to the vertical translate value
    // opts.translate.x += 1;

    opts.translate.y += h - 1;
    const pos = getPosition(opts.position, {
      width: w,
      height: h
    }, container, opts.translate);
    let content = '';

    if (opts.stroke) {
      const {
        color = '#333333',
        width = 2
      } = opts.stroke;
      content += `<text${opts.transform ? ` transform="${opts.transform}"` : ``} dominent-baseline="hanging" text-anchor="${opts.anchor}" x="${pos.x}" y="${pos.y}" style="font-family:${opts.font};font-size:${opts.size}px;font-weight:${opts.style};" stroke="${color}" stroke-width="${width}">${value || ''}</text>`; // eslint-disable-line max-len
    }

    content += `<text${opts.transform ? ` transform="${opts.transform}"` : ``} dominent-baseline="hanging" text-anchor="${opts.anchor}" x="${pos.x}" y="${pos.y}" style="font-family:${opts.font};font-size:${opts.size}px;font-weight:${opts.style};" fill="${opts.color}">${value || ''}</text>`; // eslint-disable-line max-len

    return content;
  };

  SVG.image = (url, container, opts) => {
    opts = (0, _utils.extend)({
      position: 'center',
      size: [30, 30]
    }, opts);
    url = url || opts.url;
    const [w, h] = opts.size;
    const pos = getPosition(opts.position, {
      width: w,
      height: h
    }, container, opts.translate);
    const [width, height] = opts.size;
    return `<image${opts.transform ? ` transform="${opts.transform}"` : ``} x="${pos.x}" y="${pos.y}" width="${width}" height="${height}" xlink:href="${url}" />`;
  };
  /**
   * Returns the SVG HTML string for the specified options and array of drawable elements.
   *
   * @param {number} width
   * @param {number} height
   * @param {string[]} elements
   * @param {string} [viewBox]
   * @returns {string}
   * @memberof SVG
   */


  SVG.svg = (width, height, elements, viewBox = null) => // eslint-disable-line max-len
  `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="${width}" height="${height}"${viewBox ? ` viewBox="${viewBox}"` : ''}>
			${(elements || []).map(el => el).join('')}
		</svg>`;
  /**
   * Returns the SVG HTML string using the specified size and options.
   *
   * @param {number} width
   * @param {number} height
   * @param {any} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.draw = (width, height, opts) => {
    const {
      value
    } = opts;
    let allow = true;
    let requiresText = false;
    const {
      shape: shapeOpts,
      text: textOpts,
      image: imageOpts
    } = opts;
    let elements = []; // setup text element first if defined so we can adjust shape sizing as needed

    const textElements = [];

    if (textOpts) {
      const generateTextEl = (textValue, config) => {
        const val = textValue || config.value || '';
        const x = config.x || 0;
        const y = config.y || 0;
        const size = config.size || 12;
        const [w, h] = SVG.calculateTextSize(val, size, config.style, config.padding);
        const autoSize = (0, _utils.isset)(config.autosize) ? config.autosize : true; // don't allow this element if the text value is empty

        if ((0, _utils.isEmpty)(val)) return null;

        if (autoSize) {
          // update width and height if we have text to display
          if (w && h) {
            width = w;
            height = h;
          } else {
            width = 5 * val.length;
            height = size + 2;
          }
        }

        let offset = 0;

        if (shapeOpts && shapeOpts.stroke) {
          offset = shapeOpts.stroke.width / 2 || 0;
        }

        const element = SVG.text(val, {
          width,
          height
        }, (0, _utils.extend)(config, {
          x: offset + width / 2 + x,
          y: offset + Math.round(height - (height - size * 0.7) / 2) + y
        }));
        return element;
      };

      if ((0, _utils.isArray)(textOpts)) {
        textOpts.forEach(config => {
          const el = generateTextEl(value, config);
          if (el) textElements.push(el);
        });
      } else {
        const el = generateTextEl(value, textOpts);
        if (el) textElements.push(el);
      }

      if (textElements.length > 0) {
        requiresText = true;
      }
    }

    if (shapeOpts) {
      let w = width;
      let h = height;
      const {
        type,
        size
      } = shapeOpts;

      if (size && size.length === 2) {
        w = size[0];
        h = size[1];
      }

      if (type === 'rect') {
        const shape = SVG.rect(w, h, shapeOpts);
        elements.push(shape);
      } else if (type === 'path') {
        const shape = SVG.path((0, _utils.get)(shapeOpts, 'path'), shapeOpts);
        elements.push(shape);
      } else {
        const strokeWidth = (0, _utils.get)(shapeOpts, 'stroke.width') || 0;
        shapeOpts.radius = Math.floor((w - strokeWidth * 2) / 2);
        shapeOpts.center = {
          x: Math.round(w / 2) + 1,
          y: Math.round(h / 2) + 1
        };
        const shape = SVG.circle({
          width,
          height
        }, shapeOpts);
        elements.push(shape);
      }
    }

    if (imageOpts) {
      const url = imageOpts.url;

      if (url) {
        const x = imageOpts.x || 0;
        const y = imageOpts.y || 0;
        const center = {
          x: width / 2,
          y: height / 2
        };
        const [w, h] = imageOpts.size || [30, 30];
        const imageEl = SVG.image(url, {
          width,
          height
        }, (0, _utils.extend)(imageOpts, {
          x: center.x - w / 2 + x,
          y: center.y - h / 2 + y
        }));
        elements.push(imageEl);
      }
    }

    if (textElements.length > 0) {
      elements = elements.concat(textElements);
    } else if (requiresText) {
      allow = false;
    }

    return allow ? SVG.svg(width, height, elements, opts.viewBox) : null;
  };
})(SVG || (exports.SVG = SVG = {}));

/***/ }),
/* 253 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _TileSource = _interopRequireDefault(__webpack_require__(240));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `LeafletTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `LeafletMapStrategy`.
 *
 * @export
 * @class LeafletTileSource
 * @extends {TileSource}
 */
class LeafletTileSource extends _TileSource.default {
  constructor() {
    super(...arguments);
    this._visible = true;
    this._exists = false;
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        this.animation.hide();
        this.updateVisibility();
      }

      if (this.overlay && this.canShow()) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof LeafletTileSource
   */


  show() {
    if (this._hidden === false) return;
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof LeafletTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.setOpacity(0);
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof LeafletTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof LeafletTileSource
   */


  setOpacity(value, update = true) {
    this._opacity = value;

    if (this.overlay && this.isVisible() && update === true) {
      this.overlay.setOpacity(value);
    }

    if (this.animation) {
      this.animation.setOpacity(value);
    }
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof LeafletTileSource
   */


  setOrder(value) {
    this.overlay.setZIndex(value);
  }

  createOverlay(service, opts = {}) {
    const overlay = L.tileLayer(service.url(), (0, _utils.extend)({}, opts, {
      subdomains: service.range().join('')
    }));
    overlay.on('add', () => {
      this._exists = true;
    }).on('remove', () => {
      this._exists = false;
    });
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          opacity: 0,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, false);
        source.hide();

        if (wait) {
          source.overlay.on('load', () => {
            resolve(source);
          });
        } else {
          resolve(source);
        }

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = LeafletTileSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 254 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.loadMapModuleConfig = exports.renderWithFallback = exports.isMapsGLLayer = exports.isOpenLayers = exports.isGoogle = exports.isMaplibre = exports.isMapbox = exports.isLeaflet = exports.isCoordObject = exports.mapTimestampFromDate = void 0;

var _AerisWeather = __webpack_require__(13);

var _utils = __webpack_require__(17);

/* eslint-disable spaced-comment */
/// <reference path="../../node_modules/@types/leaflet/index.d.ts" />
/// <reference path="../../node_modules/@types/mapbox-gl/index.d.ts" />
/// <reference path="../../node_modules/@types/googlemaps/index.d.ts" />
/// <reference path="../../node_modules/@types/openlayers/index.d.ts" />
/// <reference path="../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */
const mapTimestampFromDate = date => {
  const gmtDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
  return (0, _utils.formatDate)(gmtDate, 'yyyyMMddHHmm00');
};

exports.mapTimestampFromDate = mapTimestampFromDate;

const isCoordObject = value => {
  if ((0, _utils.isPlainObject)(value)) {
    const {
      lat,
      lon
    } = value;
    return (0, _utils.isset)(lat) && (0, _utils.isset)(lon);
  }

  return false;
};

exports.isCoordObject = isCoordObject;

const isLeaflet = value => {
  if (value) {
    const hasMapProp = (0, _utils.has)(value, 'openPopup');

    if (typeof L !== 'undefined' && (value instanceof L.map || value instanceof L.Map) && hasMapProp) {
      return true;
    }

    if (!(0, _utils.isHTMLElement)(value) && hasMapProp) {
      return true;
    }
  }

  return false;
};

exports.isLeaflet = isLeaflet;

const isMapbox = value => {
  if (value) {
    const hasMapProp = (0, _utils.has)(value, 'queryRenderedFeatures');

    if (typeof mapboxgl !== 'undefined' && value instanceof mapboxgl.Map && hasMapProp) {
      return true;
    }

    if (!(0, _utils.isHTMLElement)(value) && hasMapProp) {
      return true;
    }
  }

  return false;
};

exports.isMapbox = isMapbox;

const isMaplibre = value => {
  if (value) {
    const hasMapProp = (0, _utils.has)(value, 'queryRenderedFeatures');

    if (typeof maplibregl !== 'undefined' && value instanceof maplibregl.Map && hasMapProp) {
      return true;
    }

    if (!(0, _utils.isHTMLElement)(value) && hasMapProp) {
      return true;
    }
  }

  return false;
};

exports.isMaplibre = isMaplibre;

const isGoogle = value => {
  if (value) {
    const hasMapProp = (0, _utils.has)(value, 'getStreetView');

    if (typeof google !== 'undefined' && value instanceof google.maps.Map && hasMapProp) {
      return true;
    }

    if (!(0, _utils.isHTMLElement)(value) && hasMapProp) {
      return true;
    }
  }

  return false;
};

exports.isGoogle = isGoogle;

const isOpenLayers = value => {
  if (value) {
    const hasMapProp = (0, _utils.has)(value, 'forEachFeatureAtPixel');

    if (typeof ol !== 'undefined' && value instanceof ol.Map && hasMapProp) {
      return true;
    }

    if (!(0, _utils.isHTMLElement)(value) && hasMapProp) {
      return true;
    }
  }

  return false;
};

exports.isOpenLayers = isOpenLayers;

const isMapsGLLayer = value => /^mapsgl__/.test(value) || /^mapsgl::/.test(value);

exports.isMapsGLLayer = isMapsGLLayer;

const renderWithFallback = (renderer, data, fallback = '') => {
  if (renderer && (0, _utils.isset)(data) && !(0, _utils.isEmpty)(data)) {
    return renderer(data);
  }

  return fallback;
};

exports.renderWithFallback = renderWithFallback;

const loadMapModuleConfig = (namespace, callback) => {
  (0, _AerisWeather.modulesLoader)().then(modules => {
    const module = (0, _utils.get)(modules, namespace);

    if (module) {
      module().then(Module => {
        Module = Module.default || Module;
        const result = new Module();
        callback(result.id, result.source(), result);
      });
    }
  });
};

exports.loadMapModuleConfig = loadMapModuleConfig;

/***/ }),
/* 255 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapStrategy = _interopRequireDefault(__webpack_require__(228));

var Mapbox = _interopRequireWildcard(__webpack_require__(256));

var _MapboxOverlayFactory = _interopRequireDefault(__webpack_require__(264));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */
const MAPBOX_VERSION = '2.0.0';
/**
 * A map strategy for working with the third-party Mapbox GL mapping library.
 *
 * @export
 * @class MapboxMapStrategy
 * @extends {EventDispatcher}
 * @implements {MapStrategy}
 */

class MapboxMapStrategy extends _MapStrategy.default {
  constructor(target, opts) {
    super(target, (0, _utils.extend)({
      accessToken: null,
      style: 'mapbox://styles/mapbox/streets-v9'
    }, opts));
    this._pointAnimationUpdates = {};
    this._shapeDataById = {};
    this._clickedMapLayer = false;
  }

  get strategy() {
    return 'mapbox';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getContainer());
  }

  loadDependencies() {
    const css = document.createElement("style");
    css.innerHTML = '.mapboxgl-marker { line-height: 0; }';
    window.document.body.appendChild(css);
    return new Promise((resolve, reject) => {
      if (typeof mapboxgl === 'undefined' || typeof mapboxgl.Map === 'undefined') {
        Promise.all([(0, _utils.loadStyles)(`https://api.tiles.mapbox.com/mapbox-gl-js/v${MAPBOX_VERSION}/mapbox-gl.css`), (0, _utils.loadScript)(`https://api.tiles.mapbox.com/mapbox-gl-js/v${MAPBOX_VERSION}/mapbox-gl.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _MapboxOverlayFactory.default();
    this._eventMapping = {
      load: 'load',
      remove: 'unload',
      resize: 'resize',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      move: 'move',
      movestart: 'move:start',
      moveend: 'move:end'
    };
    const mbversion = mapboxgl.version;

    if (mbversion) {
      let [major, minor] = mbversion.split('.');
      major = parseInt(major, 10);
      minor = parseInt(minor, 10);

      if (major === 0 && minor < 50) {
        throw new Error(`AerisWeather SDK requires Mapbox GL JS version 0.50.0 or higher. You are using version ${mbversion}.`);
      }
    } // set view properties from native map options if defined


    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if (center && (0, _utils.isArray)(center)) {
        const [lon, lat] = center;

        if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
          (0, _utils.set)(this.opts, 'center', {
            lat,
            lon
          });
        }
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of mapboxgl.Map
    // if mapboxgl.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isMapbox)(target)) {
      this._setInitialView = false;
      this._map = target;
      setTimeout(() => {
        this.trigger('map:ready');
      }, 250);
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      mapboxgl.accessToken = this.opts.accessToken;
      this._map = new mapboxgl.Map((0, _utils.extend)({}, this.opts.map, {
        container: target,
        style: this.opts.style
      }));
      this._currentMapStyle = this.opts.style;
      const controls = new mapboxgl.NavigationControl();

      this._map.addControl(controls, 'bottom-left');

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }

      this.map.on('load', () => {
        setTimeout(() => {
          this.trigger('map:ready');
        }, 250);
      });
    }
  }
  /**
   * Updates the base map style using a Mapbox style URL.
   *
   * @param {string} style
   * @returns
   * @memberof MapboxMapStrategy
   */


  setBaseStyle(style) {
    if (style === this._currentMapStyle) return;
    const map = this.map; // grab the existing style and cache all Aeris-related sources and layers
    // so they can be re-added after changing the map style

    const mapStyle = map.getStyle();
    const aerisLayers = mapStyle.layers.filter(layer => /^aeris-/.test(layer.id));
    const aerisSources = Object.keys(mapStyle.sources).filter(key => /^aeris-/.test(key)).reduce((prev, result) => {
      prev[result] = mapStyle.sources[result];
      return prev;
    }, {}); // need to wait for the new style to load before re-adding the previous map data

    map.on('style.load', () => {
      Object.keys(aerisSources).forEach(key => {
        const existing = map.getSource(key);

        if (!existing) {
          map.addSource(key, aerisSources[key]);
        }
      });
      aerisLayers.forEach(layer => {
        const existing = map.getLayer(layer.id);

        if (!existing) {
          map.addLayer(layer);
        }
      });
    }); // update the map style

    map.setStyle(style, {
      diff: true
    });
  }

  setView(center, zoom) {
    this.map.jumpTo({
      center: {
        lat: center.lat,
        lon: center.lon
      },
      zoom: Math.max(1, zoom - 1)
    });
  }

  getCenter() {
    const coord = this._map.getCenter();

    return {
      lat: coord.lat,
      lon: coord.lng
    };
  }

  setCenter(coord) {
    this._map.setCenter({
      lat: coord.lat,
      lon: coord.lon
    });
  }

  getZoom() {
    return this._map.getZoom() + 1;
  }

  setZoom(zoom) {
    this._map.setZoom(Math.max(0, zoom - 1));
  }

  getBounds() {
    const b = this.map.getBounds();
    return {
      north: b.getNorth(),
      west: b.getWest(),
      south: b.getSouth(),
      east: b.getEast()
    };
  }

  setBounds(bounds) {
    const sw = new mapboxgl.LngLat(bounds.west, bounds.south);
    const ne = new mapboxgl.LngLat(bounds.east, bounds.north);
    this.map.fitBounds(new mapboxgl.LngLatBounds(sw, ne));
  }

  fitBounds(bounds, padding = [10, 10]) {
    const sw = new mapboxgl.LngLat(bounds.west, bounds.south);
    const ne = new mapboxgl.LngLat(bounds.east, bounds.north);
    const b = new mapboxgl.LngLatBounds(sw, ne);
    const opts = {};

    if (padding.length === 1) {
      opts.padding = padding[0];
    } else if (padding.length === 2) {
      opts.padding = {
        top: padding[1],
        right: padding[0],
        bottom: padding[1],
        left: padding[0]
      };
    } else if (padding.length === 4) {
      opts.padding = {
        top: padding[0],
        right: padding[1],
        bottom: padding[2],
        left: padding[3]
      };
    }

    this.map.fitBounds(b, opts);
  }
  /** Sources */


  isTile(source) {
    return source instanceof Mapbox.TileSource;
  }

  isMarker(el) {
    if (el === null || el === void 0 ? void 0 : el.renderable) {
      return el.renderable instanceof mapboxgl.Marker;
    }

    return el instanceof mapboxgl.Marker;
  }

  isPolygon(el) {
    return el instanceof Mapbox.Polygon;
  }

  isPolyline(el) {
    return el instanceof Mapbox.Polyline;
  }

  addSource(source) {
    super.addSource(source);

    if (this.isTile(source)) {
      source.updateVisibility();
    }
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof Mapbox.Tile) {
      overlay.addTo(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof Mapbox.Tile) {
      overlay.remove();
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Mapbox.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof mapboxgl.Marker) {
      marker.addTo(this.map);
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof Mapbox.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof mapboxgl.Marker) {
      marker.remove();
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!(0, _utils.isset)(options)) return;

    if (marker instanceof Mapbox.Marker) {
      marker.update(options);
    }
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Mapbox.Polygon || shape instanceof Mapbox.Polyline) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
      this._shapeDataById[shape.id] = data; // this._renderableEvents.forEach((name) => {
      // 	shape.on(name, () => {
      // 		if (name === 'click') {
      // 			this._clickedMapLayer = true;
      // 			setTimeout(() => {
      // 				this._clickedMapLayer = false;
      // 			}, 100);
      // 		}
      // 		this.trigger(`shape:${name}`, { data, shape })
      // 	});
      // });
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Mapbox.Polygon || shape instanceof Mapbox.Polyline) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.show();
      return;
    }

    super.showShape(shape);
  }

  hideShape(shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.hide();
      return;
    }

    super.hideShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    const p = this.map.project({
      lat: coord.lat,
      lng: coord.lon
    });
    return {
      x: p.x,
      y: p.y
    };
  }

  pointToCoord(point) {
    const c = this.map.unproject([point.x, point.y]);
    return {
      lat: c.lat,
      lon: c.lng
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    const popup = new mapboxgl.Popup(opts).setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setLngLat({
        lat: target.lat,
        lng: target.lon
      }).addTo(this.map);
    } else if (this.isMarker(target)) {
      target.setPopup(popup);
      target.togglePopup();
    }
  }

  _setupEvents() {
    this.map.on('movestart', e => {
      ['before:change:bounds', 'before:change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('moveend', e => {
      ['after:change:bounds', 'after:change:center', 'change:bounds', 'change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomstart', e => {
      ['before:change:zoom'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomend', e => {
      ['after:change:zoom', 'change:zoom'].forEach(name => this.trigger(name));
    }); // call super at the bottom so our initial click event handler gets called first to
    // handle layer vs map click triggers

    super._setupEvents();
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.lngLat.lat,
            lon: event.lngLat.lng
          },
          point: {
            x: event.point.x,
            y: event.point.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = MapboxMapStrategy;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 256 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Polygon", ({
  enumerable: true,
  get: function () {
    return _PolygonLayer.default;
  }
}));
Object.defineProperty(exports, "Polyline", ({
  enumerable: true,
  get: function () {
    return _PolylineLayer.default;
  }
}));
Object.defineProperty(exports, "Tile", ({
  enumerable: true,
  get: function () {
    return _TileLayer.default;
  }
}));
Object.defineProperty(exports, "Marker", ({
  enumerable: true,
  get: function () {
    return _Marker.default;
  }
}));
Object.defineProperty(exports, "TileSource", ({
  enumerable: true,
  get: function () {
    return _MapboxTileSource.default;
  }
}));

var _PolygonLayer = _interopRequireDefault(__webpack_require__(257));

var _PolylineLayer = _interopRequireDefault(__webpack_require__(259));

var _TileLayer = _interopRequireDefault(__webpack_require__(260));

var _Marker = _interopRequireDefault(__webpack_require__(261));

var _MapboxTileSource = _interopRequireDefault(__webpack_require__(263));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 257 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(258));

var strings = _interopRequireWildcard(__webpack_require__(133));

var _utils = __webpack_require__(17);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */
class MapboxPolygonLayer extends _Layer.default {
  constructor(layer, polygons, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._needsEventSetup = true;
    this._polygons = polygons;
  }

  get strokeLayerId() {
    return `${this.layerId}-stroke`;
  }

  addTo(map) {
    super.addTo(map);

    if (this._strokeLayer) {
      const contains = map.getLayer(this.strokeLayerId) !== undefined;

      if (!contains) {
        map.addLayer(this._strokeLayer, this.layerId);
      }
    }

    if (this._needsEventSetup) {
      map.on('click', this.layerId, e => {
        this.trigger('click', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseenter', this.layerId, e => {
        this.trigger('mouseover', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseleave', this.layerId, e => {
        this.trigger('mouseout', {
          data: this.data,
          shape: this.renderable
        });
      });
      this._needsEventSetup = false;
    }
  }

  remove() {
    if (!this.map) return;

    if (this._strokeLayer) {
      const contains = this.map.getLayer(this.strokeLayerId) !== undefined;

      if (contains) {
        this.map.removeLayer(this.strokeLayerId);
      }
    }

    super.remove();
  }

  invalidate() {
    const isMulti = this._polygons.length > 1;
    const polygons = (this._polygons || []).map(polygon => {
      const outer = polygon.outer.map(c => [c.lon, c.lat]);
      const inner = polygon.inner ? polygon.inner.map(p => p.map(c => [c.lon, c.lat])) : [];
      return [outer, ...inner];
    });
    this.source = {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: {
            type: isMulti ? 'MultiPolygon' : 'Polygon',
            coordinates: isMulti ? polygons : polygons[0] || []
          }
        }]
      }
    };
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  createRenderable() {
    const style = this.opts;
    const convertedStyle = {
      fill: {},
      stroke: {}
    }; // format the line/fill styles as required for the Mapbox paint style spec

    ['fill', 'line'].forEach(type => {
      const dest = type === 'line' ? 'stroke' : 'fill';
      Object.keys(style).filter(key => new RegExp(`^${type}-`).test(key)).forEach(prop => {
        const k = strings.hyphenate(prop);

        if ((0, _utils.isset)(style[prop])) {
          convertedStyle[dest][k] = style[prop];
        }
      });
    }); // need to create a separate layer for the stoke style since Mapbox
    // doesn't allow you to set the apply stroke styling to a fill layer

    if (Object.keys(convertedStyle.stroke).length > 0) {
      this._strokeLayer = {
        id: this.strokeLayerId,
        type: 'line',
        source: this.sourceId,
        layout: {},
        paint: convertedStyle.stroke
      };
    }

    return {
      id: this.layerId,
      type: 'fill',
      source: this.sourceId,
      layout: {},
      paint: convertedStyle.fill
    };
  }

}

var _default = MapboxPolygonLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 258 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapLayer = _interopRequireDefault(__webpack_require__(246));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `Layer` is a container class that is responsible for creating and managing a Mapbox
 * source and associated layer representation on a Mapbox map.
 */
class MapboxLayer extends _MapLayer.default {
  /**
   * Source identifier on the map.
   *
   * @readonly
   * @type {string}
   * @memberof Layer
   */
  get sourceId() {
    return `${this.layerId}-source`;
  }
  /**
   * The parent layer identifier for the layer, if any. When specified, this layer will be
   * rendered on the map below the layer associated with the parent identifier.
   *
   * @type {string}
   * @memberof Layer
   */


  get parentId() {
    return this._relativeTo;
  }

  set parentId(value) {
    this._relativeTo = value;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.exists() && !this.isHidden) {
      if (this.renderable.type === 'raster') {
        this.map.setPaintProperty(this.layerId, 'raster-opacity', value);
      } else if (this.renderable.type === 'fill') {
        this.map.setPaintProperty(this.layerId, 'fill-opacity', value);
      }
    }
  }

  setZIndex(value) {
    if (this.exists()) {
      const layers = this.map.getStyle().layers;
      let index = 0;
      layers.forEach((layer, i) => {
        if (layer.type === 'line' && /^admin-/.test(layer.id) && index === 0) {
          index = i;
        }
      });
      const target = layers.map(layer => layer.id)[index + value];
      this.map.removeLayer(this.layerId);
      this.map.addLayer(this.renderable, target);
    }
  }

  exists() {
    const map = this.map;

    if (!map) {
      return false;
    }

    return map.getLayer(this.layerId) !== undefined && map.getSource(this.sourceId) !== undefined;
  }

  invalidate() {
    throw new Error('Subclasses must override `invalidate`');
  }

  createRenderable() {
    return null;
  }

  updateVisibility(visible) {
    if (this.exists()) {
      if (this.renderable.type === 'raster') {
        this.map.setPaintProperty(this.layerId, 'raster-opacity', this.opacity);
      }

      this.map.setLayoutProperty(this.layerId, 'visibility', visible ? 'visible' : 'none');
    }
  }

  addToMap(map) {
    if (this.exists()) {
      return;
    } // determine where to position this layer, typically below map labels/symbols but above roads


    if (!this._relativeTo) {
      const layers = map.getStyle().layers;
      layers.forEach((layer, index) => {
        if (layer.type === 'line' && /^admin-/.test(layer.id) && !this._relativeTo) {
          this._relativeTo = layer.id;
        }
      });
    }

    const contains = map.getLayer(this.layerId) !== undefined;

    if (!contains) {
      if (!this.source) {
        this.invalidate();
      } else {
        map.addSource(this.sourceId, this.source);

        if (!this._relativeTo || map.getLayer(this._relativeTo) !== undefined) {
          map.addLayer(this.renderable, this._relativeTo);
        }
      }
    }

    if (this.isHidden) {
      this.hide();
    }
  }

  removeFromMap(map) {
    const contains = map.getLayer(this.layerId) !== undefined;

    if (contains) {
      map.removeLayer(this.layerId);
      map.removeSource(this.sourceId);
    }
  }

}

var _default = MapboxLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 259 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(258));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */
class MapboxPolylineLayer extends _Layer.default {
  constructor(layer, points, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._needsEventSetup = true;
    this._points = points;
  }

  addTo(map) {
    super.addTo(map);

    if (this._needsEventSetup) {
      map.on('click', this.layerId, e => {
        this.trigger('click', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseenter', this.layerId, e => {
        this.trigger('mouseover', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseleave', this.layerId, e => {
        this.trigger('mouseout', {
          data: this.data,
          shape: this.renderable
        });
      });
      this._needsEventSetup = false;
    }
  }

  invalidate() {
    this.source = {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: this._points.map(point => [point.lon, point.lat])
          }
        }]
      }
    };
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  createRenderable() {
    const style = (0, _utils.cloneDeep)(this.opts);
    return {
      id: this.layerId,
      type: 'line',
      source: this.sourceId,
      layout: {},
      paint: style
    };
  }

}

var _default = MapboxPolylineLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 260 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(258));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `TileLayer` is a container class that is responsible for creating and managing a Mapbox
 * source and associated layer representation on a Mapbox map.
 */
class MapboxTileLayer extends _Layer.default {
  constructor(layer, opts, id = undefined) {
    super(layer, (0, _utils.extend)({
      type: 'tile'
    }, opts), id);
    this._type = this.opts.type;
  }
  /**
   * Updates the tile or image url for the layer.
   *
   * @param {string} url
   * @memberof TileLayer
   */


  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }
  /**
   * Updates the bounds for the layer when rendered as an image.
   *
   * @param {GeoBounds} bounds
   * @memberof TileLayer
   */


  setBounds(bounds) {
    this.opts.bounds = bounds;
  }
  /**
   * Updates the layer source using the specified image URL and coordinate bounds. Only used
   * for `image` layer types.
   *
   * @param {string} url
   * @param {GeoBounds} [bounds=undefined]
   * @returns
   * @memberof TileLayer
   */


  setImage(url, bounds = undefined) {
    this.opts.url = url;
    const map = this.map;
    if (!map) return;
    if (!bounds) bounds = this.opts.bounds;
    const source = map.getSource(this.sourceId);

    if (source) {
      source.updateImage({
        url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      });
    } else {
      this.invalidate();
    }
  }

  invalidate() {
    const {
      url,
      bounds
    } = this.opts;
    if (!url) return;

    if (this._type === 'image') {
      if (!bounds) {
        return;
      }

      this.source = {
        type: 'image',
        url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      };
    } else {
      this.source = {
        type: 'raster',
        tiles: [1, 2, 3, 4].map(s => url.replace(/\{s\}/, `${s}`)),
        tileSize: 256,
        attribution: this.opts.attribution || ''
      };
    }

    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  updateVisibility(visible) {
    if (this.exists()) {
      this.map.setPaintProperty(this.layerId, 'raster-opacity', visible ? this.opacity : 0);
    }
  }

  createRenderable() {
    return {
      id: this.layerId,
      type: 'raster',
      source: this.sourceId,
      paint: {
        'raster-opacity': this.opacity,
        'raster-opacity-transition': {
          duration: 0,
          delay: 0
        },
        'raster-fade-duration': 0
      }
    };
  }

}

var _default = MapboxTileLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 261 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _MapMarker = _interopRequireDefault(__webpack_require__(250));

var _utils2 = __webpack_require__(262);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */
class MapboxMarker extends _MapMarker.default {
  update(opts) {
    var _a;

    if (!(0, _utils.isset)(opts)) return;
    const {
      data
    } = opts;

    if ((0, _utils.isset)(data)) {
      this.data = Object.assign(Object.assign({}, this.data), data);
    }

    const value = (_a = this.data) === null || _a === void 0 ? void 0 : _a.value;
    let style = opts.style || {};

    if ((0, _utils.isFunction)(style)) {
      style = style({
        value
      });
    }

    this.setStyle(style);
  }

  setStyle(style) {
    this.opts.style = style; // Mapbox doesn't support updating an existing marker's element, so we need to create a new marker
    // for each different value associated with a coordinate's data and add/remove it accordingly

    this.invalidate();
  }

  createRenderable() {
    const {
      style
    } = this.opts;
    const coord = this.coordinate;
    const opts = {};

    if (style) {
      opts.icon = (0, _utils2.markerIconFromStyle)(style);

      if (style.zIndex) {
        opts.zIndex = style.zIndex;
      }
    }

    const renderable = new mapboxgl.Marker({
      element: opts.icon
    });
    renderable.setLngLat([coord.lon, coord.lat]);

    if (style && style.callout) {
      let content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        const fn = style.callout;
        content = fn();
      }

      const popup = new mapboxgl.Popup();
      popup.setHTML(content);
      renderable.setPopup(popup);
    }

    return renderable;
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    const renderable = this.renderable;

    if (renderable) {
      const el = renderable.getElement();

      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          el.removeEventListener(name, renderable[handlerName]);
        } else {
          renderable[handlerName] = e => {
            e.stopPropagation();
            this.trigger(name, {
              data: this.data,
              marker: renderable
            });
          };
        }

        el.addEventListener(name, renderable[handlerName]);
      });

      renderable.addTo(map);
    }
  }

  removeFromMap(map) {
    const renderable = this.renderable;

    if (renderable) {
      const el = renderable.getElement();

      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          el.removeEventListener(name, renderable.__awxjs_clickHandler);
        }
      });

      renderable.remove();
    }
  }

}

var _default = MapboxMarker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 262 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.markerIconFromStyle = exports.formatLayerOptions = void 0;

var _SVG = __webpack_require__(252);

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

// generate Mapbox paint options from config
const formatLayerOptions = opts => {
  const formatted = {
    stroke: false,
    fill: false
  };
  formatted.id = opts.id;

  if (opts.stroke) {
    formatted.stroke = true;
    formatted.lineColor = opts.stroke.color;
    formatted.lineOpacity = opts.stroke.opacity;
    formatted.lineWidth = opts.stroke.width;
    formatted.lineCap = opts.stroke.lineCap;
    formatted.lineJoin = opts.stroke.lineJoin;
    formatted.lineDasharray = opts.stroke.dashArray;
    formatted.dashOffset = opts.stroke.dashOffset;
  }

  if (opts.fill) {
    formatted.fill = true;
    formatted.fillColor = opts.fill.color;
    formatted.fillOpacity = opts.fill.opacity;
  }

  if (formatted.fill && !(0, _utils.isset)(opts.fillOpacity)) opts.fillOpacity = 1;
  if (formatted.stroke && !(0, _utils.isset)(opts.strokeOpacity)) opts.strokeOpacity = 1;
  delete formatted.fill;
  delete formatted.stroke; // convert camelcase style keys to hypenated strings

  Object.keys(formatted).forEach(key => {
    const k = (0, _strings.hyphenate)(key);

    if (k !== key) {
      formatted[k] = formatted[key];
      delete formatted[key];
    }
  });
  return formatted;
};

exports.formatLayerOptions = formatLayerOptions;

const markerIconFromStyle = style => {
  if (!style) {
    return null;
  }

  if (style.html) {
    console.warn('awxjs - HTML markers are not currently supported with Mapbox GL');
  }

  if (style.svg) {
    const [width, height] = style.size || [12, 12];

    if (document) {
      const div = document.createElement('div');
      div.innerHTML = _SVG.SVG.draw(width, height, style.svg);

      if (style.zIndex) {
        div.style.zIndex = `${style.zIndex}`;
      }

      return div;
    }
  }

  if (style.icon) {
    const image = new Image();
    image.src = style.icon.url;
    image.width = style.size[0];
    image.height = style.size[1];
    return image;
  }

  return null;
};

exports.markerIconFromStyle = markerIconFromStyle;

/***/ }),
/* 263 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _TileSource = _interopRequireDefault(__webpack_require__(240));

var _TileLayer = _interopRequireDefault(__webpack_require__(260));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `MapboxTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `MapboxMapStrategy`.
 *
 * @export
 * @class MapboxTileSource
 * @extends {TileSource}
 */
class MapboxTileSource extends _TileSource.default {
  constructor(key, service, opts) {
    super(key, service, opts);
    const anim = this.animation;
    const animOverlay = new _TileLayer.default(key, (0, _utils.extend)(opts, {
      type: 'image'
    }), `${this.identifier}-anim`);
    anim === null || anim === void 0 ? void 0 : anim.on('show', e => {
      this.show();
    });
    anim === null || anim === void 0 ? void 0 : anim.on('hide', e => {
      this.hide();
    });
    anim === null || anim === void 0 ? void 0 : anim.on('load:image advance:image', e => {
      const image = e.data.img;

      if (image) {
        animOverlay.setImage(image.src);
      }
    });
    this._animationOverlay = animOverlay;
    this.on('overlay:ready', () => {
      const opacity = (0, _utils.get)(opts, 'style.opacity');
      const relativeTo = (0, _utils.get)(opts, 'style.belowLayer');

      if (opts.id) {
        this._overlay.id = opts.id;
        this._animationOverlay.id = `${opts.id}-anim`;
      }

      if ((0, _utils.isset)(opacity)) {
        this._overlay.setOpacity(opacity);

        this._animationOverlay.setOpacity(opacity);
      }

      this._overlay.parentId = relativeTo;
      this._animationOverlay.parentId = this._overlay.layerId;
    });
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    var _a;

    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        (_a = this.animation) === null || _a === void 0 ? void 0 : _a.hide();
        this.updateVisibility();
      }

      if (this.overlay && (this.canShow() || !this.overlay.exists())) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof MapboxTileSource
   */


  show() {
    var _a;

    if (this._hidden === false) return;
    this._hidden = false;

    if (((_a = this.animation) === null || _a === void 0 ? void 0 : _a.isAnimating()) && this._animationOverlay) {
      this._animationOverlay.show();
    } else if (this.overlay) {
      this.overlay.show();
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof MapboxTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.hide();
    }

    if (this._animationOverlay) {
      this._animationOverlay.hide();
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof MapboxTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof MapboxTileSource
   */


  setOpacity(value, update = true) {
    var _a;

    this._opacity = value;

    if (this.overlay) {
      this.overlay.setOpacity(value);
    }

    if (this._animationOverlay) {
      this._animationOverlay.setOpacity(value);
    }

    (_a = this.animation) === null || _a === void 0 ? void 0 : _a.setOpacity(value);
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof MapboxTileSource
   */


  setOrder(value) {
    if (this.overlay) {
      this.overlay.setZIndex(value);
    }

    if (this._animationOverlay) {
      this._animationOverlay.setZIndex(value);
    }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, (0, _utils.extend)(opts, {
      type: 'type'
    }), this.identifier);
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          opacity: 0,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, false);
        source.hide();

        if (wait) {
          const map = this.overlay.map;
          map.on('sourcedata', e => {
            const {
              sourceId,
              isSourceLoaded
            } = e || {};

            if (sourceId === source.overlay.sourceId && isSourceLoaded) {
              resolve(source);
            }
          });
        } else {
          resolve(source);
        }

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = MapboxTileSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 264 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var Mapbox = _interopRequireWildcard(__webpack_require__(256));

var _utils = __webpack_require__(262);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class MapboxOverlayFactory
 * @implements {OverlayFactory}
 * @implements {PointDataSource}
 */
class MapboxOverlayFactory {
  /**
   * Returns a tile layer instance configured with the specified url template string and options.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {TileSource}
   * @memberof OverlayFactory
   */
  tileLayer(layer, service, opts) {
    return new Mapbox.TileSource(layer, service, opts);
  }
  /**
   * Returns an annotation, or marker, instance with the specified coordinate and configuration
   * options.
   *
   * @param {string} layer
   * @param {Coordinate} coord
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof OverlayFactory
   */


  marker(layer, coord, style) {
    if (style) {
      // if skipped via the style, then return null
      if (style.skip && style.skip === true) {
        return null;
      }
    }

    return new Mapbox.Marker(coord, undefined, {
      style
    });
  }
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OverlayFactory
   */


  polygon(layer, shapes, style) {
    let opts;

    if (style) {
      opts = (0, _utils.formatLayerOptions)(style);
    }

    shapes.forEach(shape => {
      if (!opts.id) {
        opts.id = shape.id;
      }
    });
    return new Mapbox.Polygon(layer, shapes, opts, opts.id);
  }

  polyline(layer, points, style) {
    const mapping = {
      stroke: {
        color: 'lineColor',
        opacity: 'lineOpacity',
        width: 'lineWidth',
        dashArray: 'lineDashArray'
      }
    };
    let opts;

    if (style) {
      if (style) {
        opts = (0, _utils.formatLayerOptions)(style);
        delete opts.fill;
      }
    }

    const p = points.map(point => [point.lat, point.lon]);
    return new Mapbox.Polyline(layer, points, opts, opts.id);
  }

}

var _default = MapboxOverlayFactory;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 265 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapStrategy = _interopRequireDefault(__webpack_require__(228));

var OpenLayers = _interopRequireWildcard(__webpack_require__(266));

var _Event = _interopRequireDefault(__webpack_require__(99));

var _OpenLayersOverlayFactory = _interopRequireDefault(__webpack_require__(275));

var _OpenLayersTileSource = _interopRequireDefault(__webpack_require__(274));

var _Popup = _interopRequireDefault(__webpack_require__(273));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _utils2 = __webpack_require__(254);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * A map strategy for working with the third-party OpenLayers mapping library.
 *
 * @export
 * @class OpenLayersMapStrategy
 * @extends {MapStrategy}
 * @implements {MapStrategy}
 */
class OpenLayersMapStrategy extends _MapStrategy.default {
  constructor() {
    super(...arguments);
    this._hasLoaded = false;
    this._clickedMapLayer = false;
    this._shapeDataById = {};
  }

  get strategy() {
    return 'openlayers';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getTarget());
  }

  loadDependencies() {
    return new Promise((resolve, reject) => {
      if (typeof ol === 'undefined' || typeof ol.Map === 'undefined') {
        const version = '6.5.0';
        Promise.all([(0, _utils.loadStyles)(`https://openlayers.org/en/v${version}/css/ol.css`), (0, _utils.loadScript)(`https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v${version}/build/ol.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _OpenLayersOverlayFactory.default();
    this._eventMapping = {
      // rendercomplete: 'load',
      unload: 'unload',
      resize: 'resize',
      // click: 'click',
      dblclick: 'dblclick',
      pointermove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      movestart: 'move:start',
      moveend: 'move:end',
      popupopen: 'popupopen',
      popupclose: 'popupclose'
    };

    _Popup.default.injectStyles(); // set view properties from native map options if defined


    const initView = (0, _utils.get)(this.opts, 'map.view');

    if (initView && initView instanceof ol.View) {
      const [lon, lat] = ol.proj.toLonLat(initView.getCenter());

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        (0, _utils.set)(this.opts, 'center', {
          lat,
          lon
        });
      }

      (0, _utils.set)(this.opts, 'zoom', initView.getZoom());
    } // constructor allows passing either an HTMLElement or instance of ol.Map
    // if ol.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isOpenLayers)(target)) {
      this._setInitialView = false;
      this._map = target;
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      const mapOpts = (0, _utils.extend)({
        layers: [new ol.layer.Tile({
          source: new ol.source.OSM()
        })]
      }, this.opts.map);
      mapOpts.target = target;
      this._map = new ol.Map(mapOpts); // position the zoom control at the bottom-left

      (0, _DOM.default)('head').append('<style>.ol-zoom { top: auto; bottom: .5em; }</style>');

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }
    }

    setTimeout(() => {
      this.trigger('map:ready');
    }, 250);
  }
  /**
   * Updates the base layer using tiles from the provided URL.
   *
   * @param {string} url
   * @memberof OpenLayersMapStrategy
   */


  setBaseStyle(url) {
    const baseLayer = this.map.getLayers().item(0);
    this.map.removeLayer(baseLayer);
    this.map.getLayers().insertAt(0, new ol.layer.Tile({
      source: (0, _utils.isset)(url) ? new ol.source.XYZ({
        url: url.replace(/\{s\}/, '1')
      }) : new ol.source.OSM()
    }));
  }

  setBaseUrl(url) {
    this.setBaseStyle(url);
  }

  setView(center, zoom) {
    this.map.setView(new ol.View({
      center: ol.proj.fromLonLat([center.lon, center.lat]),
      zoom
    }));
  }

  getCenter() {
    const [lon, lat] = ol.proj.toLonLat(this.map.getView().getCenter());
    return {
      lat,
      lon
    };
  }

  setCenter(coord) {
    this.map.getView().setCenter(ol.proj.fromLonLat([coord.lon, coord.lat]));
  }

  getZoom() {
    return this.map.getView().getZoom();
  }

  setZoom(zoom) {
    this.map.getView().setZoom(zoom);
  }

  getBounds() {
    // const [ minx, miny, maxx, maxy ]: ol.Extent = this.map.getView().calculateExtent(this.map.getSize());
    // const [ west, south ] = ol.proj.toLonLat([ minx, miny ]);
    // const [ east, north ] = ol.proj.toLonLat([ maxx, maxy ]);
    const extent = this.map.getView().calculateExtent(this.map.getSize());
    const [west, south, east, north] = ol.proj.transformExtent(extent, 'EPSG:3857', 'EPSG:4326');
    return {
      north,
      west,
      south,
      east
    };
  }

  setBounds(bounds) {
    const [minx, miny] = ol.proj.fromLonLat([bounds.west, bounds.south]);
    const [maxx, maxy] = ol.proj.fromLonLat([bounds.east, bounds.north]);
    const extent = [minx, miny, maxx, maxy];
    this.map.getView().fit(extent);
  }

  fitBounds(bounds, padding = [10, 10]) {
    const [minx, miny] = ol.proj.fromLonLat([bounds.west, bounds.south]);
    const [maxx, maxy] = ol.proj.fromLonLat([bounds.east, bounds.north]);
    const extent = [minx, miny, maxx, maxy];
    let opts;

    if (padding.length === 1) {
      opts = [padding[0], padding[0], padding[0], padding[0]];
    } else if (padding.length === 2) {
      opts = [padding[1], padding[0], padding[1], padding[0]];
    } else if (padding.length === 4) {
      opts = [padding[0], padding[1], padding[2], padding[3]];
    }

    this.map.getView().fit(extent, {
      padding: opts
    });
  }
  /** Sources */


  isTile(source) {
    return source instanceof _OpenLayersTileSource.default;
  }

  isMarker(el) {
    return el instanceof OpenLayers.Marker;
  }

  isPolygon(el) {
    return el instanceof OpenLayers.Polygon;
  }

  isPolyline(el) {
    return el instanceof OpenLayers.Polyline;
  }
  /** Overlays */


  addOverlay(overlay, index) {
    if (overlay instanceof OpenLayers.Tile) {
      overlay.addTo(this.map, index);
    } else if (overlay instanceof ol.layer.Base || overlay instanceof ol.layer.Tile) {
      if (index) {
        this.map.getLayers().insertAt(index, overlay);
      } else {
        this.map.addLayer(overlay);
      }
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof OpenLayers.Tile) {
      overlay.remove();
    } else if (overlay instanceof ol.layer.Base || overlay instanceof ol.layer.Tile) {
      this.map.removeLayer(overlay);
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof OpenLayers.Marker) {
      if (!this.containsLayer(marker.renderable)) {
        marker.on('click', () => this.trigger("marker:click"
        /* MARKER_CLICK */
        , {
          data,
          marker
        }));
        marker.on('mouseover', () => this.trigger("marker:mouseover"
        /* MARKER_MOUSEOVER */
        , {
          data,
          marker
        }));
        marker.on('mouseout', () => this.trigger("marker:mouseout"
        /* MARKER_MOUSEOUT */
        , {
          data,
          marker
        }));
        marker.addTo(this.map);
      }
    } else if (marker instanceof ol.layer.Vector) {
      if (!this.containsLayer(marker)) {
        this.map.addLayer(marker);
      }

      return;
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof OpenLayers.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof ol.layer.Vector) {
      this.map.removeLayer(marker);
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!options) return;

    if (marker instanceof OpenLayers.Marker) {
      marker.update(options);
    }

    super.updateMarker(marker, options, layer);
  }

  showMarkers(markers, show) {
    markers.forEach(marker => {
      if (this.isMarker(marker)) {
        marker = marker.layer;
      }

      if (marker instanceof ol.layer.Vector) {
        marker.setVisible(show);
      }
    });
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof OpenLayers.Polygon || shape instanceof OpenLayers.Polyline) {
      if (!this.containsLayer(shape.renderable)) {
        // need to insert shapes below markers which use Point geometries
        // so grab the index of the first Point layer on the map to use for inserting the shape
        const index = this.getIndexBoundForGeom('point', true);
        shape.on('click', () => this.trigger("shape:click"
        /* SHAPE_CLICK */
        , {
          data,
          shape
        }));
        shape.on('mouseover', () => this.trigger("shape:mouseover"
        /* SHAPE_MOUSEOVER */
        , {
          data,
          shape
        }));
        shape.on('mouseout', () => this.trigger("shape:mouseout"
        /* SHAPE_MOUSEOUT */
        , {
          data,
          shape
        }));
        shape.addTo(this.map, index);
        this._shapeDataById[shape.id] = data;
      }
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof OpenLayers.Polygon || shape instanceof OpenLayers.Polyline) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    this.addShape(shape);
  }

  hideShape(shape) {
    this.removeShape(shape);
  }

  containsLayer(layer) {
    const existing = this.map.getLayers().getArray();
    return existing.indexOf(layer) !== -1;
  }
  /** Conversions */


  coordToPoint(coord) {
    if (!(0, _utils.isset)(coord)) {
      return null;
    }

    const point = this.map.getPixelFromCoordinate(ol.proj.fromLonLat([coord.lon, coord.lat]));

    if (point) {
      const [x, y] = point;
      return {
        x,
        y
      };
    }

    return null;
  }

  pointToCoord(point) {
    if (!(0, _utils.isset)(point)) {
      return null;
    }

    const coord = this.map.getCoordinateFromPixel(ol.proj.toLonLat([point.x, point.y]));

    if (coord) {
      const [lon, lat] = coord;
      return {
        lat,
        lon
      };
    }

    return null;
  }

  getInsertIndex(layer, positionOffset) {
    const existing = this.map.getLayers().getArray();
    const index = existing.indexOf(layer);

    if (index !== -1) {
      return Math.max(0, index + positionOffset);
    }

    return existing.length;
  }

  getIndexBoundForGeom(type, min = false) {
    let index = 0;
    const existing = this.map.getLayers().getArray();
    existing.forEach((layer, i) => {
      if (layer instanceof ol.layer.Vector) {
        const source = layer.getSource();
        const features = source.getFeatures();

        if (features && features.length > 0) {
          const geom = features[0].getGeometry();

          if (geom.getType().toLowerCase() === type.toLowerCase()) {
            index = min ? Math.min(index, i) : Math.max(index, i);
          }
        }
      }
    });
    return Math.max(1, index);
  }
  /** Callout */


  showCallout(target, content, opts) {
    const popup = new _Popup.default();
    popup.setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setCoordinate(target);
    } else if (this.isMarker(target)) {
      popup.setCoordinate(target.coordinate);
    } else if (target instanceof ol.Feature) {
      const geom = target.getGeometry();

      if (geom instanceof ol.geom.Point) {
        const [lon, lat] = geom.getCoordinates();
        popup.setCoordinate({
          lat,
          lon
        });
      }
    }

    if (this._activePopup) {
      this._activePopup.remove();
    }

    this._activePopup = popup;
    popup.addTo(this.map);
  }

  _setupEvents() {
    super._setupEvents();

    const getMouseEventInfo = e => {
      const pixel = this.map.getEventPixel(e);
      const mapCoord = this.map.getEventCoordinate(e);
      const coord = mapCoord ? ol.proj.toLonLat(mapCoord) : [null, null];
      return {
        pixel,
        coord
      };
    }; // OpenLayers doesn't support regular mouse events, so we need to register them on the map's DOM target


    ['mouseover', 'mouseout', 'mousedown', 'mouseup'].forEach(eventName => {
      this.map.getTargetElement().addEventListener(eventName, e => {
        const {
          pixel,
          coord
        } = getMouseEventInfo(e);
        this.trigger(eventName, {
          coord: {
            lat: coord[1],
            lon: coord[0]
          },
          point: {
            x: pixel[0],
            y: pixel[1]
          }
        });
      });
    });
    this.map.on('rendercomplete', () => {
      if (this._hasLoaded === false) {
        this._hasLoaded = true;
        this.trigger('load');
      }
    });
    this.map.on('click', e => {
      // let selectedLayer: ol.layer.Layer;
      // trigger custom events for markers and shape selections in order to properly handle popup
      let selectedMarker = false; // const selected = this.map.getFeaturesAtPixel(e.pixel, {
      // 	layerFilter: (layer) => {
      // 		return (layer instanceof ol.layer.Vector);
      // 	}
      // });
      // if (selected && selected.length > 0) {
      // 	const feature = selected[0];
      // 	const geom = feature.getGeometry();
      // 	if (geom instanceof ol.geom.Point) {
      // 		selectedMarker = true;
      // 		layer.dispatchEvent(new Event('marker:click'));
      // 	} else if (geom instanceof ol.geom.Polygon) {
      // 		this.trigger('shape:click', { shape: feature });
      // 	}
      // }

      let triggered = false;
      this.map.forEachFeatureAtPixel(e.pixel, (feature, layer) => {
        if (!triggered) {
          const geom = feature.getGeometry();
          const props = feature.getProperties();
          const id = (0, _utils.get)(props, 'id') || (0, _utils.get)(props, 'properties.id');
          const dataKey = (id || '').replace(/^aeriswx-/, '');

          if (geom instanceof ol.geom.Point) {
            selectedMarker = true;
            layer.dispatchEvent(new _Event.default('marker:click'));
            triggered = true;
          } else if (geom instanceof ol.geom.SimpleGeometry) {
            const data = this._shapeDataById[dataKey];
            this.trigger('shape:click', {
              shape: feature,
              data
            });
            triggered = true;
          }
        }
      }, {
        hitTolerance: 10
      });

      if (triggered) {
        this._clickedMapLayer = true;
        setTimeout(() => {
          this._clickedMapLayer = false;
        }, 100);
      } else {
        this.trigger('click', this._dataForMapEvent('click', e));
      } // no marker nor shape was selected, hide any active popup


      if (!selectedMarker && this._activePopup) {
        this._activePopup.remove();
      }
    });
    this.map.on('moveend', e => {
      this.trigger('change:bounds');
      this.trigger('change:center');
    });
    this.map.on('zoomend', e => {
      this.trigger('change:zoom');
    });

    const handleFeatureMouseOut = () => {
      if (this._hoveredMapLayer) {
        const {
          type,
          feature
        } = this._hoveredMapLayer;
        this.trigger(`${type}:mouseout`, {
          [type]: feature,
          data: null
        });
        this._hoveredMapLayer = undefined;
      }
    }; // this.map.on('idle', e => this.trigger('idle'));


    this.map.on('pointermove', e => {
      let found = false;
      this.map.forEachFeatureAtPixel(e.pixel, (feature, layer) => {
        var _a, _b;

        if (!found) {
          const geom = feature.getGeometry();
          const props = feature.getProperties();
          const id = (0, _utils.get)(props, 'id') || (0, _utils.get)(props, 'properties.id');
          const dataKey = (id || '').replace(/^aeriswx-/, '');

          if (geom instanceof ol.geom.Point) {
            found = true;

            if (feature !== ((_a = this._hoveredMapLayer) === null || _a === void 0 ? void 0 : _a.feature)) {
              handleFeatureMouseOut();
              this.trigger('marker:mouseover', {
                marker: feature,
                data: null
              });
              this._hoveredMapLayer = {
                type: 'marker',
                feature
              };
            }
          } else if (geom instanceof ol.geom.SimpleGeometry) {
            found = true;

            if (feature !== ((_b = this._hoveredMapLayer) === null || _b === void 0 ? void 0 : _b.feature)) {
              handleFeatureMouseOut();
              const data = this._shapeDataById[dataKey];
              this.trigger('shape:mouseover', {
                shape: feature,
                data
              });
              this._hoveredMapLayer = {
                type: 'shape',
                feature
              };
            }
          }
        }
      });

      if (!found) {
        handleFeatureMouseOut();
      }
    });
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;
    let coord;

    switch (name) {
      case 'pointermove':
      case 'click':
      case 'dblclick':
        coord = ol.proj.toLonLat(event.coordinate);
        data = {
          coord: {
            lat: coord[1],
            lon: coord[0]
          },
          point: {
            x: event.pixel[0],
            y: event.pixel[1]
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = OpenLayersMapStrategy;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 266 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Polygon", ({
  enumerable: true,
  get: function () {
    return _PolygonLayer.default;
  }
}));
Object.defineProperty(exports, "Polyline", ({
  enumerable: true,
  get: function () {
    return _PolylineLayer.default;
  }
}));
Object.defineProperty(exports, "Tile", ({
  enumerable: true,
  get: function () {
    return _TileLayer.default;
  }
}));
Object.defineProperty(exports, "Marker", ({
  enumerable: true,
  get: function () {
    return _Marker.default;
  }
}));
Object.defineProperty(exports, "TileSource", ({
  enumerable: true,
  get: function () {
    return _OpenLayersTileSource.default;
  }
}));

var _PolygonLayer = _interopRequireDefault(__webpack_require__(267));

var _PolylineLayer = _interopRequireDefault(__webpack_require__(269));

var _TileLayer = _interopRequireDefault(__webpack_require__(270));

var _Marker = _interopRequireDefault(__webpack_require__(271));

var _OpenLayersTileSource = _interopRequireDefault(__webpack_require__(274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 267 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(268));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */
class OpenLayersPolygonLayer extends _Layer.default {
  constructor(layer, polygons, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._polygons = polygons;
  }

  invalidate() {
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map, this._targetIndex);
    }
  }

  createRenderable() {
    const {
      stroke,
      fill
    } = this.opts;
    let id;
    const isMulti = this._polygons.length > 1;
    const polygons = (this._polygons || []).map(polygon => {
      if (!(0, _utils.isset)(id) && (0, _utils.isset)(polygon.id)) {
        id = polygon.id;
      }

      const outer = polygon.outer.map(c => [c.lon, c.lat]);
      const inner = polygon.inner ? polygon.inner.map(p => p.map(c => [c.lon, c.lat])) : [];
      return [outer, ...inner];
    });
    this.source = new ol.source.Vector({
      features: new ol.format.GeoJSON().readFeatures({
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          properties: {
            id
          },
          geometry: {
            type: isMulti ? 'MultiPolygon' : 'Polygon',
            coordinates: isMulti ? polygons : polygons[0] || []
          }
        }]
      }, {
        dataProjection: null,
        featureProjection: 'EPSG:3857'
      })
    });
    return new ol.layer.Vector({
      source: this.source,
      style: new ol.style.Style({
        stroke: stroke ? new ol.style.Stroke(stroke) : null,
        fill: fill ? new ol.style.Fill(fill) : null
      })
    });
  }

}

var _default = OpenLayersPolygonLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 268 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapLayer = _interopRequireDefault(__webpack_require__(246));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `Layer` is a container class that is responsible for creating and managing a OpenLayers
 * source and associated layer representation on a OpenLayers map.
 */
class OpenLayersLayer extends _MapLayer.default {
  setOpacity(value) {
    var _a;

    super.setOpacity(value);
    (_a = this.renderable) === null || _a === void 0 ? void 0 : _a.setOpacity(value);
  }

  setZIndex(index) {
    var _a;

    (_a = this.renderable) === null || _a === void 0 ? void 0 : _a.setZIndex(index);
  }

  exists() {
    const map = this.map;

    if (!map) {
      return false;
    } // return (map.getLayer(this.layerId) !== undefined);


    return false;
  }

  invalidate() {}

  createRenderable() {
    return undefined;
  }

  updateVisibility(visible) {
    var _a;

    (_a = this.renderable) === null || _a === void 0 ? void 0 : _a.setVisible(visible);
  }

  addToMap(map, index) {
    this._targetIndex = index;

    if (this.renderable) {
      if (index >= 0) {
        map.getLayers().insertAt(index, this.renderable);
      } else {
        map.addLayer(this.renderable);
      }
    } else {
      this.invalidate();
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      map.removeLayer(this.renderable);
    }
  }

}

var _default = OpenLayersLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 269 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(268));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */
class OpenLayersPolylineLayer extends _Layer.default {
  constructor(layer, points, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._points = points;
  }

  invalidate() {
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map, this._targetIndex);
    }
  }

  createRenderable() {
    const {
      stroke
    } = this.opts; // points.push(ol.proj.transform([xx,yy],'EPSG:4326', 'EPSG:3857'));

    const points = this._points.map(point => ol.proj.transform([point.lon, point.lat], 'EPSG:4326', 'EPSG:3857'));

    const feature = new ol.Feature({
      properties: {
        id: this.id
      },
      geometry: new ol.geom.LineString(points)
    });
    this.source = new ol.source.Vector();
    this.source.addFeature(feature);
    return new ol.layer.Vector({
      source: this.source,
      style: new ol.style.Style({
        stroke: stroke ? new ol.style.Stroke(stroke) : null
      })
    });
  }

}

var _default = OpenLayersPolylineLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 270 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(268));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `TileLayer` is a container class that is responsible for creating and managing a OpenLayers
 * source and associated layer representation on a OpenLayers map.
 */
class OpenLayersTileLayer extends _Layer.default {
  constructor() {
    super(...arguments);
    this._loadCounter = {
      loading: 0,
      loaded: 0
    };
  }
  /**
   * Updates the tile or image url for the layer.
   *
   * @param {string} url
   * @memberof TileLayer
   */


  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }
  /**
   * Updates the bounds for the layer when rendered as an image.
   *
   * @param {GeoBounds} bounds
   * @memberof TileLayer
   */


  setBounds(bounds) {
    this.opts.bounds = bounds;
  }
  /**
   * Forces a redraw of the layer on the map.
   *
   * @returns
   * @memberof TileLayer
   */


  invalidate() {
    const map = this.map;
    this.remove();
    this.createRenderable();

    if (map) {
      this.addTo(map, this._targetIndex);
    }
  }

  createRenderable() {
    this._loadCounter = {
      loading: 0,
      loaded: 0
    };
    const source = new ol.source.XYZ({
      url: this.opts.url,
      attributions: this.opts.attribution ? [this.opts.attribution] : null
    });
    source.on('tileloadstart', e => {
      this._loadCounter.loading += 1;
    });
    source.on(['tileloadend', 'tileloaderror'], e => {
      this._loadCounter.loaded += 1;

      if (this._loadCounter.loaded === this._loadCounter.loading) {
        this.trigger('load');
      }
    });
    this._source = source;
    const renderable = new ol.layer.Tile({
      source: this._source
    });
    renderable.setOpacity(this.isHidden ? 0 : this.opacity);
    return renderable;
  }

}

var _default = OpenLayersTileLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 271 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _MapMarker = _interopRequireDefault(__webpack_require__(250));

var _utils2 = __webpack_require__(272);

var _Popup = _interopRequireDefault(__webpack_require__(273));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */
class OpenLayersMarker extends _MapMarker.default {
  get feature() {
    return this._feature;
  }

  get popup() {
    return this._popup;
  }

  update(opts) {
    var _a;

    if (!(0, _utils.isset)(opts)) return;
    const value = (_a = opts.data) === null || _a === void 0 ? void 0 : _a.value;
    let style = opts.style || {};

    if ((0, _utils.isFunction)(style)) {
      style = style({
        value
      });
    }

    this.setStyle(style);
  }

  setStyle(style) {
    const icon = (0, _utils2.markerIconFromStyle)(style);

    if (this.feature && icon) {
      this.feature.setStyle(new ol.style.Style({
        image: icon
      }));
    }
  }

  setPopup(popup) {
    this._popup = popup;
  }

  createRenderable() {
    const {
      style
    } = this.opts;
    const coord = this.coordinate;
    let icon;

    if (style) {
      icon = (0, _utils2.markerIconFromStyle)(style);

      if (style.callout) {
        let content = style.callout;

        if ((0, _utils.isFunction)(style.callout)) {
          const fn = style.callout;
          content = fn();
        } // marker.setPopupContent(content);


        const popup = new _Popup.default(coord);
        popup.setHTML(content);
        this._popup = popup;
      }
    }

    this._feature = new ol.Feature({
      geometry: new ol.geom.Point(ol.proj.fromLonLat([coord.lon, coord.lat]))
    });
    return new ol.layer.Vector({
      source: new ol.source.Vector({
        features: [this.feature]
      }),
      style: new ol.style.Style({
        image: icon
      }),
      zIndex: style ? style.zIndex : null
    });
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    const observable = this.renderable;

    if (observable) {
      ['click', 'mouseover', 'mouseout'].forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (observable[handlerName]) {
          observable.un(name, observable[handlerName]);
        } else {
          observable[handlerName] = e => {
            this.trigger(name, {
              data: this.data,
              marker: observable
            });

            if (this.popup) {
              if (this._activePopup) {
                this._activePopup.remove();
              }

              this.popup.addTo(map);
              this._activePopup = this.popup;
            }
          };

          observable.on('marker:click', observable[handlerName]);
        }
      });
    }

    map.addLayer(this.renderable);
  }

  removeFromMap(map) {
    const observable = this.renderable;

    if (observable) {
      ['click', 'mouseover', 'mouseout'].forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (observable[handlerName]) {
          observable.un(name, observable[handlerName]);
        }
      });
    }

    map.removeLayer(this.renderable);
  }

}

var _default = OpenLayersMarker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 272 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.markerIconFromStyle = exports.formatLayerOptions = void 0;

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

var _color = __webpack_require__(139);

var _SVG = __webpack_require__(252);

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */
const formatLayerOptions = opts => {
  const formatted = {
    stroke: null,
    fill: null
  };

  if (opts.stroke) {
    const {
      r,
      g,
      b
    } = (0, _color.toRGB)(opts.stroke.color); // eslint-disable-line object-curly-newline

    formatted.stroke = {
      color: `rgba(${r}, ${g}, ${b}, ${opts.stroke.opacity || 1.0})`,
      width: opts.stroke.width,
      lineCap: opts.stroke.lineCap,
      lineJoin: opts.stroke.lineJoin,
      lineDash: opts.stroke.dashArray,
      lineDashOffset: opts.stroke.dashOffset
    };
  }

  if (opts.fill) {
    const {
      r,
      g,
      b
    } = (0, _color.toRGB)(opts.fill.color); // eslint-disable-line object-curly-newline

    formatted.fill = {
      color: `rgba(${r}, ${g}, ${b}, ${(0, _utils.isset)(opts.fill.opacity) ? opts.fill.opacity : 1.0})`
    };
  } // convert camelcase style keys to hypenated strings


  Object.keys(formatted).forEach(key => {
    const k = (0, _strings.hyphenate)(key);

    if (k !== key) {
      formatted[k] = formatted[key];
      delete formatted[key];
    }
  });
  return formatted;
};

exports.formatLayerOptions = formatLayerOptions;

const markerIconFromStyle = style => {
  if (style.html) {
    console.warn('awxjs - HTML markers are not currently supported with OpenLayers');
  }

  if (style.svg) {
    let [width, height] = style.size || [12, 12];

    if (style.svg.text) {
      const textStyle = style.svg.text;

      if ((0, _utils.isArray)(textStyle)) {
        textStyle.forEach(styleDef => {
          if (styleDef.autosize) {
            [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
          }
        });
      } else {
        const styleDef = textStyle;

        if (styleDef.autosize) {
          [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
        }
      }
    }

    height += 3;

    const image = _SVG.SVG.draw(width, height, style.svg);

    return new ol.style.Icon({
      src: `data:image/svg+xml;base64,${btoa(image)}`,
      size: [width, height],
      imgSize: [width, height],
      crossOrigin: 'anonymous'
    });
  }

  if (style.icon) {
    const icon = style.icon;
    return new ol.style.Icon({
      src: icon.url,
      size: style.size,
      imgSize: style.size,
      anchor: icon.anchor,
      crossOrigin: 'anonymous'
    });
  }

  return null;
};

exports.markerIconFromStyle = markerIconFromStyle;

/***/ }),
/* 273 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class Popup {
  constructor(coordinate) {
    if (!document) return;
    const target = (0, _DOM.default)('<div class="aeris__openlayers__popup"></div>');
    this._container = target; // this._container.css({
    // 	background: 'rgba(0, 0, 0, 0.9)',
    // 	borderRadius: '6px',
    // 	bottom: '100%',
    // 	color: '#fff',
    // 	display: 'block',
    // 	fontSize: '11px',
    // 	fontWeight: 'normal',
    // 	left: '50%',
    // 	lineHeight: '14px',
    // 	marginBottom: '15px',
    // 	marginLeft: '-100px',
    // 	opacity: 0,
    // 	padding: '8px 10px',
    // 	pointerEvents: 'none',
    // 	position: 'absolute',
    // 	transition: 'opacity .2s ease-out',
    // 	width: '200px',
    // 	zIndex: 10000,
    // 	'-webkit-font-smoothing': 'antialiased'
    // });

    this._overlay = new ol.Overlay({
      insertFirst: true,
      element: target[0],
      autoPan: true,
      autoPanAnimation: {
        duration: 250,
        source: null
      }
    });

    if (coordinate) {
      this.setCoordinate(coordinate);
    }
  }

  addTo(map) {
    this._map = map;
    map.addOverlay(this._overlay); // adjust left margin now that we have a valid width for the content

    const w = this._container.width();

    if (w > 0) {
      this._container.css({
        marginLeft: `-${Math.round(w / 2)}px`
      });
    }
  }

  remove() {
    if (this._map) {
      this._map.removeOverlay(this._overlay);
    }
  }

  setCoordinate(coord) {
    const [x, y] = ol.proj.fromLonLat([coord.lon, coord.lat]);

    this._overlay.setPosition([Math.round(x), Math.round(y)]);
  }

  setHTML(html) {
    this._container.html(html);
  }

  setDOMContent(node) {
    this._container.empty().append(node);
  }

  static injectStyles() {
    const css = `
			.aeris__openlayers__popup {
				background: #fff;
				border-radius: 6px;
				bottom: 100%;
				color: #222;
				display: block;
				filter: drop-shadow(0 1px 4px rgba(0,0,0,0.2));
				font-family: 'Helvetica','Arial',sans-serif;
				font-size: 13px;
				font-weight: normal;
				left: 50%;
				line-height: 14px;
				margin-bottom: 15px;
				margin-left: -100px;
				min-width: 120px;
				padding: 8px 10px;
				pointer-events: none;
				position: absolute;
				transition: opacity .2s ease-out;
				z-index: 10000;
				-webkit-font-smoothing: antialiased
			}

			.aeris__openlayers__popup:after {
				border-left: solid transparent 10px;
				border-right: solid transparent 10px;
				border-top: solid #fff 10px;
				bottom: -10px;
				content: " ";
				height: 0;
				left: 50%;
				margin-left: -9px;
				position: absolute;
				width: 0
			}
		`;
    (0, _DOM.default)('head').append(`<style type="text/css">${css}</style>`);
  }

}

var _default = Popup;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 274 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _TileSource = _interopRequireDefault(__webpack_require__(240));

var _TileLayer = _interopRequireDefault(__webpack_require__(270));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `OpenLayersTileSource` is a subclass of `TileSource` that creates and manages a single tile
 * layer to be used with an `OpenLayersMapStrategy`.
 *
 * @export
 * @class OpenLayersTileSource
 * @extends {TileSource}
 */
class OpenLayersTileSource extends _TileSource.default {
  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        this.animation.hide();
        this.updateVisibility();
      }

      if (this.overlay && this.overlay.isHidden === false && this.canShow()) {
        let url = this.urlTemplate();

        if (url) {
          const range = this.service.range();
          const s = range.filter((v, idx) => idx === 0 || idx === range.length - 1).join('-');
          url = url.replace(/\{s\}/, `{${s}}`);
        }

        this.overlay.setUrl(url);
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof OpenLayersTileSource
   */


  show() {
    if (this._hidden === false) return;
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
      this.overlay.show();
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof OpenLayersTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.hide();
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof OpenLayersTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof OpenLayersTileSource
   */


  setOpacity(value, update = true) {
    // console.log('TileSource.setOpacity', this.key, value, this._hidden);
    this._opacity = value; // if the layer is hidden, always set renderable opacity to 0

    if (this._hidden) {
      value = 0;
    }

    if (this.overlay && update === true) {
      this.overlay.setOpacity(value);
    }

    if (this.animation) {
      this.animation.setOpacity(value);
    }
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof OpenLayersTileSource
   */


  setOrder(value) {
    if (this.overlay) {
      this.overlay.setZIndex(value);
    }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, {
      type: 'tile',
      attribution: opts.attribution
    }, this.identifier);
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)((0, _utils.cloneDeep)(this._opts), {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, true);
        source.hide();

        if (wait === false) {
          resolve(source);
        }

        source.overlay.on('load', () => {
          if (wait) {
            resolve(source);
          }

          source.setOpacity(this._opacity, true);
        }); // forward source layer remove event up to the parent source

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay,
          relativeTo: this.overlay.renderable,
          offset: 1
        }); // must set opacity and hidden after added to map so the internal layer is setup;
        // tiles won't load if layer is hidden, so just set opacity to 0 and then reset when
        // loading has completed
        // source.setOpacity(0);
        // source.setOpacity(this._opacity, false);
        // source.hide();
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = OpenLayersTileSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 275 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var OpenLayers = _interopRequireWildcard(__webpack_require__(266));

var _SVG = __webpack_require__(252);

var _utils = __webpack_require__(17);

var _color = __webpack_require__(139);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class OpenLayersOverlayFactory
 * @implements {OverlayFactory}
 * @implements {PointDataSource}
 */
class OpenLayersOverlayFactory {
  /**
   * Returns a map tile source instance configured with the specified layer code and url template
   * string.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {OSMTileSource}
   * @memberof OSMOverlayFactory
   */
  tileLayer(layer, service, opts) {
    return new OpenLayers.TileSource(layer, service, opts);
  }
  /**
   * Returns a map annotation instance at the provided coordinate and configured for the
   * specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Coordinate} coord
   * @param {MarkerStyle} style
   * @returns {L.Marker}
   * @memberof OSMOverlayFactory
   */


  marker(layer, coord, style) {
    if (style) {
      // if skipped via the style, then return null
      if (style.skip && style.skip === true) {
        return null;
      }
    }

    return new OpenLayers.Marker(coord, null, {
      style
    });
  }
  /**
   * Returns an annotation icon based on the provided configuration.
   *
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  markerIcon(style) {
    if (style.html) {
      console.warn('awxjs - HTML markers are not currently supported with OpenLayers');
    }

    if (style.svg) {
      let [width, height] = style.size || [12, 12];

      if (style.svg.text) {
        const textStyle = style.svg.text;

        if ((0, _utils.isArray)(textStyle)) {
          textStyle.forEach(styleDef => {
            if (styleDef.autosize) {
              [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
            }
          });
        } else {
          const styleDef = textStyle;

          if (styleDef.autosize) {
            [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
          }
        }
      }

      height += 3;

      const image = _SVG.SVG.draw(width, height, style.svg);

      return new ol.style.Icon({
        src: `data:image/svg+xml;base64,${btoa(image)}`,
        size: [width, height],
        imgSize: [width, height],
        crossOrigin: 'anonymous'
      });
    }

    if (style.icon) {
      const icon = style.icon;
      return new ol.style.Icon({
        src: icon.url,
        size: style.size,
        imgSize: style.size,
        anchor: icon.anchor,
        crossOrigin: 'anonymous'
      });
    }

    return null;
  }
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  polygon(layer, shapes, style) {
    // generate OpenLayers options from config
    let opts;

    if (style) {
      opts = {
        stroke: null,
        fill: null
      };
      opts.id = style.id;

      if (style.stroke) {
        const {
          r,
          g,
          b
        } = (0, _color.toRGB)(style.stroke.color); // eslint-disable-line object-curly-newline

        opts.stroke = {
          color: `rgba(${r}, ${g}, ${b}, ${style.stroke.opacity || 1.0})`,
          width: style.stroke.width,
          lineCap: style.stroke.lineCap,
          lineJoin: style.stroke.lineJoin,
          lineDash: style.stroke.dashArray,
          lineDashOffset: style.stroke.dashOffset
        };
      }

      if (style.fill) {
        const {
          r,
          g,
          b
        } = (0, _color.toRGB)(style.fill.color); // eslint-disable-line object-curly-newline

        opts.fill = {
          color: `rgba(${r}, ${g}, ${b}, ${(0, _utils.isset)(style.fill.opacity) ? style.fill.opacity : 1.0})`
        };
      }
    }

    shapes.forEach(shape => {
      if (!opts.id) {
        opts.id = shape.id;
      }
    });
    return new OpenLayers.Polygon(layer, shapes, opts);
  }

  polyline(layer, points, style) {
    let opts;

    if (style) {
      opts = {
        stroke: null,
        fill: null
      };
      opts.id = style.id;

      if (style.stroke) {
        const {
          r,
          g,
          b
        } = (0, _color.toRGB)(style.stroke.color); // eslint-disable-line object-curly-newline

        opts.stroke = {
          color: `rgba(${r}, ${g}, ${b}, ${style.stroke.opacity || 1.0})`,
          width: style.stroke.width,
          lineCap: style.stroke.lineCap,
          lineJoin: style.stroke.lineJoin,
          lineDash: style.stroke.dashArray,
          lineDashOffset: style.stroke.dashOffset
        };
      }
    }

    return new OpenLayers.Polyline(layer, points, opts);
  }

}

var _default = OpenLayersOverlayFactory;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 276 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapStrategy = _interopRequireDefault(__webpack_require__(228));

var Google = _interopRequireWildcard(__webpack_require__(277));

var _GoogleOverlayFactory = _interopRequireDefault(__webpack_require__(285));

var _GoogleTileSource = _interopRequireDefault(__webpack_require__(284));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _constants = __webpack_require__(225);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// / <reference path="../../../../../node_modules/@types/googlemaps/index.d.ts" />
// declare global {
// 	const google: any
// }
let mapPanes;
/**
 * A map strategy for working with the third-party Google mapping library.
 *
 * @export
 * @class GoogleMapStrategy
 * @extends {EventDispatcher}
 * @implements {MapStrategy}
 */

class GoogleMapStrategy extends _MapStrategy.default {
  constructor(target, opts) {
    super(target, (0, _utils.extend)({
      accessToken: null
    }, opts));
    this.addAttributions = (0, _utils.debounce)(attributions => {
      if ((0, _DOM.default)('#awxjs-attribution').length > 0) return;
      const $el = (0, _DOM.default)('<div id="awxjs-attribution"></div>');
      this.map.controls[google.maps.ControlPosition.BOTTOM_LEFT].push($el[0]);
      const content = attributions.join(' | ');
      const style = {
        'background-color': 'rgba(255,255,255,0.6)',
        'font-size': '10px',
        'padding': '2px 4px 0',
        'white-space': 'nowrap'
      };
      $el.html(`<span style="${Object.keys(style).map(prop => `${prop}: ${style[prop]};`).join(' ')}">${content}</span>`);
    }, 500);
  }

  get strategy() {
    return 'google';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getDiv());
  }

  loadDependencies() {
    return new Promise((resolve, reject) => {
      if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        const version = '1.3.1';
        Promise.all([(0, _utils.loadScript)(`https://maps.googleapis.com/maps/api/js?key=${this.opts.accessToken}`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _GoogleOverlayFactory.default();
    this._callout = new google.maps.InfoWindow();
    this._eventMapping = {
      click: 'click',
      dblclick: 'dblclick',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom_changed: 'zoom',
      drag: 'move',
      dragstart: 'move:start',
      dragend: 'move:end'
    }; // set view properties from native map options if defined

    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if ((0, _utils.isPlainObject)(center) && (0, _utils.isset)(center.lat) && (0, _utils.isset)(center.lng)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: center.lat,
          lon: center.lng
        });
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of google.maps.Map
    // if an google.maps.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isGoogle)(target)) {
      this._setInitialView = false;
      this._map = target;
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      this._map = new google.maps.Map(target, (0, _utils.extend)({
        disableDefaultUI: true,
        zoomControl: true,
        zoomControlOptions: {
          position: google.maps.ControlPosition.LEFT_BOTTOM
        }
      }, this.opts.map));

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }
    } // class _DummyOverlayView extends google.maps.OverlayView {
    // 	draw() {
    // 		mapPanes = this.getPanes();
    // 	}
    // }
    // const dummy = new _DummyOverlayView();
    // dummy.setMap(this._map);


    setTimeout(() => {
      this.trigger('map:ready');
    }, 250);
  }

  setBaseStyle(style) {
    console.warn('[Aeris] `setBaseStyle` is not supported for the Google Maps strategy');
  }

  setView(center, zoom) {
    this.map.setOptions({
      center: {
        lat: center.lat,
        lng: center.lon
      },
      zoom
    });
  }

  getCenter() {
    const coord = this.map.getCenter();
    return {
      lat: coord.lat(),
      lon: coord.lng()
    };
  }

  setCenter(coord) {
    this.map.setCenter({
      lat: coord.lat,
      lng: coord.lon
    });
  }

  getZoom() {
    return this.map.getZoom();
  }

  setZoom(zoom) {
    this.map.setZoom(zoom);
  }

  getBounds() {
    const b = this.map.getBounds();

    if (b) {
      const ne = b.getNorthEast();
      const sw = b.getSouthWest();
      return {
        north: ne.lat(),
        west: sw.lng(),
        south: sw.lat(),
        east: ne.lng()
      };
    }

    return null;
  }

  setBounds(bounds) {
    const sw = new google.maps.LatLng(bounds.south, bounds.west);
    const ne = new google.maps.LatLng(bounds.north, bounds.east);
    this.map.fitBounds(new google.maps.LatLngBounds(sw, ne), 0);
  }

  fitBounds(bounds, padding = [10, 10]) {
    const sw = new google.maps.LatLng(bounds.south, bounds.west);
    const ne = new google.maps.LatLng(bounds.north, bounds.east);
    const b = new google.maps.LatLngBounds(sw, ne);
    let opts;

    if (padding.length === 1) {
      opts = padding[0];
    } else if (padding.length === 2) {
      opts = {
        top: padding[1],
        right: padding[0],
        bottom: padding[1],
        left: padding[0]
      };
    } else if (padding.length === 4) {
      opts = {
        top: padding[0],
        right: padding[1],
        bottom: padding[2],
        left: padding[3]
      };
    }

    this.map.fitBounds(b, opts);
  }

  removeAttributions() {
    (0, _DOM.default)('#awxjs-attribution').remove();
  }
  /** Sources */


  isTile(source) {
    return source instanceof _GoogleTileSource.default;
  }

  isMarker(el) {
    if (el === null || el === void 0 ? void 0 : el.renderable) {
      return el.renderable instanceof google.maps.Marker;
    }

    return el instanceof google.maps.Marker;
  }

  isPolygon(el) {
    return el instanceof google.maps.Polygon;
  }

  isPolyline(el) {
    return el instanceof google.maps.Polyline;
  }

  addSource(source) {
    super.addSource(source);

    if (source instanceof _GoogleTileSource.default && mapPanes) {
      source.node = mapPanes.mapPane.lastElementChild;
      source.node.id = `awxjs-layer-${source.identifier}`;
    }

    if (this.opts.attribution) {
      this.addAttributions([_constants.AERIS_ATTRIBUTION]);
    }
  }

  removeSource(source) {
    super.removeSource(source);

    if (this.sources.length === 0) {
      this.removeAttributions();
    }
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof Google.Tile) {
      overlay.enabled = true;
      overlay.addTo(this.map);
    } else if (overlay instanceof google.maps.ImageMapType) {
      this.map.overlayMapTypes.push(overlay);
    } else if (overlay instanceof google.maps.GroundOverlay) {
      overlay.setMap(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof Google.Tile) {
      overlay.enabled = false;
      overlay.remove();
    } else if (overlay instanceof google.maps.ImageMapType) {
      const overlayIndex = this.map.overlayMapTypes.getArray().indexOf(overlay);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
      }
    } else if (overlay instanceof google.maps.GroundOverlay) {
      overlay.setMap(null);
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Google.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof google.maps.Marker) {
      marker.setMap(this.map);
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof Google.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof google.maps.Marker) {
      marker.setMap(null);
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!options) return;

    if (marker instanceof Google.Marker) {
      marker.update(options);
    }
  }

  bindCalloutToMarker(marker, content) {
    if (this.isMarker(marker)) {
      marker.addListener('click', () => {
        this._callout.setContent(content);

        this._callout.open(this.map, marker);
      });
    }
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Google.Polygon || shape instanceof Google.Polyline) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
    } else if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.setMap(this.map);
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Google.Polygon || shape instanceof Google.Polyline) {
      shape.offAll();
      shape.remove();
    } else if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.setMap(null);
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    this.addShape(shape);
  }

  hideShape(shape) {
    this.removeShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    if (!(0, _utils.isset)(coord)) {
      return null;
    } // GoogleMaps doesn't account for current zoom level when calling `fromLatLngToPoint`, so
    // we need to calculate the point based on the current zoom ourselves


    const proj = this.map.getProjection();
    const bounds = this.map.getBounds();
    const tr = proj.fromLatLngToPoint(bounds.getNorthEast());
    const bl = proj.fromLatLngToPoint(bounds.getSouthWest());
    const scale = Math.pow(this.map.getZoom(), 2);
    const p = proj.fromLatLngToPoint(new google.maps.LatLng(coord.lat, coord.lon));
    return {
      x: (p.x - bl.x) * scale,
      y: (p.y - tr.y) * scale
    };
  }

  pointToCoord(point) {
    if (!(0, _utils.isset)(point)) {
      return null;
    } // GoogleMaps doesn't account for current zoom level when calling `fromPointToLatLng`, so
    // we need to calculate the coordinate based on the current zoom ourselves


    const proj = this.map.getProjection();
    const bounds = this.map.getBounds();
    const tr = proj.fromLatLngToPoint(bounds.getNorthEast());
    const bl = proj.fromLatLngToPoint(bounds.getSouthWest());
    const scale = Math.pow(this.map.getZoom(), 2);
    const c = proj.fromPointToLatLng(new google.maps.Point(point.x / scale * bl.x, point.y / scale + tr.y));
    return {
      lat: c.lat(),
      lon: c.lng()
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    if ((0, _utils2.isCoordObject)(target)) {
      const popup = new google.maps.InfoWindow(Object.assign(Object.assign({}, opts), {
        position: new google.maps.LatLng(target.lat, target.lon),
        content
      }));
      popup.open(this.map);
    } else if (target instanceof google.maps.Marker) {
      const popup = new google.maps.InfoWindow(Object.assign(Object.assign({}, opts), {
        content
      }));
      popup.open(this.map, target);
    }
  }

  _setupEvents() {
    super._setupEvents();

    const handleBoundsChange = () => {
      this.trigger('change:bounds');
      this.trigger('change:center');
    };

    this.map.addListener('dragend', e => {
      handleBoundsChange();
    });
    this.map.addListener('zoom_changed', e => {
      handleBoundsChange();
      this.trigger('change:zoom');
    });
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    const pixel = event.pixel || {
      x: undefined,
      y: undefined
    };
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.latLng.lat(),
            lon: event.latLng.lng()
          },
          point: {
            x: pixel.x,
            y: pixel.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = GoogleMapStrategy;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 277 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Polygon", ({
  enumerable: true,
  get: function () {
    return _PolygonLayer.default;
  }
}));
Object.defineProperty(exports, "Polyline", ({
  enumerable: true,
  get: function () {
    return _PolylineLayer.default;
  }
}));
Object.defineProperty(exports, "Tile", ({
  enumerable: true,
  get: function () {
    return _TileLayer.default;
  }
}));
Object.defineProperty(exports, "Marker", ({
  enumerable: true,
  get: function () {
    return _Marker.default;
  }
}));
Object.defineProperty(exports, "TileSource", ({
  enumerable: true,
  get: function () {
    return _GoogleTileSource.default;
  }
}));

var _PolygonLayer = _interopRequireDefault(__webpack_require__(278));

var _PolylineLayer = _interopRequireDefault(__webpack_require__(280));

var _TileLayer = _interopRequireDefault(__webpack_require__(281));

var _Marker = _interopRequireDefault(__webpack_require__(282));

var _GoogleTileSource = _interopRequireDefault(__webpack_require__(284));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 278 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(279));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GooglePolygonLayer extends _Layer.default {
  constructor(layer, polygons, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._polygons = polygons;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.renderable) {
      this.renderable.forEach(polygon => polygon.setOptions(Object.assign(Object.assign({}, this.opts), {
        fillOpacity: this.opts.fillOpacity * value,
        strokeOpacity: this.opts.strokeOpacity * value
      })));
    }
  }

  createRenderable() {
    const groups = [];
    const opts = this.opts; // need to combine all polygon coordinate paths into a single grouped array for the multi
    // polygon layer

    this._polygons.forEach(shape => {
      const outer = shape.outer.map(coord => ({
        lat: coord.lat,
        lng: coord.lon
      }));
      const inner = shape.inner.map(polygon => polygon.map(coord => ({
        lat: coord.lat,
        lng: coord.lon
      })));
      opts.paths = [outer].concat(inner);
      const p = new google.maps.Polygon(Object.assign(Object.assign({}, opts), {
        fillOpacity: this.opts.fillOpacity * this.opacity,
        opacity: this.opts.strokeOpacity * this.opacity
      }));
      p.addListener('click', () => this.trigger('click', {
        polygon: this
      }));
      p.addListener('mouseover', () => this.trigger('mouseover', {
        polygon: this
      }));
      p.addListener('mouseout', () => this.trigger('mouseout', {
        polygon: this
      }));
      groups.push(p);
    });

    return groups;
  }

  addToMap(map) {
    if (this.renderable) {
      this.renderable.forEach(polygon => polygon.setMap(map));
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      this.renderable.forEach(polygon => polygon.setMap(null));
    }
  }

}

var _default = GooglePolygonLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 279 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapLayer = _interopRequireDefault(__webpack_require__(246));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/@types/googlemaps/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `Layer` is a container class that is responsible for creating and managing a Google Maps
 * source and associated layer representation on a Google Maps map.
 */
class GoogleLayer extends _MapLayer.default {
  invalidate() {}

  createRenderable() {
    return undefined;
  }

  updateVisibility(visible) {}

  addToMap(map) {
    if (this.renderable) {
      this.renderable.setMap(map);
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      this.renderable.setMap(null);
    }
  }

}

var _default = GoogleLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 280 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(279));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/googlemaps/index.d.ts" />

/* eslint-enable spaced-comment */
class GooglePolylineLayer extends _Layer.default {
  constructor(layer, points, opts = undefined, id = undefined) {
    super(layer, opts, id);
    this._points = points;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.renderable) {
      this.renderable.setOptions(Object.assign(Object.assign({}, this.opts), {
        strokeOpacity: value
      }));
    }
  }

  createRenderable() {
    const renderable = new google.maps.Polyline(Object.assign(Object.assign({}, this.opts), {
      path: this._points.map(coord => ({
        lat: coord.lat,
        lng: coord.lon
      }))
    }));
    renderable.addListener('click', () => this.trigger('click', {
      polyline: this
    }));
    renderable.addListener('mouseover', () => this.trigger('mouseover', {
      polyline: this
    }));
    renderable.addListener('mouseout', () => this.trigger('mouseout', {
      polyline: this
    }));
    return renderable;
  }

  addToMap(map) {
    if (this.renderable) {
      this.renderable.setMap(map);
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      this.renderable.setMap(null);
    }
  }

}

var _default = GooglePolylineLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 281 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(279));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GoogleTileLayer extends _Layer.default {
  setOpacity(value) {
    super.setOpacity(value);

    if (this.renderable) {
      this.renderable.setOpacity(value);
    }
  }

  setZIndex(index) {
    if (this.map && this.renderable) {
      const overlayIndex = this.map.overlayMapTypes.getArray().indexOf(this.renderable);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
        this.map.overlayMapTypes.insertAt(index, this.renderable);
      }
    }
  }

  updateVisibility(visible) {
    if (this.renderable) {
      this.renderable.setOpacity(visible ? this.opacity : 0);
    }
  }

  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }

  invalidate() {
    const map = this.map;
    this.remove();
    setTimeout(() => {
      if (this.enabled) {
        this.addTo(map);
      }
    }, 200);
  }

  createRenderable() {
    const renderable = new google.maps.ImageMapType({
      name: this.id,
      opacity: this.opacity,
      tileSize: new google.maps.Size(256, 256),
      getTileUrl: (tileCoord, zoom) => {
        let url = this.opts.url;

        if (!(0, _utils.isset)(url)) {
          return null;
        }

        const vars = {
          x: tileCoord.x,
          y: tileCoord.y,
          z: zoom,
          s: Math.abs(tileCoord.x + tileCoord.y) % 4 + 1
        };
        Object.keys(vars).forEach(k => {
          url = url.replace(new RegExp(`{${k}}`), `${vars[k]}`);
        });
        return url;
      }
    });
    google.maps.event.addListenerOnce(renderable, 'tilesloaded', () => {
      this.trigger('load', {
        overlay: renderable
      });
    });
    return renderable;
  }

  addToMap(map) {
    if (this.renderable) {
      if (this.opts.zIndex >= 0) {
        // const overlayArray = this.map.overlayMapTypes.getArray()
        map.overlayMapTypes.insertAt(this.opts.zIndex, this.renderable);
      } else {
        map.overlayMapTypes.push(this.renderable);
      }
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      google.maps.event.clearListeners(this.renderable, 'tilesloaded');
      const overlayIndex = this.map.overlayMapTypes.getArray().indexOf(this.renderable);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
      }
    }
  }

}

var _default = GoogleTileLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 282 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _MapMarker = _interopRequireDefault(__webpack_require__(250));

var _utils2 = __webpack_require__(283);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
// /<reference path="../../../../../node_modules/@types/googlemaps/index.d.ts" />

/* eslint-enable spaced-comment */
class GoogleMarker extends _MapMarker.default {
  update(opts) {
    var _a;

    if (!(0, _utils.isset)(opts)) return;
    const value = (_a = opts.data) === null || _a === void 0 ? void 0 : _a.value;
    let style = opts.style || {};

    if ((0, _utils.isFunction)(style)) {
      style = style({
        value
      });
    }

    this.setStyle(style);
  }

  setStyle(style) {
    const icon = (0, _utils2.markerIconFromStyle)(style);

    if (icon) {
      this.renderable.setIcon(icon);
    }
  }

  createRenderable() {
    const {
      style
    } = this.opts;
    const coord = this.coordinate;
    const opts = {};

    if (style) {
      opts.icon = (0, _utils2.markerIconFromStyle)(style);

      if (style.zIndex) {
        opts.zIndex = style.zIndex;
      }
    }

    const renderable = new google.maps.Marker((0, _utils.extend)({
      position: new google.maps.LatLng(coord.lat, coord.lon),
      optimized: false
    }, opts));

    if (style && style.callout) {
      let content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        const fn = style.callout;
        content = fn();
      } // const popup = L.popup().setContent(content);
      // marker.bindPopup(popup);

    }

    return renderable;
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    const renderable = this.renderable;

    if (renderable) {
      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          renderable[handlerName].remove();
        } else {
          renderable[handlerName] = renderable.addListener(name, () => {
            this.trigger(name, {
              data: this.data,
              marker: renderable
            });
          });
        }
      });

      renderable.setMap(map);
    }
  }

  removeFromMap(map) {
    const renderable = this.renderable;

    if (renderable) {
      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          renderable[handlerName].remove();
        }
      });

      renderable.setMap(null);
    }
  }

}

var _default = GoogleMarker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 283 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.markerIconFromStyle = exports.formatLayerOptions = void 0;

var _SVG = __webpack_require__(252);

var _utils = __webpack_require__(17);

const formatLayerOptions = opts => {
  const formatted = {};

  if (opts.stroke) {
    formatted.strokeColor = opts.stroke.color;
    formatted.strokeOpacity = opts.stroke.opacity;
    formatted.strokeWeight = opts.stroke.width; // formatted.lineCap = opts.stroke.lineCap;
    // formatted.lineJoin = opts.stroke.lineJoin;
    // formatted.dashArray = opts.stroke.dashArray;
    // formatted.dashOffset = opts.stroke.dashOffset;
  } else {
    formatted.strokeOpacity = 0;
  }

  if (opts.fill) {
    formatted.fillColor = opts.fill.color;
    formatted.fillOpacity = opts.fill.opacity;
  } else {
    formatted.fillOpacity = 0;
  }

  if (!(0, _utils.isset)(opts.fillOpacity)) opts.fillOpacity = 1;
  if (!(0, _utils.isset)(opts.strokeOpacity)) opts.strokeOpacity = 1;
  return formatted;
};

exports.formatLayerOptions = formatLayerOptions;

const markerIconFromStyle = style => {
  // html marker not supported, would require custom overlay
  // re: https://humaan.com/blog/custom-html-markers-google-maps/
  if (style.html) {
    console.warn('awxjs - HTML markers are not currently supported with Google Maps');
  }

  if (style.svg) {
    let [width, height] = style.size || [12, 12];

    if (style.svg.text) {
      const textStyle = style.svg.text;

      if ((0, _utils.isArray)(textStyle)) {
        textStyle.forEach(styleDef => {
          if (styleDef.autosize) {
            [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
          }
        });
      } else {
        const styleDef = textStyle;

        if (styleDef.autosize) {
          [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
        }
      }
    }

    height += 3;

    const image = _SVG.SVG.draw(width, height, style.svg);

    return {
      url: `data:image/svg+xml;base64,${btoa(image)}`,
      size: new google.maps.Size(width, height),
      scaledSize: new google.maps.Size(width, height),
      anchor: new google.maps.Point(width / 2, height / 2)
    };
  }

  if (style.icon) {
    const icon = style.icon;
    const options = {
      url: icon.url,
      size: new google.maps.Size(style.size[0], style.size[1]),
      scaledSize: new google.maps.Size(style.size[0], style.size[1])
    };

    if (icon.anchor && icon.anchor.length === 2) {
      options.anchor = new google.maps.Point(icon.anchor[0], icon.anchor[1]);
    }

    return options;
  }

  return null;
};

exports.markerIconFromStyle = markerIconFromStyle;

/***/ }),
/* 284 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _TileSource = _interopRequireDefault(__webpack_require__(240));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

var _TileLayer = _interopRequireDefault(__webpack_require__(281));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/googlemaps/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `GoogleTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `GoogleMapStrategy`.
 *
 * @export
 * @class LeafletTileSource
 * @extends {TileSource}
 */
class GoogleTileSource extends _TileSource.default {
  constructor(key, service, opts) {
    var _a;

    super(key, service, opts);
    this._layerRemovedWhileLoading = false;
    /**
     * Animation Providers
     */

    this._tileLoadCheckInterval = null; // need to listen for reset events on the animation so that we can remove any actively
    // loading Google layer while in the middle of loading

    (_a = this.animation) === null || _a === void 0 ? void 0 : _a.on('reset', () => {
      if (this._loadingSource) {
        this.trigger('layer:remove', {
          layer: this._loadingSource.overlay
        });
      }
    });
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        this.animation.hide();
        this.updateVisibility();
      }

      if (this.overlay && this.overlay.isHidden === false && this.canShow()) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof GoogleTileSource
   */


  show() {
    if (this._hidden === false) return;
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof GoogleTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.setOpacity(0);
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof GoogleTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof GoogleTileSource
   */


  setOpacity(value, update = true) {
    this._opacity = value;

    if (this.overlay && update === true && this.isVisible()) {
      this.overlay.setOpacity(value);
    }

    if (this.animation) {
      this.animation.setOpacity(value);
    }
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof GoogleTileSource
   */


  setOrder(value) {
    this.overlay.setZIndex(value); // if (this.node && this.node instanceof HTMLElement) {
    // 	this.node.style.zIndex = value.toString();
    // }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, {
      opacity: (0, _utils.isset)((0, _utils.get)(opts, 'style.opacity')) ? (0, _utils.get)(opts, 'style.opacity') : 1,
      zIndex: (0, _utils.get)(opts, 'style.zIndex')
    }, this.identifier);
    overlay.on('map:add', e => {
      const {
        map
      } = e.data || {};

      if (map) {
        google.maps.event.addListener(map.overlayMapTypes, 'remove_at', (index, removed) => {
          this._layerRemovedWhileLoading = true;
        });
      }
    });
    return overlay;
  }

  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          data: {
            service: this.service
          },
          style: {
            opacity: 0
          }
        }));
        source.isAnimationFrame = true; // source.setOpacity(this._opacity, false);

        source.hide();

        const onLoad = () => {
          resolve(source);
          this._loadingSource = null;
        };

        this._loadingSource = source;

        if (wait) {
          // hack to handle cases where layers are removed while other layers are loading, which mutates the map.overlayMapTypes
          // array and prevents the currently loading layer from triggering its `tilesloaded` event for some reason.
          this._tileLoadCheckInterval = setTimeout(() => {
            if (this._layerRemovedWhileLoading) {
              onLoad();
            }

            this._layerRemovedWhileLoading = false;
          }, 2000);
          source.overlay.once('load', () => {
            if (this._tileLoadCheckInterval) {
              window.clearInterval(this._tileLoadCheckInterval);
            }

            this._tileLoadCheckInterval = null;
            onLoad();
          });
        } else {
          onLoad();
        } // forward source layer remove event up to the parent source


        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = GoogleTileSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 285 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var Google = _interopRequireWildcard(__webpack_require__(277));

var _utils = __webpack_require__(283);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// /<reference path="../../../../../node_modules/@types/googlemaps/index.d.ts" />

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class LeafletOverlayFactory
 * @implements {OverlayFactory}
 * @implements {PointDataSource}
 */
class GoogleOverlayFactory {
  /**
   * Returns a map tile source instance configured with the specified layer code and url template
   * string.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {OSMTileSource}
   * @memberof OSMOverlayFactory
   */
  tileLayer(layer, service, opts) {
    return new Google.TileSource(layer, service, opts);
  }
  /**
   * Returns a map annotation instance at the provided coordinate and configured for the
   * specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Coordinate} coord
   * @param {MarkerStyle} style
   * @returns {L.Marker}
   * @memberof OSMOverlayFactory
   */


  marker(layer, coord, style) {
    if (style) {
      // if skipped via the style, then return null
      if (style.skip && style.skip === true) {
        return null;
      }
    }

    return new Google.Marker(coord, null, {
      style
    });
  }
  /**
   * Returns a polygon layer for the specified shapes and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OSMOverlayFactory
   */


  polygon(layer, shapes, style) {
    let opts;

    if (style) {
      opts = (0, _utils.formatLayerOptions)(style);
    }

    return new Google.Polygon(layer, shapes, opts);
  }
  /**
   * Returns a polyline layer for the specified points and configuration.
   *
   * @param layer
   * @param points
   * @param style
   * @returns
   */


  polyline(layer, points, style) {
    let opts;

    if (style) {
      opts = (0, _utils.formatLayerOptions)(style);
    }

    return new Google.Polyline(layer, points, opts);
  }

}

var _default = GoogleOverlayFactory;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 286 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _style = _interopRequireDefault(__webpack_require__(287));

var _Layers = __webpack_require__(300);

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class that manages the configuration and style providers based on layer code.
 *
 * @export
 * @class MapLayerConfig
 */
class MapLayerConfig {
  /**
   * Initializes and returns a map configuration instance with the provided styles.
   *
   * @param {({ [key: string]: LayerStyleGroups | LayerStyle })} [styles]
   * @memberof MapLayerConfig
   */
  constructor(styles) {
    this._configs = {
      'air-quality': _style.default.airquality,
      'convective': _style.default.convectiveOutlook,
      'drought-monitor': _style.default.droughtMonitor,
      earthquakes: _style.default.earthquakes,
      fires: _style.default.fires,
      'fire-outlook': _style.default.fireOutlook,
      'lightning-strikes': _style.default.lightningStrikes,
      records: _style.default.records,
      'river-observations': _style.default.rivers,
      stormcells: _style.default.stormcells,
      stormreports: _style.default.stormreports,
      text: _style.default.text
    };
    if (styles) this.setStyles(styles);
  }
  /**
   * Returns the layer configuration for the specified layer code.
   *
   * @param {string} layer
   * @returns {LayerOptions}
   * @memberof MapLayerConfig
   */


  getConfig(layer) {
    return this._configs[layer];
  }

  setConfig(layer, config) {
    this._configs[layer] = config;
  }
  /**
   * Sets the style(s) for the specified layer code.
   *
   * @param {string} layer
   * @param {(LayerStyleGroups | LayerStyle)} style
   * @memberof MapLayerConfig
   */


  setStyle(layer, style) {
    const config = this.getConfig(layer) || {};

    if ((0, _Layers.isTile)(layer)) {
      let rasterStyle;

      if (style.raster) {
        rasterStyle = style.raster;
      } else {
        rasterStyle = style;
      }

      config.style = (0, _utils.extend)(config.style, rasterStyle);
    } else if ((0, _Layers.isVector)(layer) || (0, _Layers.isText)(layer)) {
      let markerStyle;
      let polygonStyle;
      let polylineStyle;
      const grouped = (0, _utils.isset)(style.marker) || (0, _utils.isset)(style.polygon) || (0, _utils.isset)(style.polyline);

      if (style.marker) {
        markerStyle = style.marker;
      } else if (grouped === false) {
        markerStyle = style;
      }

      if (style.polygon) {
        polygonStyle = style.polygon;
      } else if (grouped === false) {
        polygonStyle = style;
      }

      if (style.polyline) {
        polylineStyle = style.polyline;
      } else if (grouped === false) {
        polylineStyle = style;
      }

      config.style = (0, _utils.extend)(config.style, {
        marker: markerStyle,
        polygon: polygonStyle,
        polyline: polylineStyle
      });
    }

    this._configs[layer] = (0, _utils.cloneDeep)(config);
  }
  /**
   * Sets the style(s) for the specified layers.
   *
   * @param {({ [layer: string]: LayerStyleGroups | LayerStyle })} layers
   * @memberof MapLayerConfig
   */


  setStyles(layers) {
    Object.keys(layers).forEach(layer => this.setStyle(layer, layers[layer]));
  }
  /**
   * Returns the style associated with the specified layer code, if any.
   *
   * @param {string} layer
   * @param {(( 'raster' | 'marker' | 'polygon' | 'polyline'))} type
   * @returns {LayerStyle}
   * @memberof MapLayerConfig
   */


  getStyle(layer, type) {
    const config = this.getConfig(layer);

    if (config) {
      const style = config.style;

      if (style[type]) {
        return style[type];
      }

      return style;
    }

    return undefined;
  }
  /**
   * Sets the text style to use for text annotations.
   *
   * @param {ShapeStyle} style
   * @memberof MapLayerConfig
   */


  setTextStyle(style) {
    this.setStyle('text', {
      marker: style
    });
  }
  /**
   * Returns the text style.
   *
   * @returns {ShapeStyle}
   * @memberof MapLayerConfig
   */


  getTextStyle() {
    return this.getStyle('text', 'marker');
  }

}

var _default = MapLayerConfig;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 287 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.configForLayer = void 0;

var _airquality = _interopRequireDefault(__webpack_require__(288));

var _convectiveoutlook = _interopRequireDefault(__webpack_require__(289));

var _droughtmonitor = _interopRequireDefault(__webpack_require__(290));

var _earthquakes = _interopRequireDefault(__webpack_require__(291));

var _fires = _interopRequireDefault(__webpack_require__(292));

var _fireOutlook = _interopRequireDefault(__webpack_require__(293));

var _lightningStrikes = _interopRequireDefault(__webpack_require__(294));

var _records = _interopRequireDefault(__webpack_require__(295));

var _rivers = _interopRequireDefault(__webpack_require__(296));

var _stormcells = _interopRequireDefault(__webpack_require__(297));

var _stormreports = _interopRequireDefault(__webpack_require__(298));

var _text = _interopRequireDefault(__webpack_require__(299));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MAPPING = {
  'air-quality': _airquality.default,
  'convective': _convectiveoutlook.default,
  'drought-monitor': _droughtmonitor.default,
  earthquakes: _earthquakes.default,
  fires: _fires.default,
  'fire-outlook': _fireOutlook.default,
  'lightning-strikes': _lightningStrikes.default,
  records: _records.default,
  'river-observations': _rivers.default,
  stormcells: _stormcells.default,
  stormreports: _stormreports.default,
  text: _text.default
};

const configForLayer = layer => MAPPING[layer];

exports.configForLayer = configForLayer;
var _default = {
  airquality: _airquality.default,
  convectiveOutlook: _convectiveoutlook.default,
  droughtMonitor: _droughtmonitor.default,
  earthquakes: _earthquakes.default,
  fires: _fires.default,
  fireOutlook: _fireOutlook.default,
  lightningStrikes: _lightningStrikes.default,
  records: _records.default,
  rivers: _rivers.default,
  stormcells: _stormcells.default,
  stormreports: _stormreports.default,
  text: _text.default
};
exports["default"] = _default;

/***/ }),
/* 288 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const color = (code = '') => {
  code = code.toLowerCase().replace(/\s/, '-');

  switch (code) {
    case 'good':
      return '#29e11f';

    case 'moderate':
      return '#f8f92a';

    case 'usg':
      return '#f9681b';

    case 'unhealthy':
      return '#f60115';

    case 'very-unhealthy':
      return '#7a2c83';

    case 'hazardous':
      return '#65001b';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const size = (code = '') => {
  code = code.toLowerCase().replace(/\s/, '-');

  switch (code) {
    case 'moderate':
      return 12;

    case 'usg':
      return 14;

    case 'unhealthy':
      return 18;

    case 'very-unhealthy':
      return 20;

    case 'hazardous':
      return 24;

    default:
      return 10;
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'airquality'
    },
    properties: {
      id: 'id',
      timestamp: 'timestamp'
    }
  },
  style: {
    marker: data => {
      const period = (0, _utils.get)(data, 'periods.0');

      if (!period) {
        return {
          skip: true
        };
      }

      const type = (0, _utils.get)(period, 'category');

      if (!type) {
        return {
          skip: true
        };
      }

      const width = size(type);
      return {
        className: 'marker-airquality',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(type)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [width, width]
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 289 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const colors = {
  default: '#000000',
  general: '#b3e6b1',
  marginal: '#6cbd69',
  slight: '#f4f964',
  enhanced: '#e0b767',
  moderate: '#e0686a',
  high: '#fe59ff'
};
/**
 * @private
*/

const config = {
  data: {
    request: {
      endpoint: 'convective/outlook',
      action: "search"
      /* SEARCH */
      ,
      parameters: {
        filter: 'geo'
      }
    },
    properties: {
      id: 'id',
      category: 'details.risk.type',
      timestamp: {
        from: 'details.range.minTimestamp',
        to: 'details.range.maxTimestamp'
      },
      path: 'geoPoly'
    }
  },
  style: {
    polygon: data => {
      const type = (0, _utils.get)(data, 'details.risk.type');
      return {
        fill: {
          color: colors[type] || colors.default,
          opacity: 1
        }
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 290 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const color = (code = '') => {
  code = code.toLowerCase();

  switch (code) {
    case 'd0':
      return '#ffff00';

    case 'd1':
      return '#fccc66';

    case 'd2':
      return '#ff9b00';

    case 'd3':
      return '#e10000';

    case 'd4':
      return '#600000';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'droughts/monitor',
      action: "search"
      /* SEARCH */
      ,
      parameters: {
        filter: 'geo'
      }
    },
    properties: {
      id: 'id',
      category: 'details.category',
      timestamp: {
        from: 'details.range.minTimestamp',
        to: 'details.range.maxTimestamp'
      },
      path: 'geoPoly'
    }
  },
  style: {
    polygon: data => {
      const type = (0, _utils.get)(data, 'details.category');
      return {
        fill: {
          color: color(type),
          opacity: 1
        }
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 291 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const color = (code = '') => {
  code = code.toLowerCase().replace(/\s/, '-');

  switch (code) {
    case 'mini':
      return '#6fb314';

    case 'minor':
      return '#dfcb01';

    case 'light':
      return '#ce8f00';

    case 'moderate':
      return '#ff5d01';

    case 'strong':
      return '#e90004';

    case 'major':
      return '#ce0052';

    case 'great':
      return '#b90285';

    case 'catastrophic':
      return '#f500ff';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const size = (code = '') => {
  code = code.toLowerCase().replace(/\s/, '-');

  switch (code) {
    case 'minor':
      return 18;

    case 'light':
      return 20;

    case 'moderate':
      return 22;

    case 'strong':
      return 26;

    case 'major':
      return 30;

    case 'great':
      return 36;

    case 'catastrophic':
      return 42;

    default:
      return 16;
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'earthquakes'
    },
    properties: {
      id: 'report.id',
      timestamp: 'report.timestamp'
    }
  },
  style: {
    marker: data => {
      let type = (0, _utils.get)(data, 'report.type');
      const magnitude = (0, _utils.get)(data, 'report.mag');

      if (magnitude >= 9) {
        type = 'catastrophic';
      }

      const width = size(type);
      return {
        className: 'marker-earthquake',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(type)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [width, width]
      };
    }
  },
  animation: {
    enabled: true
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 292 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

/**
 * @private
*/
const config = {
  data: {
    request: {
      endpoint: 'fires'
    },
    properties: {
      id: 'report.id',
      timestamp: 'report.timestamp'
    }
  },
  style: {
    marker: data => {
      const width = 12;
      return {
        className: 'marker-earthquake',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: '#ff0000'
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [width, width]
      };
    }
  },
  animation: {
    enabled: true
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 293 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

const color = (code = '') => {
  code = code.toLowerCase();

  switch (code) {
    case 'elevated':
      return '#ffb367';

    case 'critical':
      return '#ff666a';

    case 'extreme':
      return '#fe59ff';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'fires/outlook',
      action: "search"
      /* SEARCH */
      ,
      parameters: {
        filter: 'geo'
      }
    },
    properties: {
      id: 'id',
      path: 'geoPoly',
      category: 'details.risk.type',
      timestamp: {
        from: 'details.range.minTimestamp',
        to: 'details.range.maxTimestamp'
      }
    }
  },
  style: {
    polygon: data => {
      const type = (0, _utils.get)(data, 'details.risk.type');
      return {
        fill: {
          color: color(type),
          opacity: 0.7
        }
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 294 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const color = delta => {
  if (delta < 1) {
    return '#f5f5f5';
  }

  if (delta < 5) {
    return '#dddddd';
  }

  if (delta < 10) {
    return '#bbbbbb';
  }

  if (delta < 15) {
    return '#888888';
  }

  return '#545454';
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'lightning'
    },
    properties: {
      id: 'id',
      timestamp: 'ob.timestamp'
    }
  },
  style: {
    marker: data => {
      const ts = (0, _utils.get)(data, 'ob.timestamp');

      if (!ts) {
        return null;
      }

      const delta = (new Date().getTime() - ts * 1000) / (1000 * 60);
      return {
        className: 'marker-record',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(delta)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [14, 14]
      };
    }
  },
  animation: {
    enabled: true
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 295 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const color = (code = '') => {
  code = code.toLowerCase().replace(/\s/, '-');

  switch (code) {
    case 'prcp':
      return '#2ef000';

    case 'snow':
      return '#004fff';

    case 'hsnd':
      return '#e402a4';

    case 'maxt':
      return '#ff4b00';

    case 'mint':
      return '#8700ff';

    case 'himn':
      return '#eef500';

    case 'lomx':
      return '#37b9f8';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'records'
    },
    properties: {
      id: 'id',
      timestamp: 'report.timestamp'
    }
  },
  style: {
    marker: data => {
      const type = (0, _utils.get)(data, 'report.type');
      return {
        className: 'marker-record',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(type)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [14, 14]
      };
    }
  },
  animation: {
    enabled: true
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 296 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

const color = (code = '') => {
  code = code.toLowerCase().replace(/\s/, '-');

  switch (code) {
    case 'out_of_service':
      return '#535353';

    case 'obs_not_current':
      return '#afb6ad';

    case 'not_defined':
      return '#5f9de6';

    case 'low_threshold':
      return '#7e5012';

    case 'no_flooding':
      return '#0cff01';

    case 'action':
      return '#ffff02';

    case 'minor':
      return '#ff8700';

    case 'moderate':
      return '#ff0000';

    case 'major':
      return '#c000ff';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'rivers'
    },
    properties: {
      id: 'id',
      timestamp: 'ob.timestamp'
    }
  },
  style: {
    marker: data => {
      const type = (0, _utils.get)(data, 'ob.status');
      return {
        className: 'marker-river',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(type)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [14, 14]
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 297 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

const color = (code = '') => {
  code = code.toLowerCase();

  switch (code) {
    case 'general':
      return '#2ED300';

    case 'hail':
      return '#EBE100';

    case 'rotating':
      return '#F17200';

    case 'tornado':
      return '#FF2600';

    default:
      return '#000000';
  }
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'stormcells'
    },
    properties: {
      id: 'id',
      path: 'forecast.cone.wide',
      category: 'traits.type',
      timestamp: 'ob.timestamp'
    },
    reversedCoord: true
  },
  style: {
    marker: data => {
      const type = (0, _utils.get)(data, 'traits.type');
      return {
        className: 'marker-stormcell',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(type)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [12, 12]
      };
    },
    polygon: data => {
      const type = (0, _utils.get)(data, 'traits.type');
      return {
        fill: {
          color: color(type),
          opacity: 0.5
        }
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 298 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

var _utils = __webpack_require__(17);

/**
 * @private
*/
const color = (code = '') => {
  code = code.toLowerCase();

  switch (code) {
    case 'avalanche':
      return '#639fec';

    case 'blizzard':
      return '#4100e2';

    case 'flood':
      return '#117d00';

    case 'fog':
      return '#767676';

    case 'ice':
      return '#e100e2';

    case 'hail':
      return '#62def7';

    case 'lightning':
      return '#8c8c8c';

    case 'rain':
      return '#38e600';

    case 'snow':
      return '#175cef';

    case 'tides':
      return '#40db83';

    case 'tornado':
      return '#c50000';

    case 'tropical':
      return '#FF5D00';

    case 'wind':
      return '#d8cc00';

    default:
      return '#555555';
  }
};
/**
 * @private
*/


const reportValue = (type, detail, metric = false) => {
  detail = detail || {};

  if (/\brain\b/.test(type)) {
    return metric ? `${(detail.rainMM || 0).toFixed(1)} mm` : `${(detail.rainIN || 0).toFixed(2)} in`;
  }

  if (/\bsnow\b/.test(type)) {
    return metric ? `${(detail.snowCM || 0).toFixed(1)} cm` : `${(detail.snowIN || 0).toFixed(1)} in`;
  }

  if (/\bhail\b/.test(type)) {
    return metric ? `${(detail.hailCM || 0).toFixed(1)} cm` : `${(detail.hailIN || 0).toFixed(1)} in`;
  }

  if (/\bwind\b/.test(type)) {
    return metric ? `${detail.windSpeedKMH} kmh` : `${detail.windSpeedMPH} mph`;
  }

  return null;
};
/**
 * @private
*/


const config = {
  data: {
    request: {
      endpoint: 'stormreports'
    },
    properties: {
      id: 'id',
      timestamp: 'report.timestamp'
    }
  },
  style: {
    marker: data => {
      const type = (0, _utils.get)(data, 'report.cat');
      return {
        className: 'marker-stormreport',
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: color(type)
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [14, 14]
      };
    }
  },
  animation: {
    enabled: true
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 299 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.config = void 0;

/**
 * @private
*/
const config = {
  style: {
    marker: data => {
      const width = 50;
      const height = 16;
      const textSize = 14;
      return {
        className: 'marker-text',
        svg: {
          text: {
            value: data.value || '',
            x: width / 2,
            y: Math.round(height - (height - textSize * 0.7) / 2),
            size: textSize,
            style: 'bold',
            color: 'rgb(0,0,0)',
            autosize: true
          }
        },
        spacing: 20
      };
    }
  }
};
exports.config = config;
var _default = config;
exports["default"] = _default;

/***/ }),
/* 300 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.isValidLayer = exports.getInvalidLayers = exports.isTile = exports.isText = exports.isVector = exports.isShape = exports.isPoint = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _Http = _interopRequireDefault(__webpack_require__(101));

var _utils = __webpack_require__(17);

var _LayerTimes = _interopRequireDefault(__webpack_require__(301));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 */
let _data;

let _modifiers = [];
const pointLayers = ['air-quality', 'earthquakes', 'fires', 'records', 'river-observations', 'stormreports'];

const isPoint = layer => pointLayers.indexOf(layer) !== -1;

exports.isPoint = isPoint;
const shapeLayers = ['convective', 'drought-monitor', 'fire-outlook', 'tropical-cyclones-break-points'];

const isShape = layer => shapeLayers.indexOf(layer) !== -1;

exports.isShape = isShape;
const vectorLayers = pointLayers.concat(shapeLayers).concat(['stormcells', 'tropical-cyclones']);

const isVector = layer => vectorLayers.indexOf(layer) !== -1;

exports.isVector = isVector;
const textLayers = ['observations'];

const isText = layer => textLayers.indexOf(layer) !== -1;

exports.isText = isText;

const isTile = layer => !isVector(layer) && !isText(layer);

exports.isTile = isTile;

const getInvalidLayers = layer => {
  if (!(0, _utils.isset)(layer) || !(0, _utils.isString)(layer)) return [];
  layer = layer.replace(/\:.+$/, '');

  const ids = (_data || []).map(config => config.id);

  const layers = (layer || '').split(',');
  const codes = []; // iterate through each layer code and check if it exists in the allowed layer ids
  // if not, then strip off each valid modifier to use as the code check

  layers.forEach(code => {
    if (ids.indexOf(code) === -1) {
      _modifiers.forEach(m => {
        code = code.replace(new RegExp(`-${m}`), '');
      });
    }

    codes.push(code);
  });
  const matches = [];
  codes.forEach(code => {
    code = code.replace(/\:.*$/, '');
    const found = ids.indexOf(code) !== -1 || isVector(code) || isText(code);

    if (!found) {
      matches.push(code);
    }
  });
  return matches;
};

exports.getInvalidLayers = getInvalidLayers;

const isValidLayer = layer => {
  const matches = getInvalidLayers(layer);
  return matches.length === 0;
};
/**
 * A `Layers` object is responsible for fetching and caching Aeris Maps (AMP) layers metadata as
 * well as providing utility methods for returning and comparing layer information.
 *
 * @export
 * @class Layers
 * @extends {EventDispatcher}
 */


exports.isValidLayer = isValidLayer;

class Layers extends _EventDispatcher.default {
  /**
   * Initializes and returns a new Layers instance.
   *
   * Layer metadata will be requested immediate if it has not already been cached by the library.
   *
   * @memberof Layers
   */
  constructor(account) {
    super();
    this._groups = {};
    this._loading = false;
    this._validTimes = new _LayerTimes.default(account);

    if ((0, _utils.isset)(_data)) {
      this._process(_data);
    } else {
      this.fetch();
    }
  }
  /**
   * Returns the `LayerTimes` instance that can be used to fetch and return the valid times for
   * AerisWeather Maps layers.
   *
   * @readonly
   * @type {LayerTimes}
   * @memberof Layers
   */


  get validTimes() {
    return this._validTimes;
  }
  /**
   * Return the layer metadata.
   *
   * If the data has not already been loaded and cached, this method will perform a new
   * request before resolving the Promise with the data.
   *
   * @returns
   * @memberof Layers
   */


  fetch() {
    return new Promise((resolve, reject) => {
      // always return a copy of our _data object in case callers try to change the data contained within
      if (_data) {
        resolve((0, _utils.cloneDeep)(_data));
      } else if (this._loading) {
        this.on('load:done', e => {
          resolve((0, _utils.cloneDeep)(_data));
        });
      } else {
        this._fetchLayerMetadata().then(data => {
          resolve((0, _utils.cloneDeep)(_data));
        });
      }
    }).catch(e => {
      console.error(`[Aeris] Failed to load map layer metadata - ${e}`);
    });
  }
  /**
   * Returns whether layer metadata is already cached.
   *
   * @returns {boolean}
   * @memberof Layers
   */


  cached() {
    return _data !== undefined;
  }
  /**
   * Returns whether layer metadata is currently being requested.
   *
   * @returns {boolean}
   * @memberof Layers
   */


  loading() {
    return this._loading;
  }
  /**
   * Returns the layer groups.
   *
   * @returns {*}
   * @memberof Layers
   */


  groups() {
    return this._groups;
  }
  /**
   * Returns whether the layer for the identifier is part of the specified group.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} id
   * @param {string} group
   * @param {boolean} [strict=false]
   * @returns {boolean}
   * @memberof Layers
   */


  inGroup(id, group, strict = false) {
    const groupLayers = this._groups[group];
    id = id.replace(/:.*$/, '');

    if (groupLayers) {
      if (strict) {
        return groupLayers.indexOf(id) !== -1;
      }

      let found = false;
      groupLayers.forEach(code => {
        const re = new RegExp(`^${code}-`); // support for modifiers in values layers array

        if (code === id || re.test(id)) {
          found = true;
        }
      });
      return found;
    }

    return false;
  }
  /**
   * Returns whether the specified layer exists within AMP.
   *
   * @param {string} layer
   * @returns {boolean}
   * @memberof Layers
   */


  exists(layer) {
    return isValidLayer(layer);
  }
  /**
   * Returns the layer metadata that matches the query based on the specified property and value.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} prop
   * @param {*} value
   * @param {boolean} [strict=false]
   * @returns {LayerConfig}
   * @memberof Layers
   */


  find(prop, value, strict = false) {
    const results = this.findAll(prop, [value], strict);

    if (results.length > 0) {
      return results[0];
    }

    return undefined;
  }
  /**
   * Returns an array of layer metadata for all layers that match the query based on the
   * specified property and values.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} prop
   * @param {string[]} values
   * @param {boolean} [strict=false]
   * @returns {LayerConfig[]}
   * @memberof Layers
   */


  findAll(prop, values, strict = false) {
    const data = _data;
    const layers = [];
    values = values || [];

    if (data) {
      values.forEach(value => {
        data.forEach((layer, i) => {
          const layerVal = layer[prop];
          let match = layerVal === value;

          if (!match) {
            const re = new RegExp(`^${layerVal}-`); // support for modifiers in values layers array

            let modifiers = (layer.modifiers || []).map(modifier => [].concat((modifier.options || []).map(opt => `${layer.id}-${opt.id}`)));
            modifiers = modifiers.length > 0 ? modifiers[0] : modifiers;

            if (prop === 'id') {
              if (!strict) {
                match = re.test(value);
              } else {
                match = modifiers.indexOf(value) !== -1;
              }
            }
          }

          if (match) {
            if (prop === 'id') {
              layer = (0, _utils.extend)((0, _utils.cloneDeep)(layer), {
                id: value
              });
            }

            layers.push(layer);
          }
        });
      });
    }

    return (0, _utils.cloneDeep)(layers);
  }

  findInvalidIds(ids) {
    const str = (0, _utils.isArray)(ids) ? ids.join(',') : ids;
    return getInvalidLayers(str);
  }
  /**
   * Returns an array of future layer metadata.
   *
   * @returns {LayerConfig[]}
   * @memberof Layers
   */


  future() {
    if (!this._future) {
      const futureLayers = this.findAll('category', ['forecasts', 'models', 'outlooks']); // future radar and satellite are in rad/sat category, so add them manually

      futureLayers.push(this.find('id', 'fradar'));
      futureLayers.push(this.find('id', 'fsatellite'));
      this._future = futureLayers;
    }

    return this._future;
  }
  /**
   * Returns an array of future layer identifiers.
   *
   * @returns {string[]}
   * @memberof Layers
   */


  futureCodes() {
    return this.future().map(layer => layer ? layer.id : undefined);
  }
  /**
   * Returns whether the specified layer identifier is a future layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  isFuture(id) {
    let match = false; // iterate through multiple layers if combined string is provided

    if (id.indexOf(',') >= 0) {
      return this._checkCombined(id, code => this.isFuture(code));
    }

    const codes = this.futureCodes();
    let stripped = id.replace(/:.*$/, '');
    match = codes.indexOf(stripped) !== -1;

    if (!match) {
      stripped = stripped.replace(/\-\w+$/, '');
      match = codes.indexOf(stripped) !== -1;
    }

    return match;
  }
  /**
   * Returns whether the specified layer identifier is a base layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  isBase(id) {
    const stripped = id.replace(/:.*$/, '');
    return this.inGroup(stripped, 'base');
  }
  /**
   * Returns whether the specified layer identifier is an overlay layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  isOverlay(id) {
    const stripped = id.replace(/:.*$/, '');
    return this.inGroup(stripped, 'overlay') || this.inGroup(stripped, 'masks');
  }
  /**
   * Returns whether the specified layer identifier has metric data, specifically for text
   * layers.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  hasMetric(id) {
    if (this.inGroup(id, 'text')) {
      return /^f?humidity-/.test(id) === false;
    }

    return false;
  }

  _checkCombined(id, validator) {
    let match = false;
    (id || '').split(',').forEach(code => {
      const result = validator(code);

      if (result) {
        match = true;
      }
    });
    return match;
  }

  _process(json) {
    if (!json) return;
    const groups = {};
    _modifiers = [];
    json.forEach(el => {
      let cat = el.category; // catch to handle new category names in layers.json source that aren't what we expect

      if (cat.match(/^base/)) {
        cat = 'base';
      } else if (cat.match(/overlay/)) {
        cat = 'overlay';
      }

      if (groups[cat] === undefined) {
        groups[cat] = [];
      }

      groups[cat].push(el.id); // also add this layer to 'text' group if it's a text layer

      if (/-text$/.test(el.id)) {
        if (groups.text === undefined) {
          groups.text = [];
        }

        groups.text.push(el.id);
      }

      if (el.modifiers && (0, _utils.isArray)(el.modifiers)) {
        el.modifiers.forEach(modifier => {
          if (modifier.options) {
            modifier.options.forEach(option => {
              if (_modifiers.indexOf(option.id) === -1) {
                _modifiers.push(option.id);
              }
            });
          }
        });
      }
    });

    _modifiers.push('aeris');

    this._groups = groups;
  }

  _fetchLayerMetadata() {
    this._loading = true;
    this.trigger('load:start');
    return new Promise((resolve, reject) => {
      _Http.default.request('https://cdn.aerisjs.com/layers.json').then(res => {
        if (res.data) {
          _data = res.data;

          this._process(res.data);

          this._loading = false;
          this.trigger('load:done');
          resolve(_data);
        }
      }).catch(error => {
        reject(error);
      });
    }).catch(e => {
      console.error(`Layers: Failed to load layers metadata - ${e}`);
    });
  }

}

var _default = Layers;
exports["default"] = _default;

/***/ }),
/* 301 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Http = _interopRequireDefault(__webpack_require__(101));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LayerTimes {
  constructor(account) {
    this.account = account;
  }

  times(layer, limit = 20) {
    return new Promise((resolve, reject) => {
      const url = `https://maps.aerisapi.com/${this.account.id}_${this.account.secret}/${layer}.json?limit=${limit}`;

      _Http.default.request(url).then(res => {
        let result = [];

        if (res.data) {
          const data = res.data;

          if ((0, _utils.isset)(data.files)) {
            result = data.files.map(time => ({
              time: new Date(time.timestamp * 1000),
              min: new Date(time.minTimestamp * 1000),
              max: new Date(time.maxTimestamp * 1000),
              run: new Date(time.runTime * 1000)
            }));
          }
        }

        resolve(result);
      }).catch(error => {
        reject(error);
      });
    });
  }

  timesInRange(layer, from, to, limit = 20) {
    return this.times(layer, limit).then(times => times.filter(valid => valid.time.getTime() >= from.getTime() && valid.time.getTime() <= to.getTime()));
  }

}

var _default = LayerTimes;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 302 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _globals = __webpack_require__(134);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ActivityIndicator {
  constructor(opts = null) {
    this._opts = (0, _utils.extend)({
      strokeWidth: 4
    }, opts);
    this.render();
  }

  get $el() {
    return this._target;
  }

  get $path() {
    return (0, _DOM.default)(`.${_globals.Globals.cssPrefix}fill-path`, this.$el);
  }

  appendTo(target, styles = null) {
    const $target = (0, _DOM.default)(target);

    if ($target.length > 0) {
      $target.append(this.$el);
      this._target = (0, _DOM.default)(`.${_globals.Globals.cssPrefix}loader`, $target);

      if (styles) {
        this._target.css(styles);
      }
    }
  }

  startAnimating() {
    this.$el.addClass('animated');
  }

  stopAnimating() {
    this.$el.removeClass('animated');
  }

  render() {
    let isPercentage = false;
    let size = (0, _utils.get)(this._opts, 'size') || '100%';

    if ((0, _utils.isString)(size)) {
      if (/%$/.test(size) === false) {
        size = size.replace(/[0-9\.]/, '');
        size = parseFloat(size);
      } else {
        isPercentage = true;
      }
    }

    const s = (0, _utils.isString)(size) ? 60 : size;
    const center = Math.round(s / 2);
    const radius = Math.round(18 * (s / 60));
    const offset = Math.round(s / 2);
    const stroke = (0, _utils.get)(this._opts, 'strokeWidth') || 4;
    const sizeStr = isPercentage ? size : `${size}px`;
    this._target = (0, _DOM.default)(`
			<div class="${_globals.Globals.cssPrefix}loader" style="width: ${sizeStr}; height: ${sizeStr};">
				<svg version="1.1" class="${_globals.Globals.cssPrefix}filler-loader" width="${s}" height="${s}" style="margin-top: -${offset}px; margin-left: -${offset}px;">
					<circle class="${_globals.Globals.cssPrefix}fill-path" cx="${center}" cy="${center}" r="${radius}" stroke-width="${stroke}" />
				</svg>
			</div>
		`);
  }

}

var _default = ActivityIndicator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 303 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createAerisSource = exports.identifierForLayer = exports.createSource = exports.createTextSource = exports.createGeoJsonSource = exports.createVectorSource = exports.createTileSource = exports.mapRequestForConfig = exports.apiRequestForConfig = exports.getSourceId = void 0;

var _ApiRequest = _interopRequireDefault(__webpack_require__(100));

var _MapRequest = _interopRequireDefault(__webpack_require__(135));

var _sources = __webpack_require__(229);

var _utils = __webpack_require__(17);

var _Layers = __webpack_require__(300);

var _style = __webpack_require__(287);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getSourceId = id => {
  if (!(0, _utils.isString)(id)) return undefined; // parse id from full identifier string

  const parts = id.split('::');
  return parts[parts.length - 1];
};

exports.getSourceId = getSourceId;

const apiRequestForConfig = (account, config) => {
  if (!(0, _utils.isset)(config)) return null;
  let request = config.service;

  if ((0, _utils.isset)(config.request)) {
    const opts = config.request;

    if (request) {
      const action = opts.action;
      const params = opts.parameters;

      if (action) {
        request.action(action);
      }

      if (params) {
        request.setParams(params);
      }
    } else if (opts.endpoint) {
      request = new _ApiRequest.default({
        server: opts.server,
        client: {
          id: account.id,
          secret: account.secret
        }
      });
      request.endpoint(opts.endpoint);

      if (opts.action) {
        request.action(opts.action);
      }

      if (opts.parameters) {
        request.setParams(opts.parameters);
      }
    }
  }

  return request;
};

exports.apiRequestForConfig = apiRequestForConfig;

const mapRequestForConfig = (account, config) => {
  const {
    layer,
    request: opts
  } = config;
  const request = new _MapRequest.default({
    server: opts.server,
    client: {
      id: account.id,
      secret: account.secret
    }
  }, {
    type: "tile"
    /* TILE */

  });
  request.layers(layer);
  return request;
};

exports.mapRequestForConfig = mapRequestForConfig;

const createTileSource = (identifier, config, factory) => {
  let service = (0, _utils.get)(config, 'data.service');

  if ((0, _utils.isFunction)(service)) {
    service = service();
  }

  if (service instanceof _MapRequest.default) {
    service.type("tile"
    /* TILE */
    );
  } // console.log('TILE', identifier, config, service);


  return factory.tileLayer(identifier, service, config);
};

exports.createTileSource = createTileSource;

const createVectorSource = (identifier, config) => new _sources.VectorSource(identifier, config);

exports.createVectorSource = createVectorSource;

const createGeoJsonSource = (identifier, config) => new _sources.GeoJsonSource(identifier, config);

exports.createGeoJsonSource = createGeoJsonSource;

const createTextSource = (identifier, config) => {
  const props = (0, _utils.get)(config, 'data.properties'); // make sure required data property mappings are provided for text layers

  if (!props) {
    throw new Error('Value for `data.properties` option is required for text layers');
  } else {
    const {
      timestamp,
      value
    } = props;

    if (!timestamp || !value) {
      throw new Error('Value for `data.properties.timestamp` and `data.properties.value` options are required for text layers');
    }
  }

  return new _sources.TextSource(identifier, config);
};

exports.createTextSource = createTextSource;

const createSource = (identifier, type, config, factory) => {
  const {
    account,
    servers
  } = config || {};
  delete config.account;
  delete config.servers;

  if (['tile', 'vector', 'geojson', 'text'].indexOf(type) === -1) {
    return null;
  }

  if (type === 'tile') {
    return createTileSource(identifier, config, factory);
  } // setup service for the module's data source


  if (config.data && !(0, _utils.isset)((0, _utils.get)(config, 'data.service'))) {
    const request = apiRequestForConfig(account, (0, _utils.extend)({}, {
      request: {
        server: servers.api
      }
    }, config.data));
    (0, _utils.set)(config, 'data.service', request);
  } // console.log('VECTOR', identifier, config);


  if (type === 'vector') {
    return new _sources.VectorSource(identifier, config);
  }

  if (type === 'geojson') {
    return new _sources.GeoJsonSource(identifier, config);
  }

  if (type === 'text') {
    return new _sources.TextSource(identifier, config);
  }

  return null;
};

exports.createSource = createSource;

const identifierForLayer = layer => layer.replace(/\:[^,]+/g, '');

exports.identifierForLayer = identifierForLayer;

const createAerisSource = (layer, config = {}, factory, layersMetadata) => {
  const {
    account,
    servers,
    timeline = {}
  } = config || {};
  const key = identifierForLayer(layer);
  const identifier = (0, _utils.get)(config, 'id') || key;

  if ((0, _Layers.isTile)(layer) || config.type === 'tile') {
    delete config.data;
    const validate = (0, _utils.isset)(config.validate) ? config.validate : true;

    if (validate === true && !layersMetadata.exists(layer)) {
      const invalid = layersMetadata.findInvalidIds(layer);
      console.warn(`[Aeris] Cannot add layer(s) {${invalid}}, not a valid AerisWeather Maps layer. See https://www.aerisweather.com/support/docs/aeris-maps/reference/map-layers/ for the list of supported AMP layers.`);
      return void 0;
    }

    const isFutureLayer = layersMetadata.isFuture(layer);
    const isBase = layersMetadata.isBase(layer);
    const isOverlay = layersMetadata.isOverlay(layer);
    let alwaysShow = (0, _utils.get)(config, 'alwaysShow');

    if (!(0, _utils.isset)(alwaysShow)) {
      alwaysShow = isFutureLayer ? timeline.alwaysShowFuture : timeline.alwaysShowPast;
    }

    const service = mapRequestForConfig(account, {
      layer,
      request: {
        server: servers.maps
      }
    });
    service.param('format', (0, _utils.get)(config, 'style.format') || 'png'); // override custom config values depending on layer type

    let sourceConfig = config;

    if (isOverlay || isBase) {
      sourceConfig = (0, _utils.extend)(sourceConfig, {
        pane: isOverlay ? 'admin' : null,
        offset: 0,
        alwaysShow: true,
        animation: {
          enabled: false
        }
      });
    } else {
      const totalIntervals = timeline.intervals;
      sourceConfig = (0, _utils.extend)({
        animation: {
          enabled: true,
          intervals: totalIntervals
        }
      }, sourceConfig, {
        offset: (0, _utils.get)(config, 'data.offset'),
        future: isFutureLayer,
        alwaysShow,
        animation: {
          bufferIntervals: timeline.bufferIntervals,
          showLoadingIntervals: timeline.showLoadingIntervals
        }
      });
    }

    sourceConfig.zIndex = (0, _utils.get)(config, 'style.zIndex');
    const source = createTileSource(identifier, (0, _utils.extend)(sourceConfig, {
      data: {
        service
      }
    }), factory);
    source.updateVisibility();
    return source;
  }

  let type = 'vector';

  if ((0, _Layers.isText)(layer)) {
    type = 'text';
  }

  const defaultConfig = (0, _style.configForLayer)(layer);
  const sourceConfig = (0, _utils.extend)({
    data: {
      request: {
        parameters: {
          plimit: 1
        }
      },
      coordinate: item => (0, _utils.get)(item, 'loc')
    },
    requiresBounds: (0, _utils.get)(defaultConfig, 'data.request.action') !== "search"
    /* SEARCH */

  }, defaultConfig, config);
  return createSource(identifier, type, sourceConfig, factory);
};

exports.createAerisSource = createAerisSource;

/***/ }),
/* 304 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Collection = _interopRequireDefault(__webpack_require__(305));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class DataSourceStore extends _Collection.default {
  constructor() {
    super(...arguments);
    this._order = new Map();
    this._mapping = new Map();
  }

  get mapping() {
    return this._mapping;
  }

  get order() {
    return this._order;
  }

  add(key, source, order) {
    super.add(key, source);

    if ((0, _utils.isset)(order)) {
      this._order.set(key, order);
    }
  }

  get(key) {
    let source = super.get(key);

    if (!(0, _utils.isset)(source)) {
      const mapped = this.mapping.get(key);

      if (mapped) {
        source = super.get(mapped);
      }
    }

    return source;
  }

}

var _default = DataSourceStore;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 305 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

class Collection {
  constructor() {
    this.store = new Map();
  }

  get items() {
    return Array.from(this.store.entries()).reduce((result, [key, value]) => {
      result[key] = value;
      return result;
    }, {});
  }

  get count() {
    return this.store.size;
  }

  has(key) {
    return (0, _utils.isset)(this.get(key));
  }

  get(key) {
    return this.store.get(key);
  }

  add(key, item) {
    this.store.set(key, item);
  }

  remove(key) {
    this.store.delete(key);
  }

  each(fn) {
    const items = this.items;
    Object.keys(items).forEach(key => fn(key, items[key]));
  }

}

var _default = Collection;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 306 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapStrategy = _interopRequireDefault(__webpack_require__(228));

var Maplibre = _interopRequireWildcard(__webpack_require__(307));

var _MaplibreOverlayFactory = _interopRequireDefault(__webpack_require__(314));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />
const MAPLIBRE_VERSION = '2.4.0';

const maplibreBasePath = version => `https://unpkg.com/maplibre-gl@${version}/dist`;

class MaplibreMapStrategy extends _MapStrategy.default {
  constructor() {
    super(...arguments);
    this._pointAnimationUpdates = {};
    this._shapeDataById = {};
    this._clickedMapLayer = false;
  }

  get strategy() {
    return 'maplibre';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getContainer());
  }

  loadDependencies() {
    const css = document.createElement("style");
    css.innerHTML = '.maplibregl-marker { line-height: 0; }';
    window.document.body.appendChild(css);
    return new Promise((resolve, reject) => {
      if (typeof maplibregl === 'undefined' || typeof maplibregl.Map === 'undefined') {
        Promise.all([(0, _utils.loadStyles)(`${maplibreBasePath(MAPLIBRE_VERSION)}/maplibre-gl.css`), (0, _utils.loadScript)(`${maplibreBasePath(MAPLIBRE_VERSION)}/maplibre-gl.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _MaplibreOverlayFactory.default();
    this._eventMapping = {
      load: 'load',
      remove: 'unload',
      resize: 'resize',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      move: 'move',
      movestart: 'move:start',
      moveend: 'move:end'
    }; // const mbversion = maplibregl.version;
    // if (mbversion) {
    // 	let [major, minor] = mbversion.split('.');
    // 	major = parseInt(major, 10);
    // 	minor = parseInt(minor, 10);
    // 	if (major === 0 && minor < 50) {
    // 		throw new Error(`AerisWeather SDK requires Maplibre GL JS version 0.50.0 or higher. You are using version ${mbversion}.`);
    // 	}
    // }
    // set view properties from native map options if defined

    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if (center && (0, _utils.isArray)(center)) {
        const [lon, lat] = center;

        if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
          (0, _utils.set)(this.opts, 'center', {
            lat,
            lon
          });
        }
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of maplibregl.Map
    // if maplibregl.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isMaplibre)(target)) {
      this._setInitialView = false;
      this._map = target;
      setTimeout(() => {
        this.trigger('map:ready');
      }, 250);
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      this._map = new maplibregl.Map((0, _utils.extend)({}, this.opts.map, {
        container: target,
        style: this.opts.style
      }));
      this._currentMapStyle = this.opts.style; // const controls = new maplibregl.NavigationControl({});
      // this._map.addControl(controls, 'bottom-left');

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }

      this.map.on('load', () => {
        setTimeout(() => {
          this.trigger('map:ready');
        }, 250);
      });
    }
  }
  /**
   * Updates the base map style using a Maplibre style URL.
   *
   * @param {string} style
   * @returns
   * @memberof MaplibreMapStrategy
   */


  setBaseStyle(style) {
    if (style === this._currentMapStyle) return;
    const map = this.map; // grab the existing style and cache all Aeris-related sources and layers
    // so they can be re-added after changing the map style

    const mapStyle = map.getStyle();
    const aerisLayers = mapStyle.layers.filter(layer => /^aeris-/.test(layer.id));
    const aerisSources = Object.keys(mapStyle.sources).filter(key => /^aeris-/.test(key)).reduce((prev, result) => {
      prev[result] = mapStyle.sources[result];
      return prev;
    }, {}); // need to wait for the new style to load before re-adding the previous map data

    map.on('style.load', () => {
      Object.keys(aerisSources).forEach(key => {
        const existing = map.getSource(key);

        if (!existing) {
          map.addSource(key, aerisSources[key]);
        }
      });
      aerisLayers.forEach(layer => {
        const existing = map.getLayer(layer.id);

        if (!existing) {
          map.addLayer(layer);
        }
      });
    }); // update the map style

    map.setStyle(style, {
      diff: true
    });
  }

  setView(center, zoom) {
    this.map.jumpTo({
      center: {
        lat: center.lat,
        lon: center.lon
      },
      zoom: Math.max(1, zoom - 1)
    });
  }

  getCenter() {
    const coord = this._map.getCenter();

    return {
      lat: coord.lat,
      lon: coord.lng
    };
  }

  setCenter(coord) {
    this._map.setCenter({
      lat: coord.lat,
      lon: coord.lon
    });
  }

  getZoom() {
    return this._map.getZoom() + 1;
  }

  setZoom(zoom) {
    this._map.setZoom(Math.max(0, zoom - 1));
  }

  getBounds() {
    const b = this.map.getBounds();
    return {
      north: b.getNorth(),
      west: b.getWest(),
      south: b.getSouth(),
      east: b.getEast()
    };
  }

  setBounds(bounds) {
    const sw = new maplibregl.LngLat(bounds.west, bounds.south);
    const ne = new maplibregl.LngLat(bounds.east, bounds.north);
    this.map.fitBounds(new maplibregl.LngLatBounds(sw, ne));
  }

  fitBounds(bounds, padding = [10, 10]) {
    const sw = new maplibregl.LngLat(bounds.west, bounds.south);
    const ne = new maplibregl.LngLat(bounds.east, bounds.north);
    const b = new maplibregl.LngLatBounds(sw, ne);
    const opts = {};

    if (padding.length === 1) {
      opts.padding = padding[0];
    } else if (padding.length === 2) {
      opts.padding = {
        top: padding[1],
        right: padding[0],
        bottom: padding[1],
        left: padding[0]
      };
    } else if (padding.length === 4) {
      opts.padding = {
        top: padding[0],
        right: padding[1],
        bottom: padding[2],
        left: padding[3]
      };
    }

    this.map.fitBounds(b, opts);
  }
  /** Sources */


  isTile(source) {
    return source instanceof Maplibre.TileSource;
  }

  isMarker(el) {
    return el instanceof maplibregl.Marker;
  }

  isPolygon(el) {
    return el instanceof Maplibre.Polygon;
  }

  isPolyline(el) {
    return el instanceof Maplibre.Polyline;
  }

  addSource(source) {
    super.addSource(source);

    if (this.isTile(source)) {
      source.updateVisibility();
    }
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof Maplibre.Tile) {
      overlay.addTo(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof Maplibre.Tile) {
      overlay.remove();
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Maplibre.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof maplibregl.Marker) {
      marker.addTo(this.map);
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof Maplibre.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof maplibregl.Marker) {
      marker.remove();
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!(0, _utils.isset)(options)) return;

    if (marker instanceof Maplibre.Marker) {
      marker.update(options);
    }
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Maplibre.Polygon || shape instanceof Maplibre.Polyline) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
      this._shapeDataById[shape.id] = data; // this._renderableEvents.forEach((name) => {
      // 	shape.on(name, () => {
      // 		if (name === 'click') {
      // 			this._clickedMapLayer = true;
      // 			setTimeout(() => {
      // 				this._clickedMapLayer = false;
      // 			}, 100);
      // 		}
      // 		this.trigger(`shape:${name}`, { data, shape })
      // 	});
      // });
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Maplibre.Polygon || shape instanceof Maplibre.Polyline) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.show();
      return;
    }

    super.showShape(shape);
  }

  hideShape(shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.hide();
      return;
    }

    super.hideShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    const p = this.map.project({
      lat: coord.lat,
      lng: coord.lon
    });
    return {
      x: p.x,
      y: p.y
    };
  }

  pointToCoord(point) {
    const c = this.map.unproject([point.x, point.y]);
    return {
      lat: c.lat,
      lon: c.lng
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    const popup = new maplibregl.Popup(opts).setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setLngLat({
        lat: target.lat,
        lng: target.lon
      }).addTo(this.map);
    } else if (this.isMarker(target)) {
      target.setPopup(popup);
      target.togglePopup();
    }
  }

  _setupEvents() {
    this.map.on('movestart', e => {
      ['before:change:bounds', 'before:change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('moveend', e => {
      ['after:change:bounds', 'after:change:center', 'change:bounds', 'change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomstart', e => {
      ['before:change:zoom'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomend', e => {
      ['after:change:zoom', 'change:zoom'].forEach(name => this.trigger(name));
    }); // call super at the bottom so our initial click event handler gets called first to
    // handle layer vs map click triggers

    super._setupEvents();
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.lngLat.lat,
            lon: event.lngLat.lng
          },
          point: {
            x: event.point.x,
            y: event.point.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = MaplibreMapStrategy;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 307 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Polygon", ({
  enumerable: true,
  get: function () {
    return _PolygonLayer.default;
  }
}));
Object.defineProperty(exports, "Polyline", ({
  enumerable: true,
  get: function () {
    return _PolylineLayer.default;
  }
}));
Object.defineProperty(exports, "Tile", ({
  enumerable: true,
  get: function () {
    return _TileLayer.default;
  }
}));
Object.defineProperty(exports, "Marker", ({
  enumerable: true,
  get: function () {
    return _Marker.default;
  }
}));
Object.defineProperty(exports, "TileSource", ({
  enumerable: true,
  get: function () {
    return _MaplibreTileSource.default;
  }
}));

var _PolygonLayer = _interopRequireDefault(__webpack_require__(308));

var _PolylineLayer = _interopRequireDefault(__webpack_require__(310));

var _TileLayer = _interopRequireDefault(__webpack_require__(311));

var _Marker = _interopRequireDefault(__webpack_require__(312));

var _MaplibreTileSource = _interopRequireDefault(__webpack_require__(313));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 308 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(309));

var strings = _interopRequireWildcard(__webpack_require__(133));

var _utils = __webpack_require__(17);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */
class MapboxPolygonLayer extends _Layer.default {
  constructor(layer, polygons, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._needsEventSetup = true;
    this._polygons = polygons;
  }

  get strokeLayerId() {
    return `${this.layerId}-stroke`;
  }

  addTo(map) {
    super.addTo(map);

    if (this._strokeLayer) {
      const contains = map.getLayer(this.strokeLayerId) !== undefined;

      if (!contains) {
        map.addLayer(this._strokeLayer, this.layerId);
      }
    }

    if (this._needsEventSetup) {
      map.on('click', this.layerId, e => {
        this.trigger('click', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseenter', this.layerId, e => {
        this.trigger('mouseover', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseleave', this.layerId, e => {
        this.trigger('mouseout', {
          data: this.data,
          shape: this.renderable
        });
      });
      this._needsEventSetup = false;
    }
  }

  remove() {
    if (!this.map) return;

    if (this._strokeLayer) {
      const contains = this.map.getLayer(this.strokeLayerId) !== undefined;

      if (contains) {
        this.map.removeLayer(this.strokeLayerId);
      }
    }

    super.remove();
  }

  invalidate() {
    const isMulti = this._polygons.length > 1;
    const polygons = (this._polygons || []).map(polygon => {
      const outer = polygon.outer.map(c => [c.lon, c.lat]);
      const inner = polygon.inner ? polygon.inner.map(p => p.map(c => [c.lon, c.lat])) : [];
      return [outer, ...inner];
    });
    this.source = {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: {
            type: isMulti ? 'MultiPolygon' : 'Polygon',
            coordinates: isMulti ? polygons : polygons[0] || []
          }
        }]
      }
    };
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  createRenderable() {
    const style = this.opts;
    const convertedStyle = {
      fill: {},
      stroke: {}
    }; // format the line/fill styles as required for the Mapbox paint style spec

    ['fill', 'line'].forEach(type => {
      const dest = type === 'line' ? 'stroke' : 'fill';
      Object.keys(style).filter(key => new RegExp(`^${type}-`).test(key)).forEach(prop => {
        const k = strings.hyphenate(prop);

        if ((0, _utils.isset)(style[prop])) {
          convertedStyle[dest][k] = style[prop];
        }
      });
    }); // need to create a separate layer for the stoke style since Mapbox
    // doesn't allow you to set the apply stroke styling to a fill layer

    if (Object.keys(convertedStyle.stroke).length > 0) {
      this._strokeLayer = {
        id: this.strokeLayerId,
        type: 'line',
        source: this.sourceId,
        layout: {},
        paint: convertedStyle.stroke
      };
    }

    return {
      id: this.layerId,
      type: 'fill',
      source: this.sourceId,
      layout: {},
      paint: convertedStyle.fill
    };
  }

}

var _default = MapboxPolygonLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 309 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _MapLayer = _interopRequireDefault(__webpack_require__(246));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `Layer` is a container class that is responsible for creating and managing a Maplibre
 * source and associated layer representation on a Maplibre map.
 */
class MaplibreLayer extends _MapLayer.default {
  /**
   * Source identifier on the map.
   *
   * @readonly
   * @type {string}
   * @memberof Layer
   */
  get sourceId() {
    return `${this.layerId}-source`;
  }
  /**
   * The parent layer identifier for the layer, if any. When specified, this layer will be
   * rendered on the map below the layer associated with the parent identifier.
   *
   * @type {string}
   * @memberof Layer
   */


  get parentId() {
    return this._relativeTo;
  }

  set parentId(value) {
    this._relativeTo = value;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.exists() && !this.isHidden) {
      if (this.renderable.type === 'raster') {
        this.map.setPaintProperty(this.layerId, 'raster-opacity', value);
      } else if (this.renderable.type === 'fill') {
        this.map.setPaintProperty(this.layerId, 'fill-opacity', value);
      }
    }
  }

  setZIndex(value) {
    if (this.exists()) {
      const layers = this.map.getStyle().layers;
      let index = 0;
      layers.forEach((layer, i) => {
        if (layer.type === 'line' && /^admin-/.test(layer.id) && index === 0) {
          index = i;
        }
      });
      const target = layers.map(layer => layer.id)[index + value];
      this.map.removeLayer(this.layerId);
      this.map.addLayer(this.renderable, target);
    }
  }

  exists() {
    const map = this.map;

    if (!map) {
      return false;
    }

    return map.getLayer(this.layerId) !== undefined && map.getSource(this.sourceId) !== undefined;
  }

  invalidate() {
    throw new Error('Subclasses must override `invalidate`');
  }

  createRenderable() {
    return null;
  }

  updateVisibility(visible) {
    if (this.exists()) {
      if (this.renderable.type === 'raster') {
        this.map.setPaintProperty(this.layerId, 'raster-opacity', this.opacity);
      }

      this.map.setLayoutProperty(this.layerId, 'visibility', visible ? 'visible' : 'none');
    }
  }

  addToMap(map) {
    if (this.exists()) {
      return;
    } // determine where to position this layer, typically below map labels/symbols but above roads


    if (!this._relativeTo) {
      const layers = map.getStyle().layers;
      layers.forEach((layer, index) => {
        if (layer.type === 'line' && /^admin-/.test(layer.id) && !this._relativeTo) {
          this._relativeTo = layer.id;
        }
      });
    }

    const contains = map.getLayer(this.layerId) !== undefined;

    if (!contains) {
      if (!this.source) {
        this.invalidate();
      } else {
        map.addSource(this.sourceId, this.source);

        if (!this._relativeTo || map.getLayer(this._relativeTo) !== undefined) {
          map.addLayer(this.renderable, this._relativeTo);
        }
      }
    }

    if (this.isHidden) {
      this.hide();
    }
  }

  removeFromMap(map) {
    const contains = map.getLayer(this.layerId) !== undefined;

    if (contains) {
      map.removeLayer(this.layerId);
      map.removeSource(this.sourceId);
    }
  }

}

var _default = MaplibreLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 310 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(309));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */
class MapboxPolylineLayer extends _Layer.default {
  constructor(layer, points, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._needsEventSetup = true;
    this._points = points;
  }

  addTo(map) {
    super.addTo(map);

    if (this._needsEventSetup) {
      map.on('click', this.layerId, e => {
        this.trigger('click', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseenter', this.layerId, e => {
        this.trigger('mouseover', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseleave', this.layerId, e => {
        this.trigger('mouseout', {
          data: this.data,
          shape: this.renderable
        });
      });
      this._needsEventSetup = false;
    }
  }

  invalidate() {
    this.source = {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: {
            type: 'LineString',
            coordinates: this._points.map(point => [point.lon, point.lat])
          }
        }]
      }
    };
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  createRenderable() {
    const style = (0, _utils.cloneDeep)(this.opts);
    return {
      id: this.layerId,
      type: 'line',
      source: this.sourceId,
      layout: {},
      paint: style
    };
  }

}

var _default = MapboxPolylineLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 311 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Layer = _interopRequireDefault(__webpack_require__(309));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `TileLayer` is a container class that is responsible for creating and managing a Mapbox
 * source and associated layer representation on a Mapbox map.
 */
class MapboxTileLayer extends _Layer.default {
  constructor(layer, opts, id = undefined) {
    super(layer, (0, _utils.extend)({
      type: 'tile'
    }, opts), id);
    this._type = this.opts.type;
  }
  /**
   * Updates the tile or image url for the layer.
   *
   * @param {string} url
   * @memberof TileLayer
   */


  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }
  /**
   * Updates the bounds for the layer when rendered as an image.
   *
   * @param {GeoBounds} bounds
   * @memberof TileLayer
   */


  setBounds(bounds) {
    this.opts.bounds = bounds;
  }
  /**
   * Updates the layer source using the specified image URL and coordinate bounds. Only used
   * for `image` layer types.
   *
   * @param {string} url
   * @param {GeoBounds} [bounds=undefined]
   * @returns
   * @memberof TileLayer
   */


  setImage(url, bounds = undefined) {
    this.opts.url = url;
    const map = this.map;
    if (!map) return;
    if (!bounds) bounds = this.opts.bounds;
    const source = map.getSource(this.sourceId);

    if (source) {
      source.updateImage({
        url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      });
    } else {
      this.invalidate();
    }
  }

  invalidate() {
    const {
      url,
      bounds
    } = this.opts;
    if (!url) return;

    if (this._type === 'image') {
      if (!bounds) {
        return;
      }

      this.source = {
        type: 'image',
        url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      };
    } else {
      this.source = {
        type: 'raster',
        tiles: [1, 2, 3, 4].map(s => url.replace(/\{s\}/, `${s}`)),
        tileSize: 256,
        attribution: this.opts.attribution || ''
      };
    }

    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  updateVisibility(visible) {
    if (this.exists()) {
      this.map.setPaintProperty(this.layerId, 'raster-opacity', visible ? this.opacity : 0);
    }
  }

  createRenderable() {
    return {
      id: this.layerId,
      type: 'raster',
      source: this.sourceId,
      paint: {
        'raster-opacity': this.opacity,
        'raster-opacity-transition': {
          duration: 0,
          delay: 0
        },
        'raster-fade-duration': 0
      }
    };
  }

}

var _default = MapboxTileLayer;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 312 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _MapMarker = _interopRequireDefault(__webpack_require__(250));

var _utils2 = __webpack_require__(262);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */
class MapboxMarker extends _MapMarker.default {
  update(opts) {
    var _a;

    if (!(0, _utils.isset)(opts)) return;
    const {
      data
    } = opts;

    if ((0, _utils.isset)(data)) {
      this.data = Object.assign(Object.assign({}, this.data), data);
    }

    const value = (_a = this.data) === null || _a === void 0 ? void 0 : _a.value;
    let style = opts.style || {};

    if ((0, _utils.isFunction)(style)) {
      style = style({
        value
      });
    }

    this.setStyle(style);
  }

  setStyle(style) {
    this.opts.style = style; // Mapbox doesn't support updating an existing marker's element, so we need to create a new marker
    // for each different value associated with a coordinate's data and add/remove it accordingly

    this.invalidate();
  }

  createRenderable() {
    const {
      style
    } = this.opts;
    const coord = this.coordinate;
    const opts = {};

    if (style) {
      opts.icon = (0, _utils2.markerIconFromStyle)(style);

      if (style.zIndex) {
        opts.zIndex = style.zIndex;
      }
    }

    const renderable = new maplibregl.Marker({
      element: opts.icon
    });
    renderable.setLngLat([coord.lon, coord.lat]);

    if (style && style.callout) {
      let content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        const fn = style.callout;
        content = fn();
      }

      const popup = new maplibregl.Popup();
      popup.setHTML(content);
      renderable.setPopup(popup);
    }

    return renderable;
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    const renderable = this.renderable;

    if (renderable) {
      const el = renderable.getElement();

      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          el.removeEventListener(name, renderable[handlerName]);
        } else {
          renderable[handlerName] = e => {
            e.stopPropagation();
            this.trigger(name, {
              data: this.data,
              marker: renderable
            });
          };
        }

        el.addEventListener(name, renderable[handlerName]);
      });

      renderable.addTo(map);
    }
  }

  removeFromMap(map) {
    const renderable = this.renderable;

    if (renderable) {
      const el = renderable.getElement();

      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          el.removeEventListener(name, renderable.__awxjs_clickHandler);
        }
      });

      renderable.remove();
    }
  }

}

var _default = MapboxMarker;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 313 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _TileSource = _interopRequireDefault(__webpack_require__(240));

var _TileLayer = _interopRequireDefault(__webpack_require__(311));

var _utils = __webpack_require__(17);

var _utils2 = __webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `MapboxTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `MapboxMapStrategy`.
 *
 * @export
 * @class MapboxTileSource
 * @extends {TileSource}
 */
class MaplibreTileSource extends _TileSource.default {
  constructor(key, service, opts) {
    super(key, service, opts);
    const anim = this.animation;
    const animOverlay = new _TileLayer.default(key, (0, _utils.extend)(opts, {
      type: 'image'
    }), `${this.identifier}-anim`);
    anim === null || anim === void 0 ? void 0 : anim.on('show', e => {
      this.show();
    });
    anim === null || anim === void 0 ? void 0 : anim.on('hide', e => {
      this.hide();
    });
    anim === null || anim === void 0 ? void 0 : anim.on('load:image advance:image', e => {
      const image = e.data.img;

      if (image) {
        animOverlay.setImage(image.src);
      }
    });
    this._animationOverlay = animOverlay;
    this.on('overlay:ready', () => {
      const opacity = (0, _utils.get)(opts, 'style.opacity');
      const relativeTo = (0, _utils.get)(opts, 'style.belowLayer');

      if (opts.id) {
        this._overlay.id = opts.id;
        this._animationOverlay.id = `${opts.id}-anim`;
      }

      if ((0, _utils.isset)(opacity)) {
        this._overlay.setOpacity(opacity);

        this._animationOverlay.setOpacity(opacity);
      }

      this._overlay.parentId = relativeTo;
      this._animationOverlay.parentId = this._overlay.layerId;
    });
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    var _a;

    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        (_a = this.animation) === null || _a === void 0 ? void 0 : _a.hide();
        this.updateVisibility();
      }

      if (this.overlay && (this.canShow() || !this.overlay.exists())) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof MapboxTileSource
   */


  show() {
    var _a;

    if (this._hidden === false) return;
    this._hidden = false;

    if (((_a = this.animation) === null || _a === void 0 ? void 0 : _a.isAnimating()) && this._animationOverlay) {
      this._animationOverlay.show();
    } else if (this.overlay) {
      this.overlay.show();
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof MapboxTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.hide();
    }

    if (this._animationOverlay) {
      this._animationOverlay.hide();
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof MapboxTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof MapboxTileSource
   */


  setOpacity(value, update = true) {
    var _a;

    this._opacity = value;

    if (this.overlay) {
      this.overlay.setOpacity(value);
    }

    if (this._animationOverlay) {
      this._animationOverlay.setOpacity(value);
    }

    (_a = this.animation) === null || _a === void 0 ? void 0 : _a.setOpacity(value);
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof MapboxTileSource
   */


  setOrder(value) {
    if (this.overlay) {
      this.overlay.setZIndex(value);
    }

    if (this._animationOverlay) {
      this._animationOverlay.setZIndex(value);
    }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, (0, _utils.extend)(opts, {
      type: 'type'
    }), this.identifier);
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          opacity: 0,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, false);
        source.hide();

        if (wait) {
          const map = this.overlay.map;
          map.on('sourcedata', e => {
            const {
              sourceId,
              isSourceLoaded
            } = e || {};

            if (sourceId === source.overlay.sourceId && isSourceLoaded) {
              resolve(source);
            }
          });
        } else {
          resolve(source);
        }

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = MaplibreTileSource;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 314 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var Maplibre = _interopRequireWildcard(__webpack_require__(307));

var _utils = __webpack_require__(262);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * A factory class that generates and returns renderable map objects from data, such as tile layers
 * and annotations, as required by the associated mapping strategy.
 *
 * @export
 * @class MapboxOverlayFactory
 * @implements {OverlayFactory}
 * @implements {PointDataSource}
 */
class MaplibreOverlayFactory {
  /**
   * Returns a tile layer instance configured with the specified url template string and options.
   *
   * @param {string} layer
   * @param {MapRequest} service
   * @param {*} [opts]
   * @returns {TileSource}
   * @memberof OverlayFactory
   */
  tileLayer(layer, service, opts) {
    return new Maplibre.TileSource(layer, service, opts);
  }
  /**
   * Returns an annotation, or marker, instance with the specified coordinate and configuration
   * options.
   *
   * @param {string} layer
   * @param {Coordinate} coord
   * @param {MarkerStyle} style
   * @returns {*}
   * @memberof OverlayFactory
   */


  marker(layer, coord, style) {
    if (style) {
      // if skipped via the style, then return null
      if (style.skip && style.skip === true) {
        return null;
      }
    }

    return new Maplibre.Marker(coord, undefined, {
      style
    });
  }
  /**
   * Returns a polygon instance configured for the specified layer code and configuration.
   *
   * @param {string} layer
   * @param {Polygon[]} shapes
   * @param {ShapeStyle} style
   * @returns {*}
   * @memberof OverlayFactory
   */


  polygon(layer, shapes, style) {
    let opts;

    if (style) {
      opts = (0, _utils.formatLayerOptions)(style);
    }

    shapes.forEach(shape => {
      if (!opts.id) {
        opts.id = shape.id;
      }
    });
    return new Maplibre.Polygon(layer, shapes, opts, opts.id);
  }

  polyline(layer, points, style) {
    const mapping = {
      stroke: {
        color: 'lineColor',
        opacity: 'lineOpacity',
        width: 'lineWidth',
        dashArray: 'lineDashArray'
      }
    };
    let opts;

    if (style) {
      if (style) {
        opts = (0, _utils.formatLayerOptions)(style);
        delete opts.fill;
      }
    }

    const p = points.map(point => [point.lat, point.lon]);
    return new Maplibre.Polyline(layer, points, opts, opts.id);
  }

}

var _default = MaplibreOverlayFactory;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 315 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _MapConfig = _interopRequireDefault(__webpack_require__(316));

var _MapRequest = _interopRequireDefault(__webpack_require__(135));

var _MapViewAnimator = _interopRequireDefault(__webpack_require__(318));

var _LegendView = _interopRequireDefault(__webpack_require__(319));

var _Timeline = _interopRequireDefault(__webpack_require__(221));

var _Layers = _interopRequireDefault(__webpack_require__(300));

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(302));

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

var _globals = __webpack_require__(134);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 */
const containers = {
  combined: ['layers'],
  split: ['base', 'past', 'future', 'overlays', 'past-text', 'future-text']
};

class MapTimestamp {
  constructor(opts) {
    this._opts = (0, _utils.extend)({
      format: 'MM/dd/yyyy hh:mm a',
      continuous: true
    }, opts);
    this.element = (0, _DOM.default)('<div class="awxjs__map-overlay__timestamp"></div>');
  }

  continuous() {
    return this._opts.continuous === true;
  }

  update(time) {
    const d = new Date(time);
    this.element.html((0, _utils.formatDate)(d, this._opts.format));
  }

}
/**
 * A view object that displays and manages static map content using imagery from the Aeris Maps
 * Platform (AMP).
 *
 * A `MapView` instance does not support user interaction in regards to panning and zooming other
 * support for static control elements to reload map content. If you need to support greater user
 * interaction for map panning and zooming, use an instance of `Map` instead.
 */


class MapView extends _EventDispatcher.default {
  /**
   * Initializes a map view instance with the specified target and configuration object.
   *
   * @param {HTMLElement} target
   * @param {MapViewOptions} [opts=undefined]
   * @memberof MapView
   */
  constructor(target, opts = undefined) {
    super();
    this._ready = false;
    /*
     * Event Handlers
     */

    this.handleLayerChange = e => {
      if (this.timeline) {
        // enable or disable text animation instances based on current map layers
        const enabled = this.config.hasText();
        const pastText = this.timeline.get('pastText');
        const futureText = this.timeline.get('futureText');
        if (pastText) pastText.enabled(enabled);
        if (futureText) futureText.enabled(enabled);
      }

      this.trigger("change:data"
      /* CHANGE_DATA */
      , {
        layers: this.config.data()
      });
    };

    this.handleOffsetChange = e => {
      let {
        data: {
          offset
        }
      } = e;

      if ((0, _utils.isset)(offset)) {
        offset = `${offset}`;

        if (/^-/.test(offset) || offset === '0' || offset == 'current') {
          if (!(0, _utils.get)(this.opts, 'animation.alwaysShowFuture')) {
            ['future', 'futureText'].forEach(type => this._targets[type].hide());
          }
        } else {
          if (!(0, _utils.get)(this.opts, 'animation.alwaysShowPast')) {
            ['past', 'pastText'].forEach(type => this._targets[type].hide());
          }
        }

        if (this._timestamp) {
          const time = (0, _utils.offsetToTime)(this.config.offset());

          this._timestamp.update(time);
        }
      }
    };

    this._loadingGroups = [];
    this.update = (0, _utils.debounce)(groups => {
      if (!this._ready) return;
      const hasDataLayers = (this.config.data() || []).length > 0;

      this._animator.past.enabled(hasDataLayers);

      this._animator.pastText.enabled(hasDataLayers);

      this._animator.future.enabled(hasDataLayers);

      this._animator.futureText.enabled(hasDataLayers);

      let types = groups || this._loadingGroups; // now adjust types based on what actually needs updating

      types = this._adjustTypesForUpdate(types);

      if (types.length === 0) {
        return;
      }

      if (this.timeline) {
        this.timeline.reset();
      }

      if (this._timestamp && (!this.timeline || !this.timeline.isEnabled())) {
        const time = (0, _utils.offsetToTime)(this.config.offset());

        this._timestamp.update(time);
      }

      this.trigger("load:start"
      /* LOAD_START */
      );

      const onComplete = () => {
        Object.keys(images).forEach(key => {
          this.setImage(key, images[key]);
        }); // if (this.timeline) {
        // 	const animations = this.timeline.animations;
        // 	if (animations) {
        // 		Object.keys(animations).forEach(key => {
        // 			const anim = <ImageAnimation>animations[key];
        // 			if (anim.isEnabled()) {
        // 				// anim.element.show();
        // 			}
        // 		});
        // 	}
        // }

        this.trigger("load:done"
        /* LOAD_DONE */
        );
      };

      const checkCompletion = function () {
        if (needed.length === 0) {
          onComplete();
        }
      };

      const images = {};
      const needed = types.slice(0);
      types.forEach(type => {
        const isFuture = type == 'future';
        let group = type;

        if (type === 'past' || type === 'future') {
          group = 'data';
        } else if (type === 'pastText' || type === 'futureText') {
          group = 'text';
        }

        const hasLayers = (0, _utils.isset)(this.config.opts(`layers.${group}`));

        if (hasLayers) {
          if (this.timeline && (group === 'data' || group === 'text')) {
            const anim = this.timeline.get(type);

            if (anim) {
              // anim.element.hide();
              if (!anim.canShow()) {
                needed.splice(needed.indexOf(type), 1);
                checkCompletion();
              } else {
                anim.once('load:image load:error', e => {
                  needed.splice(needed.indexOf(type), 1);
                  checkCompletion();
                });
              }

              anim.goToTime(this.timeline.currentTime);
            }

            return;
          }

          const request = this._request.clone();

          request.setParams(this.config.toRequestOpts([group], isFuture));
          request.get().then(result => {
            // console.log('done loading', type, result.image);
            needed.splice(needed.indexOf(type), 1);

            if (result.image) {
              images[type] = result.image.src;
            }

            checkCompletion();
          }).catch(e => {
            console.error('ERROR', e);
          });
        } else {
          needed.forEach((key, index) => {
            if (key === 'past' || key === 'future' || key === 'pastText' || key === 'futureText') {
              needed.splice(index, 1);
            }
          });
          this.setImage(type, null);
        }
      });
    }, 500);

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for MapView');
    } // convert comma-separated strings to arrays


    ['base', 'data', 'overlays'].forEach(k => {
      const key = `map.layers.${k}`;
      const val = (0, _utils.get)(opts, key);

      if ((0, _utils.isString)(val)) {
        (0, _utils.set)(opts, key, val.replace(/\s/, '').split(','));
      }
    });
    this._opts = (0, _utils.extend)({
      account: null,
      map: {
        layers: {
          base: ['flat'],
          overlays: ['admin']
        },
        center: {
          lat: 40.0,
          lon: -93.0
        },
        size: {
          width: 600,
          height: 400
        },
        autoFuture: true,
        combine: false
      },
      animation: {
        enabled: true,
        from: -2 * 3600,
        to: 0,
        autoplay: false,
        alwaysShowPast: false,
        alwaysShowFuture: false
      },
      overlays: {
        title: undefined,
        timestamp: 'MM/dd/yyyy hh:mm a',
        branding: {
          html: undefined,
          img: undefined
        }
      },
      legend: {
        enabled: true
      },
      controls: {
        layers: undefined,
        regions: undefined
      }
    }, opts);
    this._target = (0, _DOM.default)(target);
    this._config = new _MapConfig.default(this._opts.map);

    this._config.on('change', () => this.trigger("change"
    /* CHANGE */
    ));

    if (this.account) {
      this._request = new _MapRequest.default({
        server: (0, _utils.get)(this._opts, 'servers.maps'),
        client: this.account.credentials()
      });
    }

    this._layers = new _Layers.default(this.account);

    this._layers.fetch().then(data => {
      this.config.layers = this._layers;
      this.render();
    });
  }
  /**
   * Primary DOM element associated with the view.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $el() {
    return this._target;
  }
  /**
   * DOM element associated with the map.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $map() {
    return this._map;
  }
  /**
   * DOM element associated with the map's container.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $container() {
    return (0, _DOM.default)(`.${_globals.Globals.cssPrefix}map-container`, this.$el);
  }
  /**
   * Aeris account used for the map data requests.
   *
   * @readonly
   * @type {Account}
   * @memberof MapView
   */


  get account() {
    return this.opts.account;
  }
  /**
   * Configuration options for the view.
   *
   * @readonly
   * @type {{ [key: string]: any }}
   * @memberof MapView
   */


  get opts() {
    return this._opts;
  }
  /**
   * Map configuration instance managing the underlying map imagery.
   *
   * @readonly
   * @type {MapConfig}
   * @memberof MapView
   */


  get config() {
    return this._config;
  }
  /**
   * Animation timeline used to control the map view's current time and animation.
   *
   * @readonly
   * @type {Timeline}
   * @memberof MapView
   */


  get timeline() {
    if (this._animator) {
      return this._animator.timeline;
    }

    return null;
  }
  /**
   * Legend view associated with the map.
   *
   * @readonly
   * @type {LegendView}
   * @memberof MapView
   */


  get legend() {
    return this._legend;
  }
  /**
   * Returns the DOM element within the view's container for the specified selector.
   *
   * @param {string} selector
   * @returns {*}
   * @memberof MapView
   */


  el(selector) {
    return (0, _DOM.default)(selector, this.$el);
  }
  /**
   * Sets the map layers.
   *
   * The legend displayed for the specified map layers can be overridden by providing a value for
   * the `legend` parameter, which can either be an array of layer codes for multiple
   * auto-configured legends, or a single URL string for a single legend image.
   *
   * @param {MapConfigLayersOptions} layers
   * @param {string} [legend]
   * @memberof MapView
   */


  setLayers(layers, legend) {
    this.config.setLayers(layers);

    if (legend) {
      this.setLegend(legend);
    }
  }
  /**
   * Sets the legend type(s) or image URL to display. If a source URL is provided, then this
   * image will be displayed regardless of which layer types exist on the map.
   *
   * @param {(string | string[])} source
   * @memberof MapView
   */


  setLegend(source) {
    this._legendUrl = null;

    if (source) {
      if ((0, _utils.isString)(source)) {
        const str = source;

        if (str.match(/^(https?:)?\/\//)) {
          this._legendUrl = str;
          this.legend.setUrl(str);
        } else {
          this.legend.set(str.replace(/\s/g, '').split(','));
        }
      } else if ((0, _utils.isArray)(source)) {
        this.legend.set(source);
      }
    }
  }
  /**
   * Sets the units to display on the map view.
   *
   * @param {boolean} metric
   * @memberof MapView
   */


  setMetric(metric) {
    this.config.setMetric(metric);
  }

  render() {
    this.$el.empty();
    this.$el.html(`
			<div class="awxjs__mapview">
				<ul class="awxjs__map-nav"></ul>
				<div class="awxjs__map-container">
					<div class="awxjs__map">
						<ul class="awxjs__map-region-nav horizontal"></ul>
						<ul class="awxjs__map-anim-controls">
							<li data-anim-action="toggle"><button>Play</button></li>
						</ul>
					</div>
					<div class="awxjs__map-legend"></div>
				</div>
			</div>
		`);
    const opts = this.opts;
    const $map = (0, _DOM.default)(`.${_globals.Globals.cssPrefix}map-container > .${_globals.Globals.cssPrefix}map`, this.$el);
    this._map = $map;
    let w = $map.width() || 320;
    let h = $map.height() || 300;

    if (opts.map.size) {
      w = opts.map.size.width || w;
      h = opts.map.size.height || h;

      if (w === 'auto') {
        w = $map.width();
        opts.map.size.width = w; // enable auto-resizing of map width if configured

        if (opts.map.size.autoscale) {
          (0, _DOM.default)(window).on('resize', e => {
            const nw = $map.width(); // this._map.setWidth(w);

            opts.map.size.width = nw;
          });
        }
      }
    }

    const {
      width,
      height
    } = this.config.size();

    if (width && height) {
      $map.width(width).height(height);
      this.$container.width(width);
    }

    if (opts.map.region && !opts.map.bounds) {
      this.config.setRegion(opts.map.region);
    }

    const overlays = this.opts.overlays;
    const controls = this.opts.controls;
    const anim = this.opts.animation;
    const legend = this.opts.legend;
    this.setupContainers($map);

    if (overlays) {
      this.setupOverlays(overlays);
    }

    if (controls) {
      this.setupControls(controls);
    }

    if (anim) {
      this.setupAnimation(anim);
    }

    if (legend) {
      this.setupLegend(legend);
    }

    this.setupEvents();
    this.trigger("ready"
    /* READY */
    );
    this._ready = true;
    this.updateGroups();
  }

  setupEvents() {
    this.config.on('change:data change:offset', e => {
      this.updateGroups(['past', 'future']);
    });
    this.config.on('change:units', e => {
      this.updateGroups(['pastText', 'futureText']);
    });
    this.config.on('change:data', this.handleLayerChange);
    this.config.on('change:bounds change:size', e => {
      this.updateGroups();
    });
    this.config.on('change:size', e => {
      const {
        width,
        height
      } = e.data;

      if (width && height) {
        this.$map.width(width).height(height);
        this.$container.width(width);
      }
    });

    if (!this.timeline) {
      this.config.on('change:offset', this.handleOffsetChange);
      this.config.setOffset(this.config.offset());
    }

    if (this._timestamp && this.timeline) {
      const ts = this._timestamp;

      if (ts.continuous() === false) {
        this.timeline.on('advance:image', e => {
          ts.update(e.data.time);
        });
      } else {
        this.timeline.on('advance', e => {
          ts.update(e.data.time);
        });
      } // since our main animation is a timeline of combined animations, we need to listen for loading progress on either the past or
      // future animation instance within the timeline to update the timestamp; we can't do both since both will load concurrently if the
      // timeline spans past and future time periods


      if (this.timeline instanceof _Timeline.default) {
        Object.keys(this.timeline.animations).forEach(key => {
          const targetAnim = this.timeline.get(key);
          let target;

          if (targetAnim.isEnabled()) {
            if (key === 'past') {
              target = targetAnim;
            } else if (key === 'future') {
              target = targetAnim;
            }
          }

          if (target) {
            target.on('load:progress', e => {
              if (target.canShow()) {
                ts.update(e.data.time);
              }
            });
          }
        });
      }
    }
  }

  setupContainers($map) {
    const layersSel = `${_globals.Globals.cssPrefix}map__layers`;
    $map.append(`<div class="${layersSel}"></div>`);
    const $layers = this.el(`.${layersSel}`);
    this._indicator = new _ActivityIndicator.default();

    this._indicator.appendTo($layers[0]);

    this.on('load:start', () => {
      this._indicator.startAnimating();
    });
    this.on('load:done', () => {
      this._indicator.stopAnimating();
    }); // map.ext.append(this._indicator.element);

    const containerKeys = this.opts.map.combine ? containers.combined : containers.split; // create separate containers for base, past, future and overlay layers so we only have to animate content in the past and future layers

    const targets = {};
    containerKeys.forEach((key, i) => {
      const sel = `${_globals.Globals.cssPrefix}map-layer-${key}`;
      $layers.append(`<div class="${sel}"></div>`);
      const storeKey = (0, _strings.camelcase)(key);
      const $target = (0, _DOM.default)(`.${sel}`, $layers);
      $target.css({
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        "z-index": i
      });
      targets[storeKey] = $target;
    });
    this._targets = targets;
  }

  setupControls(config) {
    if (config.layers) {
      const $target = this.el(`.${_globals.Globals.cssPrefix}map-nav`);
      config.layers.forEach(layer => {
        $target.append(`<li data-map-layer="${layer.value}"><button>${layer.title}</button></li>`);
      });
      const $buttons = (0, _DOM.default)('li', $target);
      $buttons.on('click', e => {
        e.preventDefault();
        const $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
        const layers = $el.allData('map-layer');
        $buttons.removeClass('selected');
        $el.addClass('selected');

        if (layers) {
          this.config.setData(layers.split(','));
        }
      }); // select initial button based on config options

      this.on('ready', e => {
        const initialLayers = (0, _utils.get)(this.opts, 'map.layers.data') || null;

        if (initialLayers) {
          $buttons.each((el, i) => {
            const $btn = (0, _DOM.default)(el);

            if ($btn.allData('map-layer') === initialLayers.join(',')) {
              $btn.click();
            } else if (i === 0) {
              $btn.click();
            }
          });
        } else {
          $buttons.get(0).click();
        }
      });
    }

    if (config.regions) {
      const self = this;
      const $target = this.el(`.${_globals.Globals.cssPrefix}map-region-nav`);
      config.regions.forEach(region => {
        const data = Object.keys(region).reduce((prev, current) => {
          if (current !== 'title') {
            let val = region[current];

            if ((0, _utils.isObject)(val)) {
              if (current === 'center') {
                val = `${val.lat},${val.lon}`;
              } else if (current === 'bounds') {
                val = `${val.north},${val.west},${val.south},${val.east}`;
              }
            }

            prev.push(`data-map-${current}="${val}"`);
          }

          return prev;
        }, []);
        $target.append(`<li ${data.join(' ')}><button>${region.title}</button></li>`);
      });
      const $buttons = (0, _DOM.default)('li', $target);
      $buttons.on('click', e => {
        e.preventDefault();
        const $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
        const zoom = $el.allData('map-zoom');
        const center = $el.allData('map-center') || (0, _utils.get)(this.opts, 'map.center');
        const region = $el.allData('map-region');
        const bounds = $el.allData('map-bounds');
        $buttons.removeClass('selected');
        $el.addClass('selected');

        if (region) {
          self.config.setRegion(region);
        } else if (bounds) {
          const b = bounds.split(',');

          if (b.length === 4) {
            self.config.setBounds({
              north: b[0],
              west: b[1],
              south: b[2],
              east: b[3]
            });
          }
        } else if (center && !(0, _utils.isEmpty)(center)) {
          if ((0, _utils.isset)(zoom) && zoom > 0) {
            self.config.setCenter(center, zoom);
          } else {
            self.config.setCenter(center, this.config.zoom());
          }
        } else if (zoom > 0) {
          self.config.setZoom(zoom);
        }
      }); // select initial button based on config options

      this.on('ready', e => {
        const initialZoom = (0, _utils.get)(this.opts, 'map.zoom') || null;

        if ((0, _utils.isset)(initialZoom)) {
          $buttons.each((el, i) => {
            const $btn = (0, _DOM.default)(el);

            if ($btn.allData('map-zoom') === `${initialZoom}`) {
              $btn.click();
            } else if (i === 0) {
              $btn.click();
            }
          });
        } else {
          $buttons.get(0).click();
        }
      });
    }
  }

  setupOverlays(config) {
    const layersSel = `${_globals.Globals.cssPrefix}map__overlays`;
    this.$map.append(`<div class="${layersSel}"></div>`);
    const $target = this.el(`.${layersSel}`); // map timestamp

    if (config.timestamp) {
      let opts = config.timestamp;

      if ((0, _utils.isString)(opts)) {
        opts = {
          format: opts
        };
      }

      const timestamp = new MapTimestamp(opts);
      timestamp.element.css({
        "z-index": 10
      });
      $target.append(timestamp.element);
      this._timestamp = timestamp;
    } // map title


    if (config.title) {
      const sel = `${_globals.Globals.cssPrefix}map-overlay__title`;
      $target.append(`<div class="${sel}">${config.title}</div>`);
      (0, _DOM.default)(`.${sel}`, $target).css({
        "z-index": 11
      });
    } // map branding


    if (config.branding) {
      const {
        img,
        html
      } = config.branding;
      const sel = `${_globals.Globals.cssPrefix}map-overlay__branding`;
      $target.append(`<div class="${sel}"></div>`);
      const $branding = (0, _DOM.default)(`.${sel}`, $target);
      $branding.css({
        "z-index": 12
      });

      if ((0, _utils.isset)(img)) {
        $branding.html(`<img src="${img}" />`);
      } else if ((0, _utils.isset)(html)) {
        $branding.html(html);
      }
    }
  }

  setupAnimation(config) {
    const $controls = this.el('.awxjs__map-anim-controls > li'); // const $btnAnimate = $('li', $controls);
    // if animation is disabled, we only use the `animation.to` value so update the `from` value to match

    if (!config.enabled) {
      this.config.setOffset((0, _utils.get)(this.opts, 'map.offset') || 0);
      $controls.remove();
      return;
    }

    const animator = new _MapViewAnimator.default({
      past: this._targets.past,
      future: this._targets.future,
      pastText: this._targets.pastText,
      futureText: this._targets.futureText
    }, config);
    animator.provider = this;
    this._animator = animator;
    const timeline = animator.timeline; // show activity indicator while animation data is loading

    timeline.on('load:start', () => {
      this._indicator.startAnimating();
    });
    timeline.on('load:done load:error', () => {
      this._indicator.stopAnimating();
    }); // disable future layers for map if animation doesn't extend into the future

    this.config.opts('autoFuture', timeline.containsFuture());
    timeline.on('end:change', e => {
      this.config.opts('autoFuture', timeline.containsFuture());
    });
    timeline.on('start:change end:change', e => {
      // show or hide animate button based on whether animation can actually animate
      if (timeline.canAnimate()) {
        $controls.show();
      } else {
        $controls.hide();
      }
    });

    if (!timeline.canAnimate()) {
      $controls.hide();
    }

    this.on('ready', () => {
      // need to reset animation and clear its image cache if the map's data layers change
      this.config.on('change:data change:size change:zoom change:offset change:center change:bounds', e => {// timeline.reset();
      });
      this.config.on('change:units', e => {
        timeline.stop();
        const pastTextAnim = timeline.get('pastText');

        if (pastTextAnim) {
          pastTextAnim.reset();
        }

        const futureTextAnim = timeline.get('futureText');

        if (futureTextAnim) {
          futureTextAnim.reset();
        }
      });
      timeline.goToInit();

      if (timeline.isAutoPlay()) {
        this.once("load:done"
        /* LOAD_DONE */
        , () => {
          setTimeout(() => {
            timeline.play();
          }, 500);
        });
      }
    }); // // toggle animation when clicking on layers container
    // $layers.on('click', (e: any) => {
    // 	this.timeline.toggle();
    // });

    $controls.each(el => {
      const $el = (0, _DOM.default)(el);
      const action = $el.allData('anim-action');

      if (action === 'toggle') {
        const $btn = (0, _DOM.default)('button', $el);
        timeline.on('play load:start', () => {
          $btn.html('Stop');
        });
        timeline.on('stop', () => {
          $btn.html('Play');
        });
      }
    }).on('click', e => {
      e.preventDefault();
      const $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
      const action = $el.allData('anim-action');

      if (action === 'toggle') {
        timeline.toggle();
      } else if (action === 'play') {
        timeline.play();
      } else if (action === 'pause') {
        timeline.pause();
      } else if (action === 'stop') {
        timeline.stop();
      }
    });
  }

  setupLegend(config) {
    const $legend = this.el('.awxjs__map-legend');

    if (!config.enabled) {
      $legend.remove();
      return;
    }

    const legend = new _LegendView.default($legend, (0, _utils.extend)({
      size: {
        width: this.$map.width()
      }
    }, config));
    this._legend = legend;
    const update = (0, _utils.debounce)(() => {
      // don't update legend based on map layer types if we have defined a value for _legendSource
      if (this._legendUrl) return;
      const layers = this.config.data();
      const opts = {
        account: this.account
      }; // if active layers contains `alerts`, we need to pass the maps current bounds, size and zoom to be used
      // to request a filtered version of the advisories legend just for the map region

      if (layers && layers.indexOf('alerts') !== -1) {
        opts.within = {
          bounds: this.config.bounds(),
          center: this.config.center(),
          zoom: this.config.zoom(),
          size: this.config.size()
        };
      }

      legend.set(layers, opts);
    }, 50);
    this.config.on('change:data change:bounds', e => {
      update();
    });
    this.config.on('change:size', e => {
      legend.setWidth(e.data.width);
    });
    this.config.on('change:metric', e => {
      legend.setMetric(e.data.metric);
    });
    update();
  }
  /*
   * Image Methods
   */


  setImage(type, url) {
    const target = (0, _DOM.default)(`.${_globals.Globals.cssPrefix}map-layer-${type}`, this.$el);

    if (target) {
      target.empty();

      if (url) {
        target.append(`<img src="${url}" width="${this.config.size().width}" height="${this.config.size().height}">`);
      }
    }
  }

  updateGroups(groups) {
    groups = groups || ['base', 'past', 'future', 'overlays'];
    groups.forEach(group => {
      if (this._loadingGroups.indexOf(group) === -1) {
        this._loadingGroups.push(group);
      }
    });
    this.update();
  }

  _adjustTypesForUpdate(types) {
    const filtered = types.splice(0);
    const now = new Date().getTime();

    if (this.timeline && this.timeline.isEnabled()) {
      // remove `past` if animation's start time doesn't start in the past
      const pastIndex = filtered.indexOf('past');

      if (pastIndex > -1 && this.timeline.startDate().getTime() > now) {
        filtered.splice(pastIndex, 1);
      } // remove `future` if animation's end time doesn't extend beyond now


      const futureIndex = filtered.indexOf('future');

      if (futureIndex > -1 && this.timeline.endDate().getTime() <= now && this._animator.timeline.get('future').canShow() === false) {
        filtered.splice(futureIndex, 1);
      }
    }

    if (this.config.hasText()) {
      if (filtered.indexOf('past') > -1) {
        filtered.push('pastText');
      }

      if (filtered.indexOf('future') > -1) {
        filtered.push('futureText');
      }
    }

    return filtered;
  }
  /*
   * ImageAnimationProvider
   */


  animationUrlForDate(animation, date) {
    const request = this._request.clone();

    const group = /text$/i.test(animation.key) ? 'text' : 'data';
    const options = this.config.toRequestOpts([group], animation.isFuture());

    if (group === 'data' && (0, _utils.isset)(options.layers.data) || group === 'text' && (0, _utils.isset)(options.layers.text)) {
      request.setParams(options);
      request.date(date);
      return request.url();
    }

    return null;
  }

  animationSizeForImage(animation) {
    return this.config.size();
  }

}

var _default = MapView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 316 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _Regions = __webpack_require__(317);

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const timestampFromDate = date => {
  const gmtDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
  return (0, _utils.formatDate)(gmtDate, 'yyyyMMddHHmm00');
};
/**
 * A map configuration object stores and manages various map-related options associated with a
 * `MapView` instance.
 *
 * @export
 * @class MapConfig
 * @extends {EventDispatcher}
 */


class MapConfig extends _EventDispatcher.default {
  /**
   * Initializes and returns a map configuration instance for the specified map options.
   *
   * @param {MapConfigOptions} [opts=undefined]
   * @memberof MapConfig
   */
  constructor(opts = undefined) {
    super();
    /**
     * @ignore
     * Called when any configuration property changes.
     *
     * @private
     * @memberof MapConfig
     */

    this.onChange = (0, _utils.debounce)(() => {
      // // only trigger change event if we have a valid location, which prevents warning messages to the console if non-data changes
      // // occur before a location is specified for the map
      // if (this.hasLocation()) {
      // 	this.trigger('change');
      // }
      this.trigger('change');
    }, 500);
    this._opts = (0, _utils.extend)({}, {
      layers: {
        base: undefined,
        data: undefined,
        overlays: undefined,
        text: undefined
      },
      center: undefined,
      zoom: 3,
      bounds: undefined,
      size: {
        width: 600,
        height: 400
      },
      offset: '0',
      date: undefined,
      autoFuture: true,
      combined: false,
      metric: false
    }, opts);
  }
  /**
   * Aeris Maps (AMP) layers metadata.
   *
   * @type {Layers}
   * @memberof MapConfig
   */


  get layers() {
    return this._layers;
  }

  set layers(layers) {
    this._layers = layers;
  }
  /**
   * Returns or sets an option by key.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {*}
   * @memberof MapConfig
   */


  opts(key, value) {
    if ((0, _utils.isset)(value)) {
      (0, _utils.set)(this._opts, key, value);
      return null;
    }

    return (0, _utils.get)(this._opts, key);
  }
  /*
   * Layers
   */

  /**
   * Returns the data layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  data() {
    return this.opts('layers.data');
  }
  /**
   * Sets the data layer codes.
   *
   * @param {string[]} data
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setData(data) {
    if (!this._opts.combined) {
      const text = [];
      const layers = [];
      data.forEach(layer => {
        if (/-text-?/.test(layer) && this.layers.inGroup(layer, 'text')) {
          text.push(layer);
        } else {
          layers.push(layer);
        }
      });
      this.opts('layers.data', layers);
      this.opts('layers.text', text);
    } else {
      this.opts('layers.data', data);
    }

    this.trigger('change:data', {
      data
    });
    this.onChange();
    return this;
  }
  /**
   * Returns the base layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  base() {
    return this.opts('layers.base');
  }
  /**
   * Sets the base layer codes.
   *
   * @param {string[]} base
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setBase(base) {
    this.opts('layers.base', base);
    this.trigger('change:base', {
      base
    });
    this.onChange();
    return this;
  }
  /**
   * Returns the overlay layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  overlays() {
    return this.opts('layers.overlays');
  }
  /**
   * Sets the overlay layer codes.
   *
   * @param {string[]} overlays
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setOverlays(overlays) {
    this.opts('layers.overlays', overlays);
    this.trigger('change:overlays', {
      overlays
    });
    this.onChange();
    return this;
  }
  /**
   * Returns whether the layer configuration contains overlay layer codes.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  hasOverlays() {
    const overlays = this.overlays();
    return overlays && !(0, _utils.isEmpty)(overlays);
  }
  /**
   * Returns the text layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  text() {
    return this.opts('layers.text');
  }
  /**
   * Sets the text layer codes.
   *
   * @param {string[]} text
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setText(text) {
    this.opts('layers.text', text);
    this.trigger('change:text', {
      text
    });
    this.onChange();
    return this;
  }
  /**
   * Returns whether the layer configuration contains text layer codes.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  hasText() {
    const text = this.text();
    return text && !(0, _utils.isEmpty)(text);
  }
  /**
   * Sets all layer codes grouped by category.
   *
   * @param {MapConfigLayersOptions} layers
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setLayers(layers) {
    layers = layers || {};
    if (layers.base) this.setBase(layers.base);
    if (layers.data) this.setData(layers.data);
    if (layers.overlays) this.setOverlays(layers.overlays);
    if (layers.text) this.setText(layers.text);
    return this;
  }
  /**
   * Returns the time offset.
   *
   * @returns {string}
   * @memberof MapConfig
   */


  offset() {
    return this.opts('offset');
  }
  /**
   * Sets the time offset.
   *
   * @param {string} offset
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setOffset(offset) {
    this.opts('offset', `${offset}`);
    this.trigger('change:offset', {
      offset
    });
    this.onChange();
    return this;
  }

  setDate(date) {
    if (date instanceof Date) {
      this.setOffset(timestampFromDate(date));
    } else {
      this.setOffset(`${date}`);
    }
  }
  /*
   * Center and Zoom
   */

  /**
   * Returns the center place string or coordinate object.
   *
   * @returns {(string | Coordinate)}
   * @memberof MapConfig
   */


  center() {
    const center = this.opts('center');

    if (center) {
      if (/^[\d\.-]+,[\d\.-]+$/.test(center)) {
        const coord = center.split(',');

        if (coord && coord.length === 2) {
          return {
            lat: parseFloat(coord[0]),
            lon: parseFloat(coord[1])
          };
        }
      }
    }

    return center;
  }
  /**
   * Sets the center place string or coordinate object.
   *
   * @param {(Coordinate | string)} center
   * @param {number} [zoom=null]
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setCenter(center, zoom = null) {
    if ((0, _utils.isPlainObject)(center)) {
      const coord = center;
      center = `${coord.lat},${coord.lon}`;
    }

    this.opts('center', center);
    delete this._opts.bounds;

    if (zoom >= 0) {
      this.opts('zoom', zoom);
    }

    this.trigger('change:center');
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Returns the zoom level.
   *
   * @returns {number}
   * @memberof MapConfig
   */


  zoom() {
    return this.opts('zoom');
  }
  /**
   * Sets the zoom level.
   *
   * @param {number} zoom
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setZoom(zoom) {
    this.opts('zoom', zoom);
    this.trigger('change:zoom');
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Returns the coordinate bounds.
   *
   * @returns {GeoBounds}
   * @memberof MapConfig
   */


  bounds() {
    return this.opts('bounds');
  }
  /**
   * Sets the coordinate bounds.
   *
   * @param {GeoBounds} bounds
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setBounds(bounds) {
    this.opts('bounds', bounds);
    delete this._opts.center;
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Sets the center or coordinate bounds based on the specified region code.
   *
   * @param {string} key
   * @returns {MapConfig}
   * @memberof MapConfig
   * @see Regions
   */


  setRegion(key) {
    const region = _Regions.Regions.get(key);

    if (region) {
      if (region.center) {
        this.setCenter(`${region.center.lat},${region.center.lon}`, this.zoom());
      } else if (region.bounds) {
        this.setBounds(region.bounds);
      }
    }

    return this;
  }
  /*
   * Size
   */

  /**
   * Returns the image size.
   *
   * @returns {Size}
   * @memberof MapConfig
   */


  size() {
    const size = this.opts('size');

    if (size && size.width && size.height) {
      return {
        width: size.width,
        height: size.height
      };
    }

    return null;
  }
  /**
   * Sets the image size.
   *
   * @param {number} width
   * @param {number | 'auto'} height
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setSize(width, height) {
    if (height === 'auto') {
      // calculate height if we have a scale factor for the height to retain same image aspect ratio
      const factor = this.opts('size.factor');

      if (factor) {
        height = Math.round(width * factor);
      }
    }

    this._opts.size = {
      width,
      height
    };
    this.trigger('change:size', this.size());
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Returns whether to use Metric units for text layers.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  metric() {
    return this.opts('metric');
  }
  /**
   * Sets whether to use Metric units for text layers.
   *
   * @param {boolean} metric
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setMetric(metric) {
    this.opts('metric', metric);
    this.trigger('change:metric', {
      metric
    });
    this.onChange();
    return this;
  }
  /**
   * Returns an object of `MapRequest` options to use for the image request from the current
   * configuration.
   *
   * @param {string[]} [groups]
   * @param {boolean} [future=false]
   * @returns {{ [key: string]: any }}
   * @memberof MapConfig
   */


  toRequestOpts(groups, future = false) {
    groups = groups || ['base', 'data', 'overlays', 'text']; // let data = groups.indexOf('data') !== -1 ? this.data() : null;

    let layerCodes = [];
    groups.forEach(group => {
      const clayers = this.opts(`layers.${group}`);
      if (!(0, _utils.isEmpty)(clayers)) layerCodes = layerCodes.concat(clayers);
    });

    if (layerCodes) {
      let filtered = [...layerCodes]; // determine if we need imperial or metric text layers based on current units

      if (groups.indexOf('text') > -1) {
        filtered = filtered.map(value => {
          if (/-text-?/.test(value) && this.layers.hasMetric(value)) {
            const text = this.opts('metric') ? 'text-metric' : 'text';
            const matches = value.match(/^([\w-]+-text)(-metric)?(-(dk|lg)){0,2}/);
            const code = matches[1].replace(/-text.*$/, '');
            const modifiers = matches[3] || '';
            return `${code}-${text}${modifiers}`;
          }

          return value.replace(/-metric/, '');
        });
      } // reduce layers.data and layers.text to either past or future layers depending on
      // value of `opts.future`


      if (groups.indexOf('data') !== -1 || groups.indexOf('text') !== -1) {
        const futureLayers = this.layers.future();
        const futureLayerCodes = this.layers.futureCodes(); // if `opts.autoFuture` is enabled, iterate through data types and automatically
        // include the future layer type that corresponds with it

        if (this.opts('autoFuture')) {
          layerCodes.forEach(id => {
            const futureLayer = this.layers.find('id', `f${id}`, true);

            if (futureLayer && filtered.indexOf(futureLayer.id) === -1) {
              filtered.splice(layerCodes.indexOf(id) + 1, 0, futureLayer.id);
            }
          });
        }

        const isFuture = code => {
          let match = futureLayerCodes.indexOf(code) !== -1;

          if (!match) {
            futureLayerCodes.forEach(id => {
              const re = new RegExp(`^${id}-`);

              if (!match && re.test(code)) {
                match = true;
              }
            });
          }

          return match;
        };

        filtered = filtered.filter(id => {
          // allow overlays and masks to be included with either past or future layers
          if (this.layers.inGroup(id, 'overlay') || this.layers.inGroup(id, 'masks')) {
            return true;
          }

          return future ? isFuture(id) : !isFuture(id);
        });
      }

      if (filtered.length === 0) {
        layerCodes = null;
      } else {
        layerCodes = filtered;
      }
    }

    let center = this.center();

    if ((0, _utils.isPlainObject)(center)) {
      const coord = center;
      center = `${coord.lat},${coord.lon}`;
    }

    return {
      layers: {
        base: groups.indexOf('base') !== -1 ? this.base() : null,
        data: groups.indexOf('data') !== -1 ? layerCodes : null,
        overlays: groups.indexOf('overlays') !== -1 ? this.overlays() : null,
        text: groups.indexOf('text') !== -1 ? layerCodes : null
      },
      p: center,
      zoom: this.zoom(),
      bounds: this.bounds(),
      size: this.size(),
      offset: this.offset(),
      metric: this.metric(),
      format: 'png'
    };
  }

}

var _default = MapConfig;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 317 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Regions = void 0;

/**
 * @ignore
 */
const store = {
  us: {
    name: 'United States',
    bounds: {
      north: 56.26,
      west: -131.39,
      south: 15.45,
      east: -61.17
    }
  },
  usne: {
    name: 'Northeast',
    bounds: {
      north: 50.37,
      west: -87.71,
      south: 36.42,
      east: -61.96
    }
  },
  usec: {
    name: 'Mid-Atlantic',
    bounds: {
      north: 42.16,
      west: -88.18,
      south: 31.62,
      east: -70.55
    }
  },
  usse: {
    name: 'Southeast',
    bounds: {
      north: 38.85,
      west: -99.23,
      south: 22.31,
      east: -73.48
    }
  },
  usnc: {
    name: 'Northern Plains',
    bounds: {
      north: 51.18,
      west: -107.80,
      south: 37.44,
      east: -82.05
    }
  },
  usov: {
    name: 'Lower Ohio Valley',
    bounds: {
      north: 43.10,
      west: -97.10,
      south: 32.70,
      east: -79.48
    }
  },
  usce: {
    name: 'Central Plains',
    bounds: {
      north: 47.37,
      west: -110.83,
      south: 34.78,
      east: -88.42
    }
  },
  ussc: {
    name: 'Southern Plains',
    bounds: {
      north: 40.85,
      west: -111.05,
      south: 24.69,
      east: -85.30
    }
  },
  usnw: {
    name: 'Pacific Northwest',
    bounds: {
      north: 52.50,
      west: -129.33,
      south: 39.13,
      east: -103.53
    }
  },
  uswc: {
    name: 'West Coast',
    bounds: {
      north: 45.95,
      west: -129.02,
      south: 33.06,
      east: -106.61
    }
  },
  ussw: {
    name: 'Southwest',
    bounds: {
      north: 44.15,
      west: -127.01,
      south: 28.70,
      east: -101.21
    }
  },
  usak: {
    name: 'Alaska',
    bounds: {
      north: 72.87,
      west: -196.96,
      south: 48.81,
      east: -127.18
    }
  },
  ushi: {
    name: 'Hawaii',
    bounds: {
      north: 24.61,
      west: -162.77,
      south: 16.55,
      east: -151.30
    }
  },
  ca: {
    name: 'Canada',
    bounds: {
      north: 75.85,
      west: -146.95,
      south: 38.96,
      east: -43.95
    }
  },
  mx: {
    name: 'Mexico',
    bounds: {
      north: 36.63,
      west: -119.40,
      south: 11.44,
      east: -82.13
    }
  },
  crb: {
    name: 'Caribbean',
    bounds: {
      north: 29.57,
      west: -91.45,
      south: 5.18,
      east: -57.00
    }
  },
  nam: {
    name: 'North America',
    bounds: {
      north: 75.32,
      west: -185.45,
      south: -4.57,
      east: -22.68
    }
  },
  sam: {
    name: 'South America',
    bounds: {
      north: 19.97,
      west: -125.51,
      south: -58.45,
      east: -1.75
    }
  },
  eur: {
    name: 'Europe',
    bounds: {
      north: 72.50,
      west: -41.50,
      south: 30.30,
      east: 59.41
    }
  },
  afr: {
    name: 'Africa',
    bounds: {
      north: 44.47,
      west: -44.83,
      south: -41.25,
      east: 82.10
    }
  },
  mide: {
    name: 'Middle East',
    bounds: {
      north: 46.01,
      west: 23.29,
      south: 8.93,
      east: 80.77
    }
  },
  aus: {
    name: 'Australia',
    bounds: {
      north: -0.18,
      west: 107.05,
      south: -50.01,
      east: 184.22
    }
  },
  nas: {
    name: 'Northern Asia',
    bounds: {
      north: 81.09,
      west: 24.61,
      south: 22.27,
      east: 189.84
    }
  },
  sas: {
    name: 'Southern Asia',
    bounds: {
      north: 55.97,
      west: 59.59,
      south: -15.45,
      east: 171.04
    }
  },
  asia: {
    name: 'Asia',
    bounds: {
      north: 78.06,
      west: 12.66,
      south: -14.94,
      east: 206.02
    }
  },
  world: {
    name: 'World',
    bounds: {
      north: 85.00,
      west: -170.16,
      south: -67.07,
      east: 191.60
    }
  }
};
/**
 * The `Regions` module provides a store for declaring geographical regions based on a center
 * coordinate or coordinate bounds.
 */

var Regions;
exports.Regions = Regions;

(function (Regions) {
  /**
   * Returns the region configuration associated with the specified key, if any.
   *
   * @param {string} key
   */
  Regions.get = key => store[key];
  /**
   * Sets the region configuration associated with the specified key.
   *
   * @param {string} key
   * @param {RegionType} region
   */


  Regions.set = (key, region) => {
    store[key] = region;
  };
  /**
   * Returns the region URL slug associated with the specified key, if any.
   *
   * @param {string} key
   */


  Regions.slug = key => {
    const region = Regions.get(key);

    if (region) {
      return region.slug || `${region.name}`.toLowerCase().replace(/\s+/, '-');
    }

    return undefined;
  };

  Regions.asArray = (keys, format) => {
    const items = [];
    keys.forEach(code => {
      const region = Regions.get(code);

      if (region) {
        const obj = {};
        Object.keys(format).forEach(key => {
          const src = format[key];
          const dest = key;

          if (src === 'key' || src === 'code') {
            obj[dest] = code;
          } else if (src === 'slug') {
            obj[dest] = Regions.slug(code);
          } else {
            obj[dest] = region[src];
          }
        });
        items.push(obj);
      }
    });
    return items;
  };
})(Regions || (exports.Regions = Regions = {}));

/***/ }),
/* 318 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ImageAnimation = _interopRequireDefault(__webpack_require__(224));

var _Timeline = _interopRequireDefault(__webpack_require__(221));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MapViewAnimator {
  constructor(targets, opts) {
    this._targets = targets;
    this._opts = (0, _utils.extend)({
      enabled: true,
      autoplay: false,
      alwaysShowPast: false,
      alwaysShowFuture: false
    }, opts);
    this.init();
  }

  get timeline() {
    return this._timeline;
  }

  set provider(provider) {
    Object.keys(this.timeline.animations).forEach(key => {
      const anim = this.timeline.animations[key];

      if (anim instanceof _ImageAnimation.default) {
        anim.provider = provider;
      }
    });
  }

  get past() {
    return this.timeline.get('past');
  }

  get future() {
    return this.timeline.get('future');
  }

  get pastText() {
    return this.timeline.get('pastText');
  }

  get futureText() {
    return this.timeline.get('futureText');
  }

  init() {
    const targets = this._targets;
    const tl = new _Timeline.default(this._opts);
    this._timeline = tl; // break up past and future layers into separate animations so we can show/hide their containers based on
    // the parent timeline animation's time

    if (targets.past) {
      const pastAnim = new _ImageAnimation.default(targets.past, (0, _utils.extend)({}, this._opts, {
        key: 'past',
        alwaysShow: this._opts.alwaysShowPast
      }));
      tl.add('past', pastAnim);
    }

    if (targets.future) {
      const futureAnim = new _ImageAnimation.default(targets.future, (0, _utils.extend)({}, this._opts, {
        key: 'future',
        future: true,
        alwaysShow: this._opts.alwaysShowFuture
      }));
      tl.add('future', futureAnim);
    }

    if (targets.pastText) {
      const pastTextAnim = new _ImageAnimation.default(targets.pastText, (0, _utils.extend)({}, this._opts, {
        key: 'pastText',
        alwaysShow: this._opts.alwaysShowPast
      }));
      tl.add('pastText', pastTextAnim);
    }

    if (targets.futureText) {
      const futureTextAnim = new _ImageAnimation.default(targets.futureText, (0, _utils.extend)({}, this._opts, {
        key: 'futureText',
        future: true,
        alwaysShow: this._opts.alwaysShowFuture
      }));
      tl.add('futureText', futureTextAnim);
    }
  }

}

var _default = MapViewAnimator;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 319 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _ = __webpack_require__(320);

var _Http = _interopRequireDefault(__webpack_require__(101));

var _LegendStore = _interopRequireDefault(__webpack_require__(327));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

/**
 * A legend view is responsible for displaying and manging a series of legend elements.
 *
 * @export
 * @class LegendView
 * @extends {EventDispatcher}
 */
class LegendView extends _EventDispatcher.default {
  /**
   * Initializes and returns a legend view instance with the specified target and configuration
   * object.
   *
   * @param {*} target
   * @param {LegendOptions} [opts]
   * @memberof LegendView
   */
  constructor(target, opts) {
    super();
    this._loading = false;
    this._loadCallbacks = {};

    this._onResize = () => {
      this.trigger('resize', this.getSize());
    };

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for LegendView');
    }

    this._opts = (0, _utils.extend)({
      size: {
        width: 400,
        height: 40
      }
    }, opts);
    this._store = new _LegendStore.default();
    (0, _DOM.default)(target).append(`<div class="awxjs__legend-view"></div>`);
    this._target = (0, _DOM.default)('.awxjs__legend-view', target);
  }
  /**
   * The DOM element for the legend view.
   *
   * @readonly
   * @type {*}
   * @memberof LegendView
   */


  get $el() {
    return this._target;
  }

  get count() {
    return this._store.count;
  }
  /**
   * Adds a legend for the specified legend type code and options.
   *
   * @param {string} type
   * @param {LegendOptions} [opts]
   * @returns
   * @memberof LegendView
   */


  add(type, opts) {
    const key = this.getKey(type);
    let config; // load default legend styles if not already cached

    if (!this._configs) {
      this._loadCallbacks[type] = () => {
        this.add(type, opts);
      };

      if (this._loading === false) {
        this.loadStyles();
      }

      return;
    }

    opts = (0, _utils.extend)((0, _utils.cloneDeep)(this._opts), opts);

    if (opts.type === 'image') {
      config = opts;
    } // determine if we have a default style for the legend


    const legendStyle = this.configForType(type);

    if (legendStyle) {
      const {
        config: styleConfig
      } = legendStyle;

      if (!(0, _utils.isEmpty)(styleConfig)) {
        config = styleConfig;
      }

      if (!(0, _utils.isEmpty)(styleConfig.use)) {
        const parentStyle = this.configForType(styleConfig.use);
        config = Object.assign(Object.assign({}, parentStyle), config);
      }
    }

    if (!(0, _utils.isset)(config)) {
      // console.warn(`[Aeris] No configuration found for legend {${type}}, not adding to view`);
      return;
    }

    const legendOpts = (0, _utils.extend)(opts, {
      title: config.title,
      size: this._opts.size,
      autosize: this._opts.autosize,
      format: this._opts.format,
      metric: this._opts.metric
    }, config, opts);

    let legend = this._store.get(key); // just update the legend as needed if it already exists


    if (legend) {
      this._store.increment(key);

      legend.update(legendOpts);
      return;
    }

    if (config && !(0, _utils.isEmpty)(config)) {
      legend = this.createLegend(type, config, legendOpts);
      this.addLegend(legend);

      if (key !== type) {
        this._store.map(key, type);
      }
    }
  }
  /**
   * Returns the legend for the specified type code if it exists in the view.
   *
   * @param {string} type
   * @returns {LegendRenderable}
   * @memberof LegendView
   */


  get(type) {
    const key = this.getKey(type);

    if (key) {
      return this._store.get(key);
    }

    return null;
  }
  /**
   * Updates the legend view for the specified type codes and options. All previously existing
   * legends will be removed.
   *
   * @param {string[]} types
   * @param {*} [opts]
   * @memberof LegendView
   */


  set(types, opts) {
    types = types || [];
    this.removeAll(types);
    types.forEach(type => {
      if (!this.has(type)) {
        this.add(type, opts);
      } else {
        this.get(type).update(opts);
      }
    });
  }
  /**
   * Removes the legend for the specified type code.
   *
   * @param {string} type
   * @memberof LegendView
   */


  remove(type) {
    const key = this.getKey(type);

    if (key) {
      const legend = this._store.get(key);

      if (legend) {
        this._store.remove(key); // remove legend from the view if total references is 0


        if (this._store.refCount(key) === 0) {
          this.removeLegend(legend);
        }
      }

      if (legend instanceof _EventDispatcher.default) {
        legend.off('resize', this._onResize);
      }

      this._onResize();
    }

    if (this.count === 0) {
      this.$el.hide();
      this.trigger('empty');
    }
  }
  /**
   * Sets the legend using a static image URL. All previously existing legends will be removed.
   *
   * @param {string} url
   * @memberof LegendView
   */


  setUrl(url) {
    this.removeAll();
    this.$el.empty();
    this.$el.append(`<div class="awxjs__legend"><img src="${url}"></div>`);
  }
  /**
   * Adds a legend item to the view.
   *
   * @param {LegendRenderable} legend
   * @memberof LegendView
   */


  addLegend(legend) {
    const key = legend.key;

    this._store.add(key, legend);

    this.$el.append(legend.$el);
    this.$el.show();

    if (legend instanceof _EventDispatcher.default) {
      legend.on('resize', this._onResize);
    }

    this.trigger('add', {
      key: legend.key,
      count: this.count
    });

    this._onResize();
  }
  /**
   * Removes a legend item from the view.
   *
   * @param {LegendRenderable} legend
   * @memberof LegendView
   */


  removeLegend(legend) {
    if (legend) {
      legend.$el.remove();

      this._store.remove(legend.key, true);

      this.trigger('remove', {
        key: legend.key,
        count: this.count
      });
    }
  }
  /**
   * Removes all existing legends from the view.
   *
   * @param {string[]} [exclude]
   * @memberof LegendView
   */


  removeAll(exclude) {
    Object.keys(this._store.items).forEach(key => {
      let remove = true;

      if (exclude) {
        const altkeys = this._store.mapping.get(key) || [];

        if (exclude.indexOf(key) !== -1) {
          remove = false;
        } else if (altkeys) {
          altkeys.forEach(k => {
            if (exclude.indexOf(k) !== -1) {
              remove = false;
            }
          });
        }
      }

      if (remove) {
        this.remove(key);
      }
    });
  }
  /**
   * Returns whether the view contains a legend for the specified type code.
   *
   * @param {string} type
   * @returns {boolean}
   * @memberof LegendView
   */


  has(type) {
    const {
      key
    } = this.configForType(type);

    if (key) {
      return this._store.has(key);
    }

    return false;
  }
  /**
   * Forces an update of all existing legends.
   *
   * @param {{ [key: string]: any }} [opts]
   * @memberof LegendView
   */


  update(opts) {
    this._each((key, legend) => legend.update(opts));
  }
  /**
   * Sets whether the display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof LegendView
   */


  setMetric(metric) {
    this._opts.metric = metric;

    this._each((key, legend) => legend.setMetric(metric));
  }
  /**
   * Sets the size of the view and existing legends.
   *
   * @param {Size} size
   * @memberof LegendView
   */


  setSize(size) {
    this._opts.size = size;

    this._each((key, legend) => legend.setSize(size));
  }

  getSize() {
    let height = 0;
    let width = 0;

    this._each((key, legend) => {
      const size = legend.getSize();
      height += size.height;
      width = Math.max(width, size.width);
    });

    return {
      width,
      height
    };
  }
  /**
   * Sets the width of the view and all existing legends. The previous height value will be
   * used.
   *
   * @param {number} width
   * @memberof LegendView
   */


  setWidth(width) {
    const {
      height
    } = this._opts.size;
    this.setSize({
      width,
      height
    });
  }

  configForType(type) {
    if (!this._configs) return {
      key: null,
      config: null
    };
    let config = this._configs[type];
    let altkey;

    if (!config && /^f/.test(type)) {
      altkey = type.replace(/^f/, '');
      config = this._configs[altkey];
    }

    if (!config) {
      Object.keys(this._configs).forEach(key => {
        const defaults = this._configs[key];
        const enabled = defaults.enabled === true || !(0, _utils.isset)(defaults.enabled);

        if (enabled) {
          const layers = defaults.layers;

          if (layers) {
            layers.forEach(pattern => {
              const re = new RegExp(pattern);

              if (re.test(type)) {
                config = (0, _utils.cloneDeep)(defaults);
                altkey = key;
              }
            });

            if (config && !altkey) {
              altkey = key;
            }
          }
        }
      });
    }

    return {
      key: altkey || type,
      config: (0, _utils.cloneDeep)(config)
    };
  }

  _reset() {
    this.$el.empty();

    this._each((key, legend) => legend.reset());
  }

  _each(fn) {
    this._store.each(fn);
  }

  getKey(type) {
    let key = type; // determine if we have a different key to use from the style

    const legendStyle = this.configForType(type);

    if (legendStyle) {
      const {
        key: styleKey
      } = legendStyle;
      key = styleKey;
    }

    return key;
  }

  createLegend(type, config, opts) {
    const key = this.getKey(type);
    let legend;

    if (config.type === 'image') {
      legend = new _.ImageLegend(key, opts);
    } else if (config.grouped && config.items) {
      const typeOverrides = opts.types || {}; // determine if we need a grouped legend or a single one

      opts.types = config.items.reduce((prev, current) => {
        const {
          config: itemConfig
        } = this.configForType(current.key);
        const itemOpts = (0, _utils.extend)({
          factor: current.factor,
          size: {
            height: this._opts.size.height
          }
        }, itemConfig, typeOverrides[current.key]);
        itemOpts.size.width = Math.floor(this._opts.size.width * itemOpts.factor);
        prev[current.key] = itemOpts;
        return prev;
      }, {});
      legend = new _.GroupedLegend(key, opts);
    } else if (type === 'alerts' || type === 'advisories' || /^alerts-/.test(type)) {
      legend = new _.AdvisoryLegend(key, opts);

      if ((0, _utils.isset)(opts.within)) {
        setTimeout(() => {
          this.update({
            account: opts.account,
            within: opts.within
          });
        }, 500);
      }
    } else {
      legend = new _.StyledLegend(key, opts);
    }

    return legend;
  }

  loadStyles() {
    this._loading = true;
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      if (this._configs) {
        resolve(this._configs);
        return;
      }

      _Http.default.request('https://legends.aerisapi.com/defaults.json').then(res => {
        if (res.data) {
          const configs = res.data;
          Object.keys(configs).forEach(key => {
            const config = configs[key];

            if (config.config) {
              // convert underscore keys to dot-notation
              Object.keys(config.config).forEach(configKey => {
                if (configKey.indexOf('_') !== -1) {
                  const setKey = configKey.replace(/^labels_/, 'label_').replace(/_/g, '.');
                  (0, _utils.set)(config.config, setKey, config.config[configKey]);
                  delete config.config[configKey];
                }
              });
              config.styles = (0, _utils.cloneDeep)(config.config);
              delete config.config;
            }
          });
          this._configs = configs;
          this._loading = false;
          resolve((0, _utils.cloneDeep)(this._configs));
          Object.keys(this._loadCallbacks).forEach(key => {
            const fn = this._loadCallbacks[key];
            fn();
          });
        }
      });
    }));
  }

}

var _default = LegendView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 320 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "Legend", ({
  enumerable: true,
  get: function () {
    return _Legend.default;
  }
}));
Object.defineProperty(exports, "ImageLegend", ({
  enumerable: true,
  get: function () {
    return _ImageLegend.default;
  }
}));
Object.defineProperty(exports, "StyledLegend", ({
  enumerable: true,
  get: function () {
    return _StyledLegend.default;
  }
}));
Object.defineProperty(exports, "AdvisoryLegend", ({
  enumerable: true,
  get: function () {
    return _AdvisoryLegend.default;
  }
}));
Object.defineProperty(exports, "GroupedLegend", ({
  enumerable: true,
  get: function () {
    return _GroupedLegend.default;
  }
}));

var _Legend = _interopRequireDefault(__webpack_require__(321));

var _ImageLegend = _interopRequireDefault(__webpack_require__(322));

var _StyledLegend = _interopRequireDefault(__webpack_require__(323));

var _AdvisoryLegend = _interopRequireDefault(__webpack_require__(324));

var _GroupedLegend = _interopRequireDefault(__webpack_require__(326));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),
/* 321 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A legend implements the `LegendRenderable` interface and provides the base legend
 * functionality.
 *
 * @export
 * @class Legend
 * @implements {LegendRenderable}
 */
class Legend extends _EventDispatcher.default {
  /**
   * Initializes and returns a legend for the specified key and configuration options.
   *
   * @param {string} key
   * @param {LegendOptions} opts
   * @memberof Legend
   */
  constructor(key, opts) {
    super();
    this._key = key;
    this._opts = (0, _utils.extend)({
      size: undefined,
      autosize: false,
      format: 'svg',
      metric: false
    }, opts);

    if (!(0, _utils.isset)(this._opts.size)) {
      this._opts.autosize = true;
    }

    this._target = (0, _DOM.default)(`<div class="awxjs__legend awxjs__legend-${key}"></div>`);
    setTimeout(() => {
      this.update(this._opts);
    }, 500);
  }
  /**
   * Configuration options.
   *
   * @readonly
   * @type {LegendOptions}
   * @memberof Legend
   */


  get opts() {
    return this._opts;
  }
  /**
   * Key associated with the legend.
   *
   * @readonly
   * @type {string}
   * @memberof Legend
   */


  get key() {
    return this._key;
  }
  /**
   * Aeris account used when requesting data for dynamic legends.
   *
   * @readonly
   * @type {Account}
   * @memberof Legend
   */


  get account() {
    return this.opts.account;
  }
  /**
   * DOM element for the legend.
   *
   * @readonly
   * @type {*}
   * @memberof Legend
   */


  get $el() {
    return this._target;
  }
  /**
   * Shows the legend DOM element.
   *
   * @memberof Legend
   */


  show() {
    this.$el.show();
  }
  /**
   * Hides the legend DOM element.
   *
   * @memberof Legend
   */


  hide() {
    this.$el.hide();
  }
  /**
   * Sets the size of the legend.
   *
   * @param {Size} size
   * @memberof Legend
   */


  setSize(size) {
    this._opts.size = (0, _utils.extend)(this._opts.size, size);
    this.update();
  }

  getSize() {
    if (this.$el) {
      const bounds = this.$el.bounds();
      const h = this.$el.outerHeight(true);
      return {
        width: bounds.width,
        height: h
      };
    }

    return {
      width: 0,
      height: 0
    };
  }
  /**
   * Sets whether to display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof Legend
   */


  setMetric(metric) {
    this._opts.metric = metric;
    this.update(null, true);
  }
  /**
   * Returns the unit based on whether the legend is displaying values in Metric or Imperial.
   *
   * @returns {string}
   * @memberof Legend
   */


  units() {
    const key = this._opts.metric ? 'metric' : 'imperial';
    let unit = (0, _utils.get)(this._opts, `units.${key}`);

    if (unit && /^(f|c)$/.test(unit)) {
      unit = unit.toUpperCase();
    }

    return unit;
  }
  /**
   * Resets the legend by removing an existing image.
   *
   * @memberof Legend
   */


  reset() {
    this.$el.empty();
  }
  /**
   * Forces the legend to update if needed.
   *
   * @param {*} [opts]
   * @memberof Legend
   */


  update(opts, force = false) {}

  resize() {
    const size = this.getSize();
    const content = (0, _DOM.default)('.awxjs__legend-content', this.$el).children();

    if (content) {
      content.forEach(el => {
        size.width = Math.max(size.width, (0, _DOM.default)(el).outerWidth(true));
      });
    }

    this.$el.css('width', `${size.width}px`);
    this.trigger('resize', size);
  }

}

var _default = Legend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 322 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Legend = _interopRequireDefault(__webpack_require__(321));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An image legend is an object that is responsible for displaying and managing multiple related
 * legends within a single view along with title labels for each as required.
 *
 * @export
 * @class ImageLegend
 * @implements {LegendRenderable}
 */
class ImageLegend extends _Legend.default {
  constructor() {
    super(...arguments);
    this._load = (0, _utils.debounce)(url => {
      if (!url) {
        const error = new Error('Invalid legend url');
        this.trigger('load:error', {
          error
        });
        this.$el.hide();
        return;
      }

      if (!this._image) {
        this._image = new Image();
      }

      this.trigger('load:start');

      this._image.onload = () => {
        const units = this.units();
        const title = this.opts.title ? this.opts.title.replace(/\([^\)]+\)$/, `${units ? `(${units})` : ''}`) : null;
        this.$el.html(`
				${this.opts.title ? `<div class="awxjs__legend-title">${title}</div>` : ''}
				<div class="awxjs__legend-content"><img src="${url}"></div>
			`); // this.$el.show();

        this.trigger('load:done');
        setTimeout(() => {
          const size = this.getSize();
          size.width = Math.max(size.width, this._image.width);
          this.$el.css('width', `${size.width}px`);
          this.trigger('resize', size);
        }, 150);
      };

      this._image.onerror = () => {
        console.warn(`[Aeris] ImageLegend - Failed to load image from ${url}`);
      };

      this._image.src = url;
    }, 250);
  }

  get image() {
    return this._image;
  }

  url() {
    let url;

    if ((0, _utils.isPlainObject)(this.opts.url)) {
      const key = this.opts.metric ? 'metric' : 'imperial';
      url = url[key];
    } else if ((0, _utils.isString)(this.opts.url)) {
      url = this.opts.url;
    }

    return url;
  }

  getSize() {
    const size = super.getSize();

    if (this._image) {
      size.width = Math.max(size.width, this._image.width);
    }

    return size;
  }
  /**
   * Resets the legend by removing all existing images.
   *
   * @memberof ImageLegend
   */


  reset() {
    this.$el.empty();

    if (this._image) {
      this._image.onload = null;
    }

    this._image = null;
  }

  update(opts, force = false) {
    if (!(0, _utils.isEmpty)(opts)) force = true;

    if (force || !this._image) {
      this._load(this.url());
    }
  }

}

var _default = ImageLegend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 323 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ImageLegend = _interopRequireDefault(__webpack_require__(322));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A styled legend is a legend that is responsible for rendering a legend image based on a specific
 * legend configuration and style.-
 *
 * @export
 * @class StyledLegend
 * @implements {LegendRenderable}
 */
class StyledLegend extends _ImageLegend.default {
  /**
   * Sets the size of the legend.
   *
   * @param {Size} size
   * @memberof StyledLegend
   */
  setSize(size) {
    this.opts.size = (0, _utils.extend)(this.opts.size, size);
    this.update();
  }
  /**
   * Returns the calculated legend url.
   *
   * @returns {string}
   * @memberof StyledLegend
   */


  url() {
    return this._url();
  }

  _url() {
    const config = this.opts;
    const style = (0, _utils.extend)({
      interval: 1,
      gutter: null,
      radius: 6,
      columns: 4,
      metric: false,
      orientation: "h"
      /* HORIZONTAL */
      ,
      cell: {
        size: {
          width: 2,
          height: 10
        }
      },
      label: {
        interval: 20,
        position: "b"
        /* BOTTOM */
        ,
        fontsize: 11,
        color: '#222222'
      }
    }, config.styles);
    const type = config.type || "bar"
    /* BAR */
    ;
    const cellOpts = style.cell || {};
    const labelOpts = style.label || {};
    const params = {};

    if (type === "point"
    /* POINT */
    ) {
        if (!(0, _utils.isset)(style.gutter)) {
          style.gutter = {
            x: 20,
            y: 5
          };
        } else if ((0, _utils.isString)(style.gutter)) {
          const p = style.gutter.split(',');
          style.gutter = {
            x: p[0],
            y: p[1]
          };
        }
      }

    params.ls = labelOpts.fontsize;

    if (!(0, _utils.isEmpty)(labelOpts.custom)) {
      params.labels = labelOpts.custom.replace(/,\s+/g, ',').replace(/\s/g, '%20');
    }

    if (!(0, _utils.isEmpty)(labelOpts.color)) {
      const color = labelOpts.color.replace(/#/, '');

      if (color.length === 6) {
        params.lc = color;
      }
    }

    if (type === "point"
    /* POINT */
    && !(0, _utils.isEmpty)(style.filter_groups)) {
      params.filter = style.filter_groups;
    }

    if ((0, _utils.isset)(config.range)) {
      if ((0, _utils.isString)(config.range)) {
        params.range = `,${config.range}`;
      } else if ((0, _utils.isArray)(config.range)) {
        if (config.range.length === 1) {
          params.range = `,${config.range[0]}`;
        } else {
          params.range = config.range.join(',');
        }
      }
    }

    if ((0, _utils.isset)(config.keys)) {
      params.keys = config.keys;
    } else if ((0, _utils.isset)(config.filter)) {
      params.filter = config.filter;
    }

    const units = style.units;

    if (units) {
      if (config.metric) {
        params.units = units.metric;
      } else {
        params.units = units.imperial;
      }
    }

    const {
      width,
      height
    } = config.size || {
      width: null,
      height: null
    };
    const {
      width: cellWidth,
      height: cellHeight
    } = cellOpts.size || {
      width: null,
      height: null
    };
    const vars = {
      type,
      interval: !(0, _utils.isEmpty)(style.interval) ? `-i${style.interval}` : '',
      label: {
        interval: !(0, _utils.isEmpty)(labelOpts.interval) ? `-li${labelOpts.interval}` : ''
      },
      cell: {
        size: !(0, _utils.isEmpty)(cellWidth) && !(0, _utils.isEmpty)(cellHeight) ? `-c${cellWidth}x${cellHeight}` : '',
        pad: (0, _utils.isset)(style.gutter) ? `-p${style.gutter.x},${style.gutter.y}` : ''
      },
      layout: `-${style.orientation},${labelOpts.position}`,
      metric: config.metric ? '-metric' : '',
      size: !(0, _utils.isEmpty)(width) && !(0, _utils.isEmpty)(height) && !config.autosize ? `_${width}x${height}` : '',
      format: config.format,
      radius: !(0, _utils.isEmpty)(style.radius) ? `-r${style.radius}` : '',
      columns: !(0, _utils.isEmpty)(style.columns) && style.columns > 0 ? `-col${style.columns}` : ''
    };
    let url = `https://legends.aerisapi.com/${this.key}`;

    if (type === "point"
    /* POINT */
    ) {
        url += `${vars.radius}${vars.columns}${vars.cell.pad}`;
      } else {
      url += `${vars.interval}${vars.label.interval}${vars.cell.size}${vars.cell.pad}${vars.layout}${vars.metric}`;
    }

    url += `${vars.size}.${vars.format}`; // add query string to url if we have params

    url += (url.indexOf('?') > -1 ? '&' : '?') + Object.keys(params).map(k => `${encodeURIComponent(k)}=${params[k]}`).join('&');
    return url;
  }

}

var _default = StyledLegend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 324 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _StyledLegend = _interopRequireDefault(__webpack_require__(323));

var _ApiRequest = _interopRequireDefault(__webpack_require__(100));

var _Mercator = __webpack_require__(325);

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const boundsStrFromCenter = (lat, lon, zoom, size) => {
  const center = {
    lat,
    lon
  };

  const nw = _Mercator.Mercator.pointToCoord(0, 0, zoom, center, size);

  const se = _Mercator.Mercator.pointToCoord(size.width, size.height, zoom, center, size);

  nw.lat = parseFloat(nw.lat.toFixed(2));
  nw.lon = parseFloat(nw.lon.toFixed(2));
  se.lat = parseFloat(se.lat.toFixed(2));
  se.lon = parseFloat(se.lon.toFixed(2));
  return `${nw.lat},${nw.lon},${se.lat},${se.lon}`;
};
/**
 * An advisory legend is a legend object that is responsible for displaying and managing a point
 * legend based on dynamic advisory data that filters advisory elements based on specific filters
 * and/or VTEC codes.
 *
 * @export
 * @class AdvisoryLegend
 * @extends {Legend}
 */


class AdvisoryLegend extends _StyledLegend.default {
  /**
   * Forces the legend to update if needed.
   *
   * Typically this method is called with valid coordinate bounds passed to the `opts.within`
   * property in order to update the advisories displayed based on those within the specified
   * bounds.
   *
   * @param {*} [opts]
   * @memberof AdvisoryLegend
   */
  update(opts, force = false) {
    if (opts) {
      if (opts.within) {
        if (opts.within.bounds) {
          let {
            east,
            west
          } = opts.within.bounds;
          const lspan = Math.abs(east - west);
          const lcount = Math.floor(lspan / 360); // if we're spanning 360 deg lon or more, then override the west/east values to be
          // clamped at the valid -180 > 180 span

          if (lcount > 0) {
            west = -180;
            east = 180;
          }

          opts.within.bounds.west = west;
          opts.within.bounds.east = east;
        }

        this.opts.within = opts.within;
      }

      this._update();
    } else if ((0, _utils.isset)(this.opts.keys)) {
      super.update(opts, force);
    }
  }

  _update() {
    if (!this.account) {
      console.warn('[Aeris] Cannot render advisories/alerts legend, no valid Aeris account defined');
      return;
    }

    if (!this._request) {
      this._request = (0, _utils.debounce)(opts => {
        this._getVtecCodes(opts).then(codes => {
          this.opts.keys = codes.join(','); // hide the legend if we don't have any VTEC codes

          if (codes.length === 0) {
            // this.hide();
            // this.reset();
            const title = this.opts.title ? this.opts.title.replace(/\([^\)]+\)$/, '') : null;
            this.$el.html(`
							${title ? `<div class="awxjs__legend-title">${title}</div>` : ''}
							<div class="awxjs__legend-content">
								<div class="awxjs__legend-empty">No advisories within map bounds.</div>
							</div>
						`);
            this.resize();
          } else {
            this.show();
            this.update(null, true);
          }
        });
      }, 1000);
    }

    this._request(this.opts.within);
  }

  _getVtecCodes(opts = {}) {
    const {
      size
    } = opts;
    let {
      center,
      bounds,
      zoom
    } = opts;
    zoom = parseInt(zoom, 10);
    return new Promise((resolve, reject) => {
      if (!bounds) {
        if (!size || Number.isNaN(size.width) || Number.isNaN(size.height)) {
          reject(new Error('Size is not a number'));
          return;
        }

        if (!bounds && center) {
          if ((0, _utils.isString)(center) && /^[\d\.-]+,[\d\.-]+/.test(center)) {
            center = center.split(',');
            bounds = boundsStrFromCenter(center[0], center[1], zoom, size);
          } else if ((0, _utils.isObject)(center) && center.lat && center.lon) {
            bounds = boundsStrFromCenter(center.lat, center.lon, zoom, size);
          }
        }
      }

      if (bounds) {
        this._getAdvisories(bounds).then(codes => {
          resolve(codes);
        });
      } else if (center) {
        this._getPlace(center, size, zoom).then(b => {
          this._getAdvisories(b).then(codes => {
            resolve(codes);
          });
        });
      }
    });
  }

  _getPlace(loc, size, zoom) {
    return new Promise((resolve, reject) => {
      const request = new _ApiRequest.default({
        client: this.account.credentials()
      });
      request.endpoint('places').place(loc).limit(1).get().then(result => {
        if (result.data) {
          const {
            loc: {
              lat,
              long: lon
            }
          } = result.data;
          const boundsStr = boundsStrFromCenter(lat, lon, zoom, size);
          const bounds = boundsStr.split(',').map(val => parseFloat(val));

          if (bounds.length === 4) {
            resolve({
              north: bounds[0],
              west: bounds[1],
              south: bounds[2],
              east: bounds[3]
            });
          } else {
            reject();
          }
        }
      });
    });
  }

  _getAdvisories(bounds) {
    return new Promise((resolve, reject) => {
      const isSummary = this.account.canAccess('advisories_summary');
      let sortByName = true;

      const setupRequest = (requestBounds, summary) => {
        const request = new _ApiRequest.default({
          client: this.account.credentials()
        });

        if (summary) {
          request.endpoint('alerts/summary').fields('summary.typeCodes,summary.types.type,summary.types.code');
          request.sort('priority:1');
          sortByName = false;
        } else {
          request.endpoint('alerts').fields('details.type,details.name').limit(300);
        }

        if (requestBounds.west < -180 || requestBounds.west > 180) {
          requestBounds.west += 360 * Math.floor(requestBounds.west / 360);
        }

        request.action("within"
        /* WITHIN */
        ).bounds(requestBounds);
        return request;
      };

      const process = data => {
        const results = [];

        if (data) {
          if (isSummary) {
            data = data[0] || data; // vtecs = get(data, 'summary.typeCodes');

            const types = (0, _utils.get)(data, 'summary.types');
            (types || []).filter(item => (0, _utils.isset)(item) && (0, _utils.isset)(item.code)).forEach(item => {
              const {
                code,
                type
              } = item;
              const exists = results.some(result => result.code === code);

              if (code && exists === false) {
                results.push({
                  code,
                  name: type.toUpperCase()
                });
              }
            });
          } else {
            data.filter(item => (0, _utils.isset)(item) && (0, _utils.isset)(item.type)).forEach(advisory => {
              const {
                type: code,
                name: type
              } = advisory.details;
              const exists = results.some(result => result.code === code);

              if (code && exists === false) {
                results.push({
                  code,
                  name: type.toUpperCase()
                });
              }
            });
          }
        } // sort advisories by name


        const sorted = !sortByName ? results : results.sort((a, b) => {
          if (a.name < b.name) {
            return -1;
          }

          if (a.name > b.name) {
            return 1;
          }

          return 0;
        }); // return an array of VTEC codes for the sorted list

        const vtecs = sorted.reduce((prev, current) => {
          prev.push(current.code);
          return prev;
        }, []);
        return vtecs;
      }; // due to a limitation within the API, if the lspan is 180 or greater we need to split the
      // requests into two, each covering half the span; also if we cross the dateline


      const {
        west,
        east
      } = bounds;
      const lspan = west > east ? Math.abs(180 - west + (180 - Math.abs(east))) : Math.abs(east - west);

      if (lspan > 180 || west > east) {
        const offset = lspan / 2;
        const clampToDateline = west > east;
        const mid = west + offset;
        const batch = new _ApiRequest.default({
          client: this.account.credentials()
        });
        const leftRequest = setupRequest((0, _utils.extend)({}, bounds, {
          east: clampToDateline ? 180 : mid
        }), isSummary);
        const rightRequest = setupRequest((0, _utils.extend)({}, bounds, {
          west: clampToDateline ? -180 : mid
        }), isSummary);
        batch.addRequest(leftRequest);
        batch.addRequest(rightRequest);
        batch.get().then(result => {
          const responses = (0, _utils.get)(result, 'data.responses');
          let data = isSummary ? {
            summary: {
              types: [],
              typeCodes: []
            }
          } : [];

          if (responses) {
            responses.forEach(response => {
              response = response.response || response;

              if (response) {
                if (isSummary) {
                  const dataset = response[0] || response;
                  const {
                    types,
                    typeCodes
                  } = dataset.summary || {};
                  data.summary.types = data.summary.types.concat(types);
                  data.summary.typeCodes = data.summary.typeCodes.concat(typeCodes);
                } else if (!(0, _utils.isEmpty)(response)) {
                  data = data.concat(response);
                }
              }
            });
          }

          const vtecs = process(data || {});
          resolve(vtecs);
        });
      } else {
        const request = setupRequest(bounds, isSummary);
        request.get().then(result => {
          const vtecs = process(result.data || {});
          resolve(vtecs);
        });
      }
    });
  }

}

var _default = AdvisoryLegend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 325 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Mercator = void 0;

/**
 * @ignore
 */
const DegToRad = Math.PI / 180;
/**
 * @ignore
 */

const RadToDeg = 180 / Math.PI;
/**
 * @ignore
 */

const TILE_SIZE = 256;
/**
 * @ignore
 */

const _scale = zoom => TILE_SIZE * 0.5 / Math.PI * Math.pow(2, zoom);
/**
 * @ignore
 */


const _radians = value => value * DegToRad;
/**
 * @ignore
 */


const _degrees = value => value * RadToDeg;
/**
 * @ignore
 */


const _offset = (coord, zoom, size) => {
  const pi = Math.PI;
  const scale = TILE_SIZE * 0.5 / pi * Math.pow(2, zoom);

  const lat = _radians(coord.lat);

  const lon = _radians(coord.lon);

  const x = scale * (lon + pi);
  const y = scale * (pi - Math.log(Math.tan(pi * 0.25 + lat * 0.5)));
  return {
    x: size.width * 0.5 - x,
    y: size.height * 0.5 - y
  };
};
/**
 * @ignore
 */


const toFixed = (value, places = 4) => {
  const factor = Math.pow(10, places);
  return Math.round(value * factor) / factor;
};
/**
 * The `Mercator` module provides utility functions when working with a map in Mercator project,
 * such as converting between geographical coordinates and pixel coordinates and calculating
 * coordinate bounds.
 */


var Mercator;
exports.Mercator = Mercator;

(function (Mercator) {
  /**
   * Returns the coordinate for the specified pixel location on a map.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} zoom
   * @param {Coordinate} [center=undefined]
   * @param {Size} [size=undefined]
   * @returns {Coordinate}
   */
  Mercator.pointToCoord = (x, y, zoom, center = undefined, size = undefined) => {
    const pi = Math.PI;

    const scale = _scale(zoom);

    const offset = center && size ? _offset(center, zoom, size) : {
      x: 0,
      y: 0
    };
    const x2 = x - offset.x;
    const y2 = y - offset.y;
    const lon = x2 / scale - pi;
    const lat = 2 * (Math.atan(Math.exp(pi - y2 / scale)) - pi * 0.25);
    return {
      lat: _degrees(lat),
      lon: _degrees(lon)
    };
  };
  /**
   * Returns the pixel location for the specified pixel location on a map.
   *
   * @param {number} lat
   * @param {number} lon
   * @param {number} zoom
   * @param {Coordinate} [center=undefined]
   * @param {Size} [size=undefined]
   * @returns {Point}
   */


  Mercator.coordToPoint = (lat, lon, zoom, center = undefined, size = undefined) => {
    lon *= DegToRad;
    lat *= DegToRad;
    const pi = Math.PI;

    const scale = _scale(zoom);

    const offset = center && size ? _offset(center, zoom, size) : {
      x: 0,
      y: 0
    };
    const x = scale * (lon + pi);
    const y = scale * (pi - Math.log(Math.tan(pi * 0.25 + lat * 0.5)));
    return {
      x: x + offset.x,
      y: y + offset.y
    };
  };
  /**
   * Returns the center coordinate for the specified coordinate bounds.
   *
   * @param {GeoBounds} bounds
   * @returns {Coordinate}
   */


  Mercator.getBoundsCenter = bounds => {
    let lon = (bounds.west + bounds.east) / 2; // handle international dateline crossover

    if (bounds.west > bounds.east) {
      lon = bounds.west - 360 + (bounds.west + bounds.east) / 2;
    }

    return {
      lat: (bounds.south + bounds.north) / 2,
      lon
    };
  };
  /**
   * Returns the zoom level that best fits the given coordinate bounds based on the map size.
   *
   * @param {GeoBounds} bounds
   * @param {Size} size
   * @returns {number}
   */


  Mercator.getBoundsZoomLevel = (bounds, size) => {
    const WORLD_HEIGHT = 256;
    const WORLD_WIDTH = 256;
    const ZOOM_MAX = 21;

    const latRad = lat => {
      const sin = Math.sin(lat * Math.PI / 180);
      const radX2 = Math.log((1 + sin) / (1 - sin)) / 2;
      return Math.max(Math.min(radX2, Math.PI), -Math.PI) / 2;
    };

    const zoom = (mapPx, worldPx, fraction) => {
      return Math.floor(Math.log(mapPx / worldPx / fraction) / Math.LN2);
    };

    const latFraction = (latRad(bounds.north) - latRad(bounds.south)) / Math.PI;
    const lonDiff = bounds.east - bounds.west;
    const lonFraction = (lonDiff < 0 ? lonDiff + 360 : lonDiff) / 360;
    const latZoom = zoom(size.height, WORLD_HEIGHT, latFraction);
    const lngZoom = zoom(size.width, WORLD_WIDTH, lonFraction);
    return Math.min(latZoom, lngZoom, ZOOM_MAX);
  };
  /**
   * Returns the map size for the given coordinate bounds and zoom level.
   *
   * @param {GeoBounds} bounds
   * @param {number} zoom
   * @returns {Size}
   */


  Mercator.getSizeForBounds = (bounds, zoom) => {
    const nw = Mercator.coordToPoint(bounds.north, bounds.west, zoom);
    const se = Mercator.coordToPoint(bounds.south, bounds.east, zoom);
    return {
      width: se.x - nw.x,
      height: se.y - nw.y
    };
  };
  /**
   * Returns a new coordinate bounds that best fits the given coordinate bounds based on the map
   * size and any amount of padding.
   *
   * @param {GeoBounds} bounds
   * @param {Size} size
   * @param {number} [padding=0]
   * @returns {GeoBounds}
   */


  Mercator.getBoundsThatFits = (bounds, size, padding = 0) => {
    const zoom = 0;
    const tl = Mercator.coordToPoint(bounds.north, bounds.west, zoom);
    const br = Mercator.coordToPoint(bounds.south, bounds.east, zoom);
    const bw = Math.abs(br.x - tl.x);
    const bh = Math.abs(br.y - tl.y);
    const center = {
      x: tl.x + bw / 2,
      y: tl.y + bh / 2
    };
    const targetSize = {
      width: bw,
      height: bh
    };
    const sizeRatio = size.height / size.width;
    const boundsRatio = toFixed(bh / bw, 2); // console.log('RATIO - SIZE', sizeRatio, 'BOUNDS', boundsRatio);

    const pxRatio = targetSize.width / size.width;

    if (sizeRatio !== boundsRatio) {
      if (size.width < size.height) {
        const ratio = size.width / size.height;
        targetSize.height = targetSize.width * (1 / ratio); // pxRatio = targetSize.width / size.width;
      } else {
        const ratio = size.height / size.width;
        targetSize.width = targetSize.height * (1 / ratio); // pxRatio = targetSize.height / size.height;
      }
    }

    targetSize.width += padding * pxRatio;
    targetSize.height += padding * pxRatio;
    const offset = {
      x: targetSize.width / 2,
      y: targetSize.height / 2
    };
    const nw = Mercator.pointToCoord(center.x - offset.x, center.y - offset.y, zoom);
    const se = Mercator.pointToCoord(center.x + offset.x, center.y + offset.y, zoom); // console.log('ADJ PX BOUNDS', 'CENTER', center, 'OFFSET', offset, 'TARGET SIZE', targetSize);
    // console.log('PX CALC', `${se.lat},${nw.lon},${nw.lat},${se.lon}`);

    return {
      north: toFixed(nw.lat),
      south: toFixed(se.lat),
      west: toFixed(nw.lon),
      east: toFixed(se.lon)
    };
  };
  /**
   * Returns the map tile coordinate that contains the given geographical coordinate based on a
   * specific zoom level.
   *
   * @param {Coordinate} coord
   * @param {number} zoom
   * @returns {Point}
   */


  Mercator.coordToTile = (coord, zoom) => {
    const pi = Math.PI;
    const lon = coord.lon;

    const lat = _radians(coord.lat);

    const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
    const y = Math.floor((1 - Math.log(Math.tan(lat) + 1 / Math.cos(lat)) / pi) / 2 * Math.pow(2, zoom));
    return {
      x,
      y
    };
  };
  /**
   * Returns the geographical coordinate for the top-left corner of the given map tile
   * coordinate based on a specific zoom level.
   *
   * @param {Point} tile
   * @param {number} zoom
   * @returns {Coordinate}
   */


  Mercator.tileToCoord = (tile, zoom) => {
    const n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, zoom);
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    const lon = tile.x / Math.pow(2, zoom) * 360 - 180;
    return {
      lat,
      lon
    };
  };
})(Mercator || (exports.Mercator = Mercator = {}));

/***/ }),
/* 326 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _StyledLegend = _interopRequireDefault(__webpack_require__(323));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A grouped legend is an object that is responsible for displaying and managing multiple related
 * legends within a single view along with title labels for each as required.
 *
 * @export
 * @class GroupedLegend
 * @implements {LegendRenderable}
 */
class GroupedLegend extends _EventDispatcher.default {
  /**
   * Initializes and returns a grouped legend instance for the specified key and configuration
   * options.
   *
   * @param {string} key
   * @param {GroupedLegendOptions} opts
   * @memberof GroupedLegend
   */
  constructor(key, opts) {
    super();
    this._loaded = [];
    this._key = key;
    this._opts = (0, _utils.extend)({
      types: null
    }, opts);
    this._target = (0, _DOM.default)(`<div class="awxjs__legend awxjs__legend-group awxjs__legend-${key}"></div>`);
    this._legends = {};

    if (this._opts.types) {
      this.trigger('load:start');
      Object.keys(this._opts.types).forEach(type => {
        const config = (0, _utils.extend)({}, opts, (0, _utils.cloneDeep)(this._opts.types[type]));
        delete config.types;

        if (!(0, _utils.isEmpty)(config.use)) {
          type = config.use;
        }

        const legend = new _StyledLegend.default(type, config);
        legend.on('load:done', () => {
          this._loaded.push(type);

          this._checkLoaded();
        });
        this._legends[type] = legend;
        this.$el.append(legend.$el);
      });
    }
  }
  /**
   * Key associated with the legend.
   *
   * @readonly
   * @type {string}
   * @memberof GroupedLegend
   */


  get key() {
    return this._key;
  }
  /**
   * Configuration options.
   *
   * @readonly
   * @type {GroupedLegendOptions}
   * @memberof GroupedLegend
   */


  get opts() {
    return this._opts;
  }
  /**
   * DOM element for the legend.
   *
   * @readonly
   * @type {*}
   * @memberof GroupedLegend
   */


  get $el() {
    return this._target;
  }
  /**
   * Shows the legend DOM element.
   *
   * @memberof GroupedLegend
   */


  show() {
    this.$el.show();
  }
  /**
   * Hides the legend DOM element.
   *
   * @memberof GroupedLegend
   */


  hide() {
    this.$el.hide();
  }
  /**
   * Sets the size of the legend.
   *
   * @param {Size} size
   * @memberof GroupedLegend
   */


  setSize(size) {
    Object.keys(this._legends).forEach(key => {
      const opts = this.opts.types[key];
      const legend = this._legends[key];
      legend.setSize({
        width: size.width * opts.factor,
        height: size.height
      });
    });
  }

  getSize() {
    const container = this.$el.bounds();
    let width = 0;
    let height = container.height;
    Object.keys(this._legends).forEach(key => {
      const legend = this._legends[key];

      if (legend.$el) {
        const bounds = legend.$el.bounds();
        width += bounds.width;
        height = Math.max(height, bounds.height);
      }
    });
    return {
      width,
      height
    };
  }
  /**
   * Sets whether to display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof GroupedLegend
   */


  setMetric(metric) {
    Object.keys(this._legends).forEach(key => {
      const legend = this._legends[key];
      legend.setMetric(metric);
    });
  }
  /**
   * Resets the legend by removing all existing images.
   *
   * @memberof GroupedLegend
   */


  reset() {
    this.$el.empty();
    this._legends = null;
    this._loaded = [];
  }
  /**
   * Forces the legend to update if needed.
   *
   * @param {*} [opts]
   * @memberof GroupedLegend
   */


  update(opts, force = false) {
    this.trigger('load:start');
    Object.keys(this._legends).forEach(key => {
      this._legends[key].update(null, force);
    });
  }

  _checkLoaded() {
    if (this._loaded.length === Object.keys(this._opts.types).length) {
      this.trigger('load:done');
      setTimeout(() => {
        const size = this.getSize();
        this.$el.css('width', `${size.width}px`);
        this.trigger('resize', size);
      }, 150);
    }
  }

}

var _default = GroupedLegend;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 327 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Collection = _interopRequireDefault(__webpack_require__(305));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LegendStore extends _Collection.default {
  constructor() {
    super(...arguments);
    this._mapping = new Map();
    this._refs = new Map();
  }

  get mapping() {
    return this._mapping;
  }

  get refs() {
    return this._refs;
  }

  add(key, item) {
    const existing = this.get(key);

    if (!existing) {
      super.add(key, item);
    }

    this.increment(key);
  }

  has(key) {
    return (0, _utils.isset)(this.get(key));
  }

  remove(key, clear = false) {
    const existing = this.get(key);

    if (existing) {
      if (clear) {
        super.remove(key);
        this.mapping.delete(key);
        this.refs.delete(key);
      } else {
        this.decrement(key);
        const count = this.refCount(key);

        if (count === 0) {
          super.remove(key);
        }
      }
    }
  }

  map(key, mapping) {
    const existing = this.mapping.get(key) || [];

    this._mapping.set(key, [...existing, mapping]);
  }

  increment(key) {
    const val = this.refCount(key);
    this.refs.set(key, val + 1);
  }

  decrement(key) {
    const val = this.refCount(key);

    if (val > 0) {
      this.refs.set(key, val - 1);
    }
  }

  refCount(key) {
    return this.refs.get(key) || 0;
  }

}

var _default = LegendStore;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 328 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Apps = void 0;

var _InteractiveMapApp2 = _interopRequireDefault(__webpack_require__(329));

var _ButtonPanel = _interopRequireDefault(__webpack_require__(330));

var _InfoPanel2 = _interopRequireDefault(__webpack_require__(346));

var _TimelinePanel2 = _interopRequireDefault(__webpack_require__(352));

var _LegendPanel2 = _interopRequireDefault(__webpack_require__(358));

var _PlaceSearchPanel2 = _interopRequireDefault(__webpack_require__(360));

var _Tooltip = _interopRequireDefault(__webpack_require__(336));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 * Private class extension to better handle naming conflicts within this public interface.
 *
 * @class _InteractiveMapApp
 * @extends {Map}
 */
class _InteractiveMapApp extends _InteractiveMapApp2.default {}

class _LayersPanel extends _ButtonPanel.default {}

class _InfoPanel extends _InfoPanel2.default {}

class _TimelinePanel extends _TimelinePanel2.default {}

class _LegendPanel extends _LegendPanel2.default {}

class _PlaceSearchPanel extends _PlaceSearchPanel2.default {}
/**
 * @ignore
 */


let _account;
/**
 * @ignore
 */


let _servers;
/**
 * The `Apps` module provides the public interface for all application components that are part
 * of the SDK.
 */


var Apps;
exports.Apps = Apps;

(function (Apps) {
  // /**
  //  * Provides access to the `Apps` module's utility functions.
  //  *
  //  * @readonly
  //  * @type { [key: string]: Function }
  //  */
  // export const utils: any = {...mapUtils};

  /**
   * Sets the Aeris account instance to use with the `Views` module.
   *
   * @param {Account} account
   */
  Apps.setAccount = account => {
    _account = account;
  };
  /**
   * Sets the base paths for the API servers to use with data and image requests.
   *
   * @param {Servers} servers
   */


  Apps.setServers = servers => {
    _servers = servers;
  };
  /**
   * Initializes and returns a new `InteractiveMapApp` instance.
   *
   * @param {*} target
   * @param {InteractiveMapAppOptions} [opts]
   * @param {(map: Map) => void} [onInit]
   * @returns {InteractiveMap}
   */


  Apps.InteractiveMapApp = function (target, opts) {
    return new _InteractiveMapApp(target, Object.assign({}, opts, {
      account: _account,
      servers: opts.servers || _servers
    }));
  };

  Apps.panels = {
    LayersPanel: function (opts) {
      return new _LayersPanel(opts);
    },
    InfoPanel: function (opts) {
      return new _InfoPanel(opts);
    },
    TimelinePanel: function (timeline, opts) {
      return new _TimelinePanel(timeline, opts);
    },
    LegendPanel: function (opts) {
      return new _LegendPanel(opts);
    },
    PlaceSearchPanel: function (opts) {
      return new _PlaceSearchPanel(opts);
    }
  };
  Apps.ui = {
    Tooltip: function (content, opts) {
      return new _Tooltip.default(content, opts);
    }
  };
})(Apps || (exports.Apps = Apps = {}));

/***/ }),
/* 329 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _InteractiveMap = _interopRequireDefault(__webpack_require__(220));

var _ButtonPanel = _interopRequireDefault(__webpack_require__(330));

var _InfoPanel = _interopRequireDefault(__webpack_require__(346));

var _TimelinePanel = _interopRequireDefault(__webpack_require__(352));

var _LegendPanel = _interopRequireDefault(__webpack_require__(358));

var _PlaceSearchPanel = _interopRequireDefault(__webpack_require__(360));

var _ModuleManager = _interopRequireDefault(__webpack_require__(362));

var _CoordinateBounds = __webpack_require__(198);

var _layout = __webpack_require__(208);

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _DataSourceManager = _interopRequireDefault(__webpack_require__(363));

var _utils = __webpack_require__(359);

var _utils2 = __webpack_require__(17);

var _defaults = __webpack_require__(364);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `InteractiveMapApp` object provides an full-featured weather map application that manages an
 * interactive map and enables runtime interaction of map content using a series of panel
 * view components.
 *
 * @export
 * @class InteractiveMapApp
 * @extends {EventDispatcher}
 */
class InteractiveMapApp extends _EventDispatcher.default {
  /**
   * Initializes an interactive map application with the specified DOM target and configuration
   * object.
   *
   * @param {HTMLElement} target
   * @param {InteractiveMapAppOptions} [opts]
   * @memberof InteractiveMapApp
   */
  constructor(target, opts) {
    super();
    this._ready = false;
    this._layoutCache = {};
    this._layout = (0, _utils2.debounce)((sizeOnly = false) => {
      if (!sizeOnly) {
        Object.keys(this._panels).forEach(key => {
          const panel = this._panels[key];

          if (panel) {
            const pos = (0, _utils2.get)(this._opts, `panels.${key}.position`);

            if (pos && (0, _utils2.isPlainObject)(pos)) {
              if (key !== 'info') {
                panel.layout();
              }

              if (pos.pin) {
                panel.pinTo(pos.pin, pos.translate);
              } else if ((0, _utils2.isset)(pos.x) && (0, _utils2.isset)(pos.y)) {
                panel.moveTo(pos);
              }
            }
          }
        });
      }

      const layersPanel = this.panels.layers;
      const timelinePanel = this.panels.timeline;
      const legendsPanel = this.panels.legends; // calculate initial allowable area relative to parent

      const parent = this.$el.bounds(true);
      const allowed = {
        top: 0,
        left: 0,
        right: parent.right,
        bottom: parent.height,
        width: parent.width,
        height: parent.height
      };
      let region = Object.assign({}, allowed);

      if (timelinePanel) {
        const panel = timelinePanel;
        const size = panel.size();
        const inset = 10;
        const {
          pin
        } = (0, _utils2.get)(this._opts, `panels.timeline.position`) || {};

        if ((0, _layout.isCenterPinned)(pin)) {
          region = (0, _layout.insetBounds)(allowed, inset);
          const css = {};

          if (size.width >= region.width) {
            // css.width = `${region.width}px`;
            css.left = `${inset}px`; // panel.setSize(region.width, 0);
          } else {
            css.left = `${Math.floor((parent.width - size.width) / 2)}px`;
          } // panel.$el.css(css);


          this._layoutCache.timeline = css;
        }
      } // set max-height on layers panel


      if (layersPanel) {
        const panel = layersPanel;
        const contentSize = panel.contentSize();
        const bounds = panel.bounds(true, this.$el); // const contentHeight = (size.height < bounds.height) ? size.height : Math.max(size.height, bounds.height);

        let margin = bounds.top;
        region = Object.assign({}, allowed);
        const {
          pin: layersAnchor,
          translate
        } = (0, _utils2.get)(this._opts, 'panels.layers.position') || {};

        if ((0, _layout.isMiddlePinned)(layersAnchor)) {
          region.top = Math.max(0, Math.round((parent.height - bounds.height) / 2));
          region.bottom = Math.min(parent.height, region.top + region.height);
          margin = translate.y; // } else if (isBottomPinned(layersAnchor)) {

          margin = Math.abs(translate.y);
        }

        region = (0, _layout.boundsAdjustedForAnchor)(region, {
          width: bounds.width,
          height: bounds.height
        }, layersAnchor); // reference bounds for intersection checks with other panels

        const marginBounds = (0, _layout.insetBounds)(region, 10); // ensure layers panel doesn't overlap legend or timeline panels

        if (legendsPanel) {
          const {
            pin
          } = (0, _utils2.get)(this._opts, 'panels.legends.position') || {};
          const b = legendsPanel.bounds(true, this.$el);

          if ((0, _layout.intersects)(marginBounds, b, false)) {
            if ((0, _layout.isBottomPinned)(pin)) {
              region.bottom = b.top;
            } else if ((0, _layout.isTopPinned)(pin)) {
              region.top = b.bottom;
            }
          }
        }

        if (timelinePanel) {
          const {
            pin
          } = (0, _utils2.get)(this._opts, 'panels.timeline.position') || {};
          const b = timelinePanel.bounds(true, this.$el);

          if ((0, _layout.intersects)(marginBounds, b, false)) {
            if ((0, _layout.isBottomPinned)(pin)) {
              region.bottom = b.top;
            } else if ((0, _layout.isTopPinned)(pin)) {
              region.top = b.bottom;
            }
          }
        }

        region = (0, _layout.insetBounds)(region, margin);
        let maxh = Math.max(region.bottom - region.top, 0);

        if (maxh === 0) {
          maxh = allowed.bottom - allowed.top;
        }

        maxh = Math.min(maxh, region.height) - layersPanel.toolbar.outerHeight(); // console.log(bounds, allowed, `maxh=${maxh}`, 'contentSize', contentSize, margin, region);
        // const height = contentHeight > maxh ? `${Math.min(maxh, contentHeight)}px` : `${contentHeight}px`;

        const scrollbar = (0, _utils.scrollBarWidth)();
        const css = {
          'top': `${region.top}px`,
          'height': `${contentSize.height}px`,
          'max-height': `${maxh}px`,
          'width': `${contentSize.width + scrollbar}px`
        }; // panel.$el.css(css);

        panel.setMaxContentSize({
          height: maxh,
          width: contentSize.width + scrollbar
        });
        panel.content.css({
          'padding-right': `${scrollbar}px`
        });
        this._layoutCache.layers = css;
      }
    }, 50);

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for InteractiveMapApp');
    }

    const vp = (0, _layout.viewportSizeClass)();
    opts = (0, _utils2.extend)((0, _defaults.getMapAppDefaults)(vp), {
      map: {
        account: opts.account,
        servers: opts.servers
      },
      panels: {
        search: {
          account: opts.account
        }
      }
    }, opts);
    this._opts = opts;
    this._account = opts.account;

    if (!this.account) {
      throw new Error('An InteractiveMapApp must be configured with a valid `account` value.');
    }

    const classNames = `awxjs__mode-${this._opts.mode || 'light'}`;
    (0, _DOM.default)(target).html(`
			<div class="awxjs__app__component awxjs__app__fullscreen ${classNames}">
				<div class="awxjs__app__map"></div>
			</div>
		`);
    this._target = (0, _DOM.default)('.awxjs__app__component', (0, _DOM.default)(target)); // panel and source cache

    this._panels = {
      layers: null,
      info: null,
      timeline: null,
      legends: null,
      search: null
    };
    this._modules = new _ModuleManager.default(this); // interface panels

    const {
      layers: layersPanel,
      info: infoPanel,
      timeline: timelinePanel,
      search: searchPanel,
      legends: legendsPanel
    } = opts.panels;
    const mapOpts = (0, _utils2.cloneDeep)(opts.map); // update opts.map.layers values by using the layer value associated with the matching
    // layer id from the layers panel buttons

    if (mapOpts && layersPanel) {
      let initialLayers = (0, _utils2.get)(opts, 'map.layers');

      if (initialLayers) {
        if ((0, _utils2.isString)(initialLayers)) {
          initialLayers = initialLayers.replace(/\s/g, '').split(',');
        }

        const buttons = layersPanel.buttons || [];
        const result = buttons.reduce((ar, item) => {
          if ((0, _utils2.isset)(item.buttons) === false) {
            const value = item.value || item.id; // if button config has segments and is not a filter, iterate through the
            // segments to find a layer value that exists in the initial layers array

            const segments = item.segments;

            if (segments && (0, _utils2.isArray)(segments) && !item.filter) {
              segments.forEach(o => {
                const layer = o.value.replace(/\:.+$/, '');
                (0, _utils2.replace)(ar, layer, o.value);
              });
            } else {
              (0, _utils2.replace)(ar, item.value, value);
              (0, _utils2.replace)(ar, item.id, value);
            }
          }

          return ar;
        }, (0, _utils2.cloneDeep)(initialLayers));
        (0, _utils2.set)(opts, 'map.layers', result);
        (0, _utils2.set)(mapOpts, 'layers', null);
      }
    }

    this._map = new _InteractiveMap.default((0, _DOM.default)('.awxjs__app__map', this._target), mapOpts); // setup interface panels

    if (layersPanel && layersPanel.enabled !== false) {
      this._setupLayersPanel(layersPanel);
    }

    if (infoPanel && infoPanel.enabled !== false) {
      this._setupInfoPanel(infoPanel);
    }

    if (timelinePanel && timelinePanel.enabled !== false) {
      this._setupTimeline(timelinePanel);
    }

    if (searchPanel && searchPanel.enabled !== false) {
      this._setupSearchPanel(searchPanel);
    }

    if (legendsPanel && legendsPanel.enabled !== false) {
      this._setupLegendsPanel(legendsPanel);
    }

    const manager = new _DataSourceManager.default(this.map, this.panels.layers);
    manager.on("select"
    /* SELECT */
    , e => {
      this.trigger("layer:select"
      /* LAYER_SELECT */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      }));
    }).on("deselect"
    /* DESELECT */
    , e => {
      this.trigger("layer:deselect"
      /* LAYER_DESELECT */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      }));
    }).on("change"
    /* CHANGE */
    , e => {
      this.trigger("layer:change"
      /* LAYER_CHANGE */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      })); // }).on(DataSourceManagerEvent.OPTION_CHANGE, (e: any) => {
      // 	this.trigger(InteractiveMapAppEvent.LAYER_OPTION_CHANGE, e.data);
    }).on("change:control"
    /* CONTROL_CHANGE */
    , e => {
      this.trigger("layer:change:control"
      /* LAYER_CONTROL_CHANGE */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      }));
    });
    this._sourceManager = manager;

    this._map.on('change:units', e => {
      this.trigger("change:units"
      /* CHANGE_UNITS */
      , e.data);
    });

    this._map.on('ready', () => {
      this._ready = true;
      this.trigger("ready"
      /* READY */
      );
    });

    (0, _DOM.default)(window).on('resize', () => {
      this._layout();
    });

    this._layout();

    setTimeout(() => this._layout(), 200);
  }
  /**
   * The Aeris account to use when requesting data for the map.
   *
   * @readonly
   * @type {Account}
   * @memberof InteractiveMapApp
   */


  get account() {
    return this._account;
  }
  /**
   * Primary DOM element associated with the view.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $el() {
    return this._target;
  }

  get options() {
    return Object.assign({}, this._opts);
  }
  /**
   * Returns the underlying interactive map instance.
   *
   * @readonly
   * @type {InteractiveMap}
   * @memberof InteractiveMapApp
   */


  get map() {
    return this._map;
  }
  /**
   * Returns the panel component instances for the application keyed by their type.
   *
   * @readonly
   * @type {{ layers: ButtonPanel, info: InfoPanel }}
   * @memberof InteractiveMapApp
   */


  get panels() {
    return this._panels;
  }
  /**
   * Returns the set of custom data sources for the application.
   *
   * @readonly
   * @type {{ [key: string]: any }}
   * @memberof InteractiveMapApp
   */


  get sources() {
    return this._sourceManager.sources;
  }

  get modules() {
    return this._modules;
  }
  /**
   * Adds a map content source to the application cache that can be toggled on and off using the
   * unique key identifier. Note that this method does not render the source to the interactive
   * map.
   *
   * @param {string} key Identifier for the source
   * @param {string} type Type of map content source to use, `tile`, `vector`, `geojson` or `text`
   * @param {*} config Configuration options for the source
   * @returns {*}
   * @memberof InteractiveMapApp
   */


  addSource(key, type, config) {
    const source = this.map.createSource(key, type, config);

    if (source) {
      source.strategy = this.map.strategy;

      this._sourceManager.addSource(key, source);
    } else {
      console.warn(`[Aeris] Unable to add data source to InteractiveMapApp for key {${key}}, type {${type}} is invalid.
				Data sources must be of type 'tile', 'vector', 'geojson' or 'text'. See
				https://www.aerisweather.com/support/docs/toolkits/aeris-js-sdk/map-modules/data-sources/ for more info.`);
      return null;
    } // determine if source should be selected/active initially


    const initLayers = this.initialLayers();

    if ((0, _utils2.isArray)(initLayers)) {
      if (initLayers.indexOf(key) !== -1) {
        const layersPanel = this.panels.layers;

        if (layersPanel) {
          layersPanel.select([key]);
        } else {
          this.map.addSource(source, {
            id: key
          });
        }
      }
    }

    return source;
  }

  getSource(id) {
    return this._sourceManager.findSource(id);
  }
  /**
   * Shows the application info panel component using the specified view key, title and data.
   *
   * @param {string} view Identifier associated with the view to render
   * @param {string} [title] Title to display in the info panel (optional)
   * @param {*} [data] Data to use when rendering the view in the panel (optional)
   * @returns {InfoPanel}
   * @memberof InteractiveMapApp
   */


  showInfo(view, title, data) {
    const panel = this.panels.info;

    if (panel) {
      panel.showContent(view, title, data);
    }

    return panel;
  }
  /**
   * Shows the application info panel component for the specified geographical coordinate. Data
   * will be requested for the coordinate using the view's request instance
   *
   * @param {Coordinate} coord Coordinate to request data for
   * @param {string} view Identifier associated with the view to render
   * @param {string} [title] Title to display in the info panel (optional)
   * @param {MarkerStyle} [marker] Marker style to use when placing the marker on the map at the
   * coordinate (optional)
   * @returns {InfoPanel}
   * @memberof InteractiveMapApp
   */


  showInfoAtCoord(coord, view, title, marker) {
    const panel = this.panels.info;

    if (!coord) {
      return panel;
    }

    if (!marker) {
      marker = (0, _utils2.get)(this._opts, 'panels.info.marker');
    }

    const {
      lat,
      lon
    } = (0, _CoordinateBounds.normalize)(coord);

    if (panel && (0, _utils2.isset)(lat) && (0, _utils2.isset)(lon)) {
      panel.showContent(view, title).load({
        p: `${lat},${lon}`
      });

      if (this._infoPanelMarker) {
        this.map.strategy.removeMarker(this._infoPanelMarker);
      }

      if (marker) {
        this._infoPanelMarker = this.map.strategy.factory.marker('info', coord, marker);

        if (this._infoPanelMarker) {
          this.map.strategy.addMarker(this._infoPanelMarker);
        }
      }
    }

    return panel;
  }
  /**
   * Dismisses the application info panel if currently visible.
   *
   * @memberof InteractiveMapApp
   */


  closeInfoPanel() {
    const panel = this.panels.info;
    panel.close();
  }
  /**
   * Returns the panel view associated with the specified key, if any.
   *
   * @param {string} key
   * @returns {*}
   * @memberof InteractiveMapApp
   * @see panels
   */


  getPanel(key) {
    const panel = this._panels[key];

    if (panel) {
      return panel;
    }

    return null;
  }
  /**
   * Updates the configuration for the panel view associated with the specified key, if any.
   *
   * The new options provided will be applied to the existing options for the panel, meaning new values will
   * override the existing option values while other existing values will remain.
   *
   * @param {string} key
   * @param {*} config
   * @memberof InteractiveMapApp
   */


  updatePanel(key, config) {
    const existing = this.getPanel(key);

    if (existing) {
      config = Object.assign(Object.assign({}, existing.opts), config);
      existing.remove(true);

      if (key === 'layers') {
        // need to remove all sources since the new layers may not contain those that are
        // currently active on the map
        this.map.removeAllSources();
      }
    } // update panel config on stored opts


    (0, _utils2.set)(this._opts, `panels.${key}`, config); // don't create panel if disabled

    if (config.enabled === false) {
      return;
    }

    switch (key) {
      case 'layers':
        this._setupLayersPanel(config);

        break;

      case 'timeline':
        this._setupTimeline(config);

        break;

      case 'legends':
        this._setupLegendsPanel(config);

        break;

      case 'search':
        this._setupSearchPanel(config);

        break;

      case 'info':
        this._setupInfoPanel(config);

        break;

      default:
    }

    this._layout();
  }
  /**
   * Sets the units to display on the underlying interactive map.
   *
   * @param {boolean} isMetric
   * @memberof InteractiveMapApp
   */


  setMetric(isMetric) {
    this.map.setMetric(isMetric);
  }

  setMode(mode) {
    this._opts.mode = mode;

    this._target.removeClass('awxjs__mode-light awxjs__mode-dark');

    this._target.addClass(`awxjs__mode-${this._opts.mode}`);
  }
  /**
   * Returns whether the application has finished initializing.
   *
   * @returns {boolean}
   * @memberof InteractiveMapApp
   */


  isReady() {
    return this._ready;
  }

  initialLayers() {
    var _a, _b;

    const initLayers = ((_b = (_a = this._opts) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.layers) || [];
    let layers;

    if ((0, _utils2.isString)(initLayers)) {
      layers = initLayers.replace(/,\s+/, ',').split(',');
    } else {
      layers = initLayers;
    }

    return layers;
  }

  _setupLayersPanel(config) {
    const isInitialSetup = typeof this._panels.layers === 'undefined' || this._panels.layers === null;

    if (this._panels.layers) {
      this._panels.layers.offAll();
    }

    const panel = new _ButtonPanel.default((0, _utils2.extend)({}, config, {
      id: 'layers'
    }));
    panel.addTo(this.$el);
    panel.on('button:add button:remove change:size', () => {
      let vpos = panel.$el.css('top');
      if (vpos.length === 0) vpos = panel.$el.css('bottom');
      vpos = parseInt(vpos.replace(/[^\d]/, ''), 10);
      const sizeOnly = Number.isNaN(vpos) === false;

      this._layout(sizeOnly);
    }).on('show hide', () => {
      this._layout();
    });
    this._panels.layers = panel;

    if (this._sourceManager) {
      this._sourceManager.linkPanel(panel);
    }

    const setButtonLoadingState = (id, loading) => {
      if (id) {
        const btn = panel.buttonForId(id);

        if (btn) {
          btn.setLoading(loading);
        }
      }
    };

    if (isInitialSetup) {
      // listen for source loading events to show the loading state for that layer's button
      this.map.on('source:load:start', e => {
        setButtonLoadingState(e.data.layer, true);
      }).on('source:load:done', e => {
        setButtonLoadingState(e.data.layer, false);
      }).on('source:add', e => {
        this._sourceManager.handleSourceEvent('add', e.data.id);
      }).on('source:remove', e => {
        this._sourceManager.handleSourceEvent('remove', e.data.id);
      }); // select initial buttons based on map.layers value if defined

      let layers = (0, _utils2.get)(this._opts, 'map.layers');

      if (layers) {
        if ((0, _utils2.isString)(layers)) {
          layers = layers.replace(/\s/g, '').split(',');
        }

        this.map.on('ready', () => {
          panel.select(layers);
        });
      }
    }
  }

  _setupInfoPanel(config) {
    var _a, _b, _c;

    const panel = new _InfoPanel.default((0, _utils2.extend)({}, config, {
      id: 'info',
      account: this.account
    }));
    panel.addTo(this.$el);
    this._panels.info = panel;
    panel.on('close', () => {
      if (this._infoPanelMarker) {
        this.map.strategy.removeMarker(this._infoPanelMarker);
        this._infoPanelMarker = null;
      }
    }).on('show hide', () => {
      this._layout();
    });
    this.on('change:units', e => {
      const isMetric = e.data.metric || false;
      panel.setMetric(isMetric);
    }); // add default panel content views

    const localWeatherConfig = ((_c = (_b = (_a = this._opts.panels) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.views) === null || _c === void 0 ? void 0 : _c.localweather) || {
      views: [{
        renderer: 'place'
      }, {
        renderer: 'units'
      }, {
        title: 'Active Threats',
        renderer: 'threats'
      }, {
        title: 'Active Alerts',
        renderer: 'alerts'
      }, {
        title: 'Impacts',
        renderer: 'hazards'
      }, {
        title: 'Observations',
        renderer: 'obs'
      }, {
        title: 'Outlook',
        renderer: 'outlook'
      }, {
        title: 'Short-Term Forecast',
        renderer: 'forecast'
      }]
    };
    this.panels.info.setContentView('localweather', localWeatherConfig);
  }

  _setupTimeline(config) {
    const initRange = (0, _utils2.get)(config, 'range.value');
    const initTimelineFrom = (0, _utils2.get)(this._opts, 'map.timeline.from');
    const initTimelineTo = (0, _utils2.get)(this._opts, 'map.timeline.to'); // if the slider's `range.value` is defined and the map.timeline from/to are not, then
    // update the map's initial timeline range to the value of `range.value`

    if (initRange && !(0, _utils2.isset)(initTimelineFrom) && !(0, _utils2.isset)(initTimelineTo)) {
      const [from, to] = initRange;

      if ((0, _utils2.isNumber)(from)) {
        this.map.timeline.setStartOffset(from * 3600 * 1000);
      }

      if ((0, _utils2.isNumber)(to)) {
        this.map.timeline.setEndOffset(to * 3600 * 1000);
      }
    } else {
      // update initial slider `range.value` based on underlying map's timeline range
      (0, _utils2.set)(config, 'range.value', [this.map.timeline.startOffset() / 3600 / 1000, this.map.timeline.endOffset() / 3600 / 1000]);
    }

    const panel = new _TimelinePanel.default(this.map.timeline, (0, _utils2.extend)({}, config, {
      id: 'timeline'
    }));
    panel.on('change:range', () => {
      const time = this.map.timeline.currentTime;
      this.map.timeline.goToTime(time);
    }).on('show hide', () => {
      this._layout();
    });
    panel.addTo(this.$el);
    this._panels.timeline = panel;
  }

  _setupSearchPanel(config) {
    const panel = new _PlaceSearchPanel.default((0, _utils2.extend)({}, config, {
      id: 'search'
    }));
    panel.addTo(this.$el);
    this._panels.search = panel;
    panel.on('select', e => {
      const loc = (0, _utils2.get)(e.data, 'result.loc');

      if (loc) {
        const {
          lat,
          long: lon
        } = loc;
        const coord = {
          lat,
          lon
        };
        this.map.setView(coord, 8);
        this.showInfoAtCoord(coord, 'localweather', 'Local Weather');
      }
    });
  }

  _setupLegendsPanel(config) {
    const panel = new _LegendPanel.default((0, _utils2.extend)({}, config, {
      id: 'legends',
      legend: {
        metric: this.map.isMetric
      }
    }));
    panel.addTo(this.$el); // panel.on('show hide', () => {
    // 	this._layout();
    // });

    this._panels.legends = panel;
    this.map.on('layer:add', e => {
      if (!(0, _utils2.isset)(e.data)) return;
      const {
        layer,
        id
      } = e.data;
      const keys = layer || id;

      if (keys) {
        // remove group prefixes and split into multiple keys if multiple layers
        // combined in the key string
        const layers = keys.toLowerCase().replace(/^[^\:]+\:\:/, '').replace(/\:[^,]+/g, '').replace(/__/, ',').split(',');
        layers.forEach(_layer => {
          panel.legend.add(_layer, {
            account: this.account,
            within: {
              bounds: this.map.getBounds()
            }
          });
        });
      }
    }).on('layer:remove source:remove', e => {
      if (!(0, _utils2.isset)(e.data)) return;
      const {
        layer,
        id
      } = e.data;
      const keys = layer || id;

      if (keys) {
        // remove group prefixes and split into multiple keys if multiple layers
        // combined in the key string
        const layers = keys.toLowerCase().replace(/^[^\:]+\:\:/, '').replace(/\:[^,]+/g, '').replace(/__/, ',').split(',');
        layers.forEach(_layer => {
          panel.legend.remove(_layer);
        });
      }
    }).on('change:bounds', e => {
      const opts = {
        account: this.account
      }; // if active layers contains `alerts`, we need to pass the maps current bounds, size and zoom to be used
      // to request a filtered version of the advisories legend just for the map region

      opts.within = {
        bounds: this.map.getBounds()
      };
      panel.legend.update(opts);
    });
    this.on("change:units"
    /* CHANGE_UNITS */
    , e => {
      panel.legend.setMetric(e.data.metric);
    });
  }

}

var _default = InteractiveMapApp;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 330 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Panel = _interopRequireDefault(__webpack_require__(331));

var _Button = _interopRequireDefault(__webpack_require__(334));

var _SegmentedButton = _interopRequireDefault(__webpack_require__(342));

var _ButtonGroup = _interopRequireDefault(__webpack_require__(345));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getOpacityValue = (style = {}) => {
  let result = 1;

  if ((0, _utils.isset)(style.opacity)) {
    result = style.opacity;
  } else {
    ['polyline', 'polygon'].forEach(type => {
      const itemStyle = style[type];
      const styleRef = (0, _utils.isFunction)(itemStyle) ? itemStyle({}) : itemStyle;

      if (styleRef) {
        if (styleRef.fill) {
          result = styleRef.fill.opacity;
        } else if (styleRef.stroke) {
          result = styleRef.stroke.opacity;
        }
      }
    });
  }

  return result;
};

const createButton = config => {
  const opts = config;
  const btnType = opts.type;
  let result; // update any button controls based on other options associated with the button

  const controls = opts.controls;

  if (controls) {
    const settings = controls.settings;

    if ((0, _utils.isArray)(settings)) {
      (0, _utils.set)(opts, 'controls.settings', settings.map(setting => {
        var _a;

        const {
          type
        } = setting;

        if (type === 'opacity') {
          const opacity = getOpacityValue((_a = opts.options) === null || _a === void 0 ? void 0 : _a.style);

          if ((0, _utils.isset)(opacity)) {
            setting.options = Object.assign(Object.assign({}, setting.options), {
              value: [opacity * 100]
            });
          }
        }

        return setting;
      }));
    }
  }

  if (opts.buttons) {
    result = new _ButtonGroup.default(opts);
  } else if (opts.segments || opts.groups) {
    result = new _SegmentedButton.default(opts);
  } else {
    result = new _Button.default(opts);
  }

  return result;
};
/**
 * A panel that renders and manages a series of button elements to be used for toggling data on
 * and off at runtime.
 *
 * @export
 * @class ButtonPanelView
 * @extends {Panel<ButtonPanelViewOptions, PanelState>}
 */


class ButtonPanelView extends _Panel.default {
  /**
   * Initializes and returns a button panel instance for the specified configuration options.
   *
   * @param {ButtonPanelViewOptions} [opts]
   * @memberof ButtonPanel
   */
  constructor(opts) {
    super((0, _utils.extend)({
      icon: `
				<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 80.5">
					<g>
						<path d="M98.5,51.3l-13.7-7.3L58,58.2c-2.5,1.3-5.2,2-8,2c-2.8,0-5.5-0.7-8-2L15.2,44.1L1.5,51.3C0.6,51.8,0,52.8,0,53.8
							s0.6,2,1.5,2.5l43.5,23c3.2,1.7,6.9,1.7,10.1,0l43.5-23c0.9-0.5,1.5-1.4,1.5-2.5S99.4,51.8,98.5,51.3L98.5,51.3z"/>
						<path d="M1.5,29.2l43.5,23c1.6,0.8,3.3,1.2,5,1.2c1.7,0,3.5-0.4,5-1.3l43.5-23c0.9-0.5,1.5-1.4,1.5-2.5c0-1-0.6-2-1.5-2.5L55,1.3
							C53.5,0.4,51.7,0,50,0c-1.7,0-3.4,0.4-5,1.3l-43.5,23C0.6,24.7,0,25.7,0,26.7C0,27.8,0.6,28.7,1.5,29.2L1.5,29.2z"/>
					</g>
				</svg>
			`
    }, opts));
  }
  /**
   * Panel button elements.
   *
   * @readonly
   * @type {Toggleable[]}
   * @memberof ButtonPanelView
   */


  get buttons() {
    return [...(this._buttons || [])];
  }

  buttonForId(id) {
    let result;
    this.buttons.forEach((button, index) => {
      if (!(0, _utils.isset)(result)) {
        if (button instanceof _ButtonGroup.default) {
          result = button.buttonForId(id);
        } else if (button.id === id && !(0, _utils.isset)(result)) {
          result = button;
        }
      }
    });
    return result;
  }

  buttonForKey(key) {
    let result;
    this.buttons.forEach((button, index) => {
      if (!(0, _utils.isset)(result)) {
        if (button instanceof _ButtonGroup.default) {
          result = button.buttonForKey(key);
        } else if (button.key === key && !(0, _utils.isset)(result)) {
          result = button;
        }
      }
    });
    return result;
  }
  /**
   * Adds a new button to the end of the set using the provided button configuration.
   *
   * @param {(SegmentedButtonOptions | ButtonOptions | ButtonGroupOptions)} config Button configuration
   * @param {boolean} [events=true] A Boolean indicating whether to automatically add the default
   * button events
   * @returns {Button<any, any>}
   * @memberof ButtonPanelView
   */


  add(config, events = true) {
    const index = this.buttons.length;
    return this.insertAt(index, config, events);
  }
  /**
   * Inserts a new button at a specific index in the set using the provided button configuration.
   *
   * @param {number} index Index to insert the button into
   * @param {(SegmentedButtonOptions | ButtonOptions | ButtonGroupOptions)} config Button configuration
   * @param {boolean} [events=true] A Boolean indicating whether to automatically add the default
   * button events
   * @returns
   * @memberof ButtonPanelView
   */


  insertAt(index, config, events = true) {
    if (!this._buttons) this._buttons = [];
    const button = createButton(config);

    if (index >= this._buttons.length) {
      this._buttons.push(button);

      index = -1;
    } else {
      index = Math.max(0, index);

      this._buttons.splice(index, 0, button);
    }

    this._appendButton(button, events, index);

    this.trigger("button:add"
    /* ADD_BUTTON */
    , {
      button
    });
    return button;
  }

  insertBefore(id, config, events = true) {
    const index = this._indexForId(id);

    if (index === 0) {
      return this.insertAt(0, config, events);
    }

    if (index > 0) {
      return this.insertAt(index - 1, config, events);
    }

    return this.add(config, events);
  }

  insertAfter(id, config, events = true) {
    const index = this._indexForId(id);

    if (index >= 0) {
      return this.insertAt(index + 1, config, events);
    }

    return this.add(config, events);
  }
  /**
   * Removes the button at the specified index.
   *
   * @param {number} index
   * @returns
   * @memberof ButtonPanelView
   */


  removeAt(index) {
    if (!(0, _utils.isset)(this._buttons) || index > this._buttons.length - 1 || index < 0) return;
    const button = this.buttons[index];

    if (button) {
      this._buttons.splice(index, 1);

      button.$el.remove();
      this.trigger("button:remove"
      /* REMOVE_BUTTON */
      , {
        button
      });
    }
  }
  /**
   * Removes the button for the specified identifier.
   *
   * @param {string} id
   * @memberof ButtonPanelView
   */


  removeForId(id) {
    let foundIndex = -1;
    this.buttons.forEach((button, index) => {
      if (button.id === id && foundIndex === -1) {
        foundIndex = index;
      }
    });

    if (foundIndex >= 0) {
      this.removeAt(foundIndex);
    }
  }
  /**
   * Select the buttons associated with the specified value or array of values.
   *
   * @param {(string | string[])} value
   * @memberof ButtonPanelView
   */


  select(value, checkIdOnly = false) {
    this.handleSelectionState(value, true, checkIdOnly);
  }
  /**
   * Deselects the buttons associated with the specified value or array of values.
   *
   * @param {(string | string[])} value
   * @memberof ButtonPanelView
   */


  deselect(value, checkIdOnly = false) {
    this.handleSelectionState(value, false, checkIdOnly);
  }

  set(id, value) {
    const button = this.buttonForId(id) || this.buttonForKey(id);

    if (button && button instanceof _SegmentedButton.default) {
      button.value = value;
    }
  }

  handleSelectionState(value, selected, checkIdOnly = false) {
    const _select = (button, _value) => {
      if (button instanceof _SegmentedButton.default) {
        const containsId = button.containsId(_value);
        const containsValue = button.containsValue(_value);

        if (checkIdOnly) {
          if (containsId) {
            button.selectSegment(_value);
          }
        } else if (containsId || containsValue) {
          button.selectSegment(_value);
        } else if (button.matches(_value)) {
          button.select();
        }
      } else if (button instanceof _Button.default) {
        if (button.matches(_value)) {
          button.select();
        }
      }
    };

    const _deselect = (button, _value) => {
      if (button instanceof _SegmentedButton.default) {
        const containsId = button.containsId(_value);
        const containsValue = button.containsValue(_value); // console.log('_deselect', _value, containsId, containsValue);

        if (button.matches(_value)) {
          button.deselect();
        } else if (checkIdOnly) {
          if (containsId) {
            button.deselectSegment(_value);
          }
        } else if (containsId || containsValue) {
          button.deselectSegment(_value);
        }
      } else if (button instanceof _Button.default) {
        if (button.matches(_value)) {
          button.deselect();
        }
      }
    };

    if ((0, _utils.isArray)(value)) {
      value.filter(v => !(0, _utils.isEmpty)(v)).forEach(v => this.handleSelectionState(v, selected));
    } else if (this.buttons) {
      this.buttons.forEach(button => {
        const val = value;

        if (button instanceof _ButtonGroup.default) {
          const group = button;
          group.buttons.forEach(btn => {
            if (selected) {
              _select(btn, val);
            } else {
              _deselect(btn, val);
            }
          });
        } else if (button instanceof _Button.default || button instanceof _SegmentedButton.default) {
          if (selected) {
            _select(button, val);
          } else {
            _deselect(button, val);
          }
        }
      });
    }
  } // /**
  //  * Returns the size required for the panel's content.
  //  *
  //  * @returns {Size}
  //  * @memberof Panel
  //  */
  // public contentSize(): Size {
  // 	const size = super.contentSize();
  // 	let height = 0;
  // 	if (this.ui.toolbar) {
  // 		height += this.ui.toolbar.outerHeight(true);
  // 	}
  // 	this.buttons.forEach((button) => {
  // 		if (button instanceof View) {
  // 			height += button.size().height;
  // 		}
  // 	});
  // 	// add container inner padding to height
  // 	const pad = this.ui.buttons.padding();
  // 	size.height = height + pad.top + pad.bottom;
  // 	return size;
  // }


  _onAddedToDOM() {
    this.ui.content.append('<div class="awxjs__app__ui-panel-buttons"></div>');
    this.ui.buttons = (0, _DOM.default)('.awxjs__app__ui-panel-buttons', this.$el);

    if (this.opts.buttons) {
      const results = [];
      const groups = [];
      this.opts.buttons.forEach(item => {
        const button = createButton(item);

        if (button instanceof _ButtonGroup.default) {
          groups.push(button);
        }

        results.push(button);
      });
      this._buttons = results;
    }

    this.buttons.forEach(button => {
      this._appendButton(button);
    });

    const updateVisibility = () => {
      if (this.buttons.length === 0) {
        this.hide();
      } else {
        this.show();
      }
    };

    this.on('button:add button:remove', () => {
      updateVisibility();
    });
    updateVisibility();
  }

  _indexForId(id) {
    let result = -1;
    this.buttons.forEach((button, index) => {
      if (button.id === id && result === -1) {
        result = index;
      }
    });
    return result;
  }

  _appendButton(button, events = true, index = -1) {
    if (index >= 0) {
      button.addTo(this.ui.buttons, false, index);
    } else {
      button.addTo(this.ui.buttons);
    }

    if (events) {
      if (button instanceof _ButtonGroup.default) {
        const group = button;
        group.buttons.forEach(btn => {
          this._addButtonEvents(btn);
        });
      } else {
        this._addButtonEvents(button);
      }
    }
  }

  _addButtonEvents(button) {
    button.on('select', e => {
      this.trigger('select', Object.assign({}, button.info));
    }).on('deselect', e => {
      this.trigger('deselect', Object.assign({}, button.info));
    }).on('value:change', e => {
      this.trigger('change', Object.assign(Object.assign({}, button.info), e.data));
    }).on('control:change', e => {
      this.trigger('control:change', Object.assign(Object.assign({}, button.info), e.data));
    });

    if (button instanceof _ButtonGroup.default) {
      button.on('change:size', e => {
        this.trigger("change:size"
        /* SIZE_CHANGE */
        );
      });
    } else if (button instanceof _SegmentedButton.default) {
      button.on('expanded', () => {
        this.trigger("change:size"
        /* SIZE_CHANGE */
        );
      }).on('collapsed', () => {
        this.trigger("change:size"
        /* SIZE_CHANGE */
        );
      });
    }
  }

}

var _default = ButtonPanelView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 331 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

var _strings = __webpack_require__(133);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `Panel` is a view component that functions as a common view container for any type of
 * content within an application.
 *
 * @export
 * @class Panel
 * @extends {Component<T, S>}
 * @template T
 * @template S
 */
class Panel extends _Component.default {
  /**
   * Initializes and returns a panel instance configured with the specified options.
   *
   * @param {T} [opts]
   * @memberof Panel
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      enabled: true,
      toggleable: false,
      ui: {
        container: '.awxjs__app__ui-panel-container',
        toolbar: '.awxjs__app__ui-panel-toolbar',
        content: '.awxjs__app__ui-panel-content',
        toggle: '.awxjs__app__ui-panel-toggle',
        close: '.awxjs__app__ui-panel-close'
      }
    }, opts);
    opts.className = (0, _utils.isset)(opts.className) ? `app__ui-panel ${opts.className}` : 'app__ui-panel';
    super(opts);
    this._bounds = {};
    this.setState({
      visible: this.opts.toggleable !== true,
      maxContentSize: {
        width: 10000,
        height: 10000
      }
    });
  }

  get content() {
    return this.ui.content;
  }

  get toolbar() {
    return this.ui.toolbar;
  }
  /**
   * A Boolean indicating whether the panel is currently visible.
   *
   * @readonly
   * @type {boolean}
   * @memberof Panel
   */


  get visible() {
    const {
      visible
    } = this.state;
    return visible;
  }
  /**
   * Expands the panel if the panel is toggleable and collapsed.
   *
   * @returns
   * @memberof Panel
   */


  open() {
    if (this.opts.toggleable === false) return;
    this.setState({
      visible: true
    });

    this._updateSize();

    this.$el.addClass('awxjs__app__ui-panel-toggleable-open');
  }
  /**
   * Collapses the panel if the panel is toggleable and expanded.
   *
   * @returns
   * @memberof Panel
   */


  close() {
    if (this.opts.toggleable === false) return;
    this.setState({
      visible: false
    });

    this._updateSize();

    this.$el.removeClass('awxjs__app__ui-panel-toggleable-open');
  }
  /**
   * Toggles the open/closed state.
   *
   * @memberof Panel
   */


  toggle() {
    if (this.visible) {
      this.close();
    } else {
      this.open();
    }
  }
  /**
   * Returns the DOM element container for the view content.
   *
   * @returns {*}
   * @memberof Panel
   */


  getContentContainer() {
    return this.ui.content;
  }

  size() {
    if (!this.$el) {
      return {
        width: 0,
        height: 0
      };
    }

    let sizeTarget = this.$el; // if panel is toggleable, always return the size of the toggle button since that's used
    // to calculate pinned/anchored positions in its parent container

    if (this.opts.toggleable && this.ui.toggle) {
      sizeTarget = this.ui.toggle;
    } else if (this.ui.content) {
      sizeTarget = this.ui.content;
    }

    return {
      width: sizeTarget.outerWidth(true),
      height: sizeTarget.outerHeight(true)
    };
  }
  /**
   * Returns the size required for the panel's content.
   *
   * @returns {Size}
   * @memberof Panel
   */


  contentSize() {
    const size = {
      width: 0,
      height: 0
    };
    const $content = this.getContentContainer();
    const origHeight = $content[0].style.height;
    const origWidth = $content[0].style.width; // append a hidden copy of this element to the DOM just to calcaulate the proper size

    let classNames = (0, _strings.prefixCSSClassName)(this.opts.className);
    classNames = `awxjs__app__component ${classNames}`;
    let $copy = (0, _DOM.default)(`
			<div id="awxjs__panel-calc" class="${classNames}" style="display:inline-block;visibility:none;left:-10000px;width:${origWidth}">
				<div class="awxjs__app__ui-panel-content">
					${$content.html()}
				</div>
			</div>
		`);
    (0, _DOM.default)('body').append($copy);
    $copy = (0, _DOM.default)('#awxjs__panel-calc'); // copy width and height values from style in case they are set inline
    // $copy[0].style.height = $content[0].style.height;
    // $copy[0].style.width = $content[0].style.width;

    size.width = $copy.outerWidth(true);
    size.height = $copy.outerHeight(true);
    const innerSize = {
      width: 0,
      height: 0
    };
    $copy.children().forEach(child => {
      const style = window.getComputedStyle(child); // don't include absolute positioned children in the size calculation since they
      // aren't in the normal layout flow

      if (style.position !== 'absolute') {
        const $child = (0, _DOM.default)(child);
        innerSize.width = Math.max(size.width, $child.outerWidth(true));
        innerSize.height += $child.outerHeight(true);
      }
    });
    size.height = Math.max(size.height, innerSize.height);
    size.height = Math.min(size.height, this.state.maxContentSize.height);
    $copy.remove();
    return size;
  }

  setContentSize(size, adjustForToolbar = true) {
    if (adjustForToolbar) {
      size.height -= this.toolbar.outerHeight();
    }

    this.ui.content.css({
      'max-height': `${size.height}px`,
      width: `${size.width}px`,
      overflow: 'auto'
    });
  }

  setMaxContentSize(size) {
    this.setState({
      maxContentSize: size
    }); // update content size values to account for new max size

    const contentSize = this.contentSize();
    this.setContentSize(contentSize, false);

    this._updateSize();
  }

  _updateSize() {
    if (!this.opts.toggleable) return;
    if (!this.ui.close) return;
    const size = {
      width: 0,
      height: 0
    };

    if (this.visible && this._bounds.content) {
      let {
        height,
        width
      } = this.contentSize();
      const pad = this.ui.content.padding(); // width += (pad.left + pad.right);
      // height += (pad.bottom + this.ui.toolbar.outerHeight(true));

      height += this.ui.toolbar.outerHeight(true);
      size.width = width;
      size.height = height;
    } else if (!this.visible && this._bounds.toggle) {
      const {
        height,
        width
      } = this._bounds.toggle;
      size.width = width;
      size.height = height;
    } // console.log(this.id, size);
    // const bounds = this.$el.bounds();
    // size.height = Math.min(size.height, this.parent().height() - bounds.top * 2);


    this.ui.container.css({
      'max-height': `${size.height}px`,
      'max-width': `${size.width}px`
    });
    this.$el.css({
      'min-height': `${size.height}px`,
      'min-width': `${size.width}px`
    });
  }

  _render() {
    return `
			<div class="awxjs__app__ui-panel">
				<div class="awxjs__app__ui-panel-container">
					<div class="awxjs__app__ui-panel-toolbar">
						${this.opts.title ? `<div class="awxjs__app__ui-panel-title">${this.opts.title}</div>` : ''}
						<button class="awxjs__app__ui-panel-close">
							<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
								<path d="m22.699 77.301c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992l21.699-21.602 21.699 21.699c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992c1.6016-1.6016 1.6016-4.1016 0-5.6992l-21.602-21.699 21.699-21.699c1.6016-1.6016 1.6016-4.1016 0-5.6992-1.6016-1.6016-4.1016-1.6016-5.6992 0l-21.699 21.699-21.699-21.602c-1.6016-1.6016-4.1016-1.6016-5.6992 0-1.6016 1.6016-1.6016 4.1016 0 5.6992l21.699 21.602-21.602 21.699c-1.5977 1.5-1.5977 4.1016 0 5.6016z"/>
							</svg>
						</button>
					</div>
					<div class="awxjs__app__ui-panel-content"></div>
					<div class="awxjs__app__ui-panel-toggle">${this.opts.icon}</div>
				</div>
			</div>
		`;
  }

  _layout() {
    super._layout();

    if (this.ui.content) {
      const size = this.contentSize();

      if (size.width > 0 && size.height > 0) {
        const pad = this.ui.content.padding();
        this._bounds.content = (0, _utils.extend)(this.ui.content.bounds(), {
          height: size.height + pad.top + pad.bottom,
          width: size.width + pad.left + pad.right
        });
      }
    }

    if (this.ui.toggle) {
      // this.ui.content.css({
      // 	height: `auto`,
      // 	width: `auto`
      // });
      this._bounds.toggle = this.ui.toggle.bounds();
    } // if (this._bounds.content) {
    // 	const bounds = this.contentSize();
    // 	// set static width and height on container if not toggleable for
    // 	// proper sizing and positioning
    // 	if (this.opts.toggleable === false) {
    // 		this.$el.css({
    // 			height: `${bounds.height}px`,
    // 			width: `${bounds.width}px`
    // 		});
    // 	}
    // }


    this._updateSize();
  }

  _afterRender() {
    super._afterRender();

    if (this.opts.toggleable) {
      this.$el.addClass('awxjs__app__ui-panel-toggleable');
    }
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    if (this.opts.toggleable) {
      this.close();
    }
  }

  _setupEvents() {
    if (this.opts.toggleable) {
      this.ui.toggle.on('click', () => {
        this.open();
      });
      this.ui.close.on('click', () => {
        this.close();
      });
    }
  }

}

var _default = Panel;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 332 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _View = _interopRequireDefault(__webpack_require__(333));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `Component` is a view subclass that contains and manages its own state and is typically used
 * for interactive interface elements.
 *
 * @export
 * @class Component
 * @extends {View<T>}
 * @template T
 * @template S
 */
class Component extends _View.default {
  /**
   * Current component state.
   *
   * @readonly
   * @type {S}
   * @memberof Component
   */
  get state() {
    return (0, _utils.cloneDeep)(this._state);
  }

  getState(key) {
    return (0, _utils.get)(this.state, key);
  }
  /**
   * Updates the component state with the provided properties. Only those state properties
   * provided will be updated, while all other state properties will retain their existing
   * values.
   *
   * @param {*} state
   * @memberof Component
   */


  setState(state) {
    this._state = (0, _utils.extend)(this._state, state);
  }

}

var _default = Component;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 333 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

var _layout = __webpack_require__(208);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `View` object is the base class used for view and component classes.
 *
 * @export
 * @class View
 * @extends {EventDispatcher}
 * @template T
 */
class View extends _EventDispatcher.default {
  /**
   * Initializes and returns a view instance using the specified configuration options.
   *
   * @param {T} [opts]
   * @param {*} [data]
   * @memberof View
   */
  constructor(opts, data) {
    super();
    this._renderCount = 0;
    opts = (0, _utils.extend)({
      className: (0, _strings.prefixCSSClassName)('app__view'),
      renderer: null,
      requiresData: false
    }, opts);
    this._opts = opts; // this._target = $('<div></div>');

    this._ui = {};
    this._needsRender = true;
    this._data = (0, _utils.cloneDeep)(data); // this._DOMObserver = new MutationObserver((mutations: any, observer: any) => {
    // 	// console.log(mutations);
    // 	mutations.forEach((mutation: MutationRecord) => {
    // 		console.log(mutation.type, mutation.target, mutation.addedNodes);
    // 	});
    // });
    // this._DOMObserver.observe(this._target[0], { childList: true, subtree: true });
    // this.render(data);
  }
  /**
   * DOM element associated with the view.
   *
   * @readonly
   * @type {*}
   * @memberof View
   */


  get $el() {
    return this._target;
  }
  /**
   * Identifier associated with the view.
   *
   * @readonly
   * @type {string}
   * @memberof View
   */


  get id() {
    return this.opts.id;
  }
  /**
   * Configuration options.
   *
   * @readonly
   * @type {T}
   * @memberof View
   */


  get opts() {
    return this._opts;
  }
  /**
   * Interface DOM targets, which are only available after the view has been rendered to the DOM.
   *
   * @readonly
   * @type {{ [key: string]: any }}
   * @memberof View
   */


  get ui() {
    return this._ui;
  }
  /**
   * Data used when rendering the view, if any.
   *
   * @readonly
   * @type {*}
   * @memberof View
   */


  get data() {
    return this._data;
  }

  get isRendered() {
    return this._renderCount > 0 && typeof this._target.parent() !== 'undefined';
  }

  get isMounted() {
    return (0, _utils.isset)(this.parent());
  }

  el(selector) {
    return (0, _DOM.default)(selector, this.$el);
  }

  initialize(data) {
    data = Object.assign(Object.assign({}, this._data), data);

    let content = this._render(data);

    if (content) {
      content = content.replace(/^[^<]+/, '').replace(/[\n\r\t.]+$/, '');
      this._target = (0, _DOM.default)(content);

      this._afterRender();
    }
  }
  /**
   * Adds the view's element to the DOM by appending it to the specified target.
   *
   * @param {(HTMLElement | string)} target DOM target in which the view will be appended
   * @param {boolean} [replace=false] Whether the view should replace the target's existing
   * content
   * @param {number} [index=-1] Index within the target's children at which the view is
   * inserted, if applicable. If the value is `-1` or greater than the total number of
   * children, the view is appened to the end of the target.
   * @memberof View
   */


  addTo(target, replace = false, index = -1) {
    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for View.addTo()');
    }

    const $target = (0, _DOM.default)(target);

    if (replace) {
      $target.empty();
    } // if (this._needsRender) {
    // 	this.render(this._data);
    // }
    // if (this.opts.requiresData && isEmpty(this.data)) {
    // 	return false;
    // }


    const content = this._render(this._data);

    if (index >= 0) {
      const children = $target.children();

      if (index >= children.length) {
        $target.append(content);
        this._target = $target.children().last();
      } else {
        (0, _DOM.default)(children[index]).before(content);
        this._target = (0, _DOM.default)($target.children()[index]);
      }
    } else {
      $target.append(content);
      this._target = $target.children().last();
    }

    this._afterRender();

    if (this.opts.requiresData && (0, _utils.isEmpty)(this.data)) {
      this.hide();
    }

    if (!this._target) {
      return false;
    }

    this._lastSize = this.size();

    if (this._opts.ui) {
      this.setUI(this._opts.ui);
    }

    if (this.opts.className) {
      this.$el.addClass((0, _strings.prefixCSSClassName)(this.opts.className));
    }

    this._onAddedToDOM();

    this._layout();

    this._setupEvents();

    this._afterEvents();

    this.trigger('render');
    (0, _DOM.default)(window).on('resize', () => {
      this._onResize();
    });
    return true;
  }

  setIndex(index) {
    const $parent = this.$el.parent();
    const currentIndex = this.index();

    if ($parent && currentIndex !== index) {
      this.$el.remove();
      const children = $parent.children();
      const targetIndex = Math.min(index, children.length) - 1;
      (0, _DOM.default)(children[targetIndex]).after(this.$el);
      this._target = (0, _DOM.default)($parent.children()[index]);
    }
  }

  index() {
    const $parent = this.$el.parent();

    if ($parent) {
      const children = $parent.children();
      return children.indexOf(this.$el[0]);
    }

    return -1;
  }
  /**
   * Removes the view from the DOM.
   *
   * @memberof View
   */


  remove(removeEvents = false) {
    if (this.$el) {
      this.$el.remove();
    }

    if (removeEvents) {
      this.offAll();
    }
  }
  /**
   * Shows the view.
   *
   * @memberof View
   */


  show() {
    if (this.$el) {
      this.$el.show();
      this.trigger('show');
    }
  }
  /**
   * Hides the view.
   *
   * @memberof View
   */


  hide() {
    if (this.$el) {
      this.$el.hide();
      this.trigger('hide');
    }
  }
  /**
   * Parent DOM target, if any. Parent will be `null` if the view has not been added to the DOM.
   *
   * @returns {*}
   * @memberof View
   */


  parent() {
    if (this.$el) {
      const result = this.$el.parent();

      if (result && result.length > 0 && result[0] !== null) {
        return result;
      }
    }

    return null;
  }
  /**
   * Returns the view's current size.
   *
   * @returns {Size}
   * @memberof View
   */


  size() {
    if (!this.$el) {
      return {
        width: 0,
        height: 0
      };
    }

    return {
      width: this.$el.outerWidth(true),
      height: this.$el.outerHeight(true)
    };
  }

  setSize(width, height) {
    if (width === 0 && height === 0) return;
    const size = this.size();

    if (width > 0) {
      size.width = width;
    }

    if (height > 0) {
      size.height = height;
    }

    this.$el.css({
      width: `${size.width}px`,
      height: `${size.height}px`
    });

    this._onResize();
  }

  layout() {
    this._layout();
  }

  bounds(absolute = false, relative = null) {
    if (this.$el) {
      return this.$el.bounds(absolute, relative);
    }

    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }

  update(data, replace = true) {
    if (data) {
      data = this._onData(data);

      if ((0, _utils.isArray)(data)) {
        this._data = (0, _utils.cloneDeep)(data);
      } else {
        this._data = Object.assign(Object.assign({}, this._data), (0, _utils.cloneDeep)(data));
      }
    }

    if (this.$el && replace) {
      const content = this._render(this._data);

      this._target = this.$el.replace(content);

      this._afterRender();

      this.trigger('render');

      if (this.opts.requiresData && (0, _utils.isEmpty)(data)) {
        this.hide();
      } else {
        this.show();
      }
    }
  }
  /**
   * Assigns the UI targets according to the view's configured interface selectors.
   *
   * Note that this method should only be called after the view has been rendered and added to
   * the DOM.
   *
   * @param {{ [key: string]: string }} mapping
   * @returns
   * @memberof View
   */


  setUI(mapping) {
    if (!this.$el) return;
    Object.keys(mapping).forEach(key => {
      try {
        const result = (0, _DOM.default)(mapping[key], this.$el);

        if (result && result.length > 0) {
          this._ui[key] = result;
        } else {
          this._ui[key] = null;
        }
      } catch (e) {
        console.warn(e);
      }
    });
  }
  /**
   * Updates the view's position to the specified x and y values with optional offsets. The view
   * must be configured with absolute positioning.
   *
   * @param {Point} position
   * @param {{ x: number, y: number }} [offset={ x: 0, y: 0 }]
   * @memberof View
   */


  moveTo(position, offset = {
    x: 0,
    y: 0
  }) {
    let x = position.x;
    let y = position.y;
    x += offset.x;
    y += offset.y;
    this.$el.css({
      left: `${x}px`,
      top: `${y}px`
    });
  }
  /**
   * Positions the view by pinning it relative to its parent container. The view must be
   * configured with absolute positioning.
   *
   * @param {AnchorType} position Anchor position of the view within its container
   * @param {{ x: number, y: number }} [offset] Offsets relative to the pinned position
   * @memberof View
   */


  pinTo(position, offset) {
    const $parent = this.parent();
    position = position.replace(/-/, '');
    offset = (0, _utils.extend)({
      x: 0,
      y: 0
    }, offset);
    this.$el.addClass(`awxjs__app__view__pinned-${position}`);

    if ($parent) {
      const parent = $parent.bounds();
      const pos = (0, _layout.getPinnedPosition)(position, this.size(), {
        width: parent.width,
        height: parent.height
      }, offset);
      const horizontal = /right/.test(position) ? 'right' : 'left';
      const vertical = /bottom/.test(position) ? 'bottom' : 'top';
      const style = window.getComputedStyle(this.$el[0]);

      if (style && style.transform !== 'none') {
        const matrixType = style.transform.replace(/\(.+$/, '');
        const transformMatrix = style.transform.replace(/[^0-9,-]/g, '').split(',').map(v => parseFloat(v)); // adjust postion based on transform matrix translations

        if (matrixType === 'matrix') {
          const [a, b, c, d, tx, ty] = transformMatrix;
          pos.x -= tx / 2;
          pos.y -= ty / 2;
        }
      } // if horizontal or vertical positions are right/bottom, then just use the offset
      // values for the position but the inverse


      if (horizontal === 'right') pos.x = offset.x * -1;
      if (vertical === 'bottom') pos.y = offset.y * -1;
      const props = {};
      props[horizontal] = `${pos.x}px`;
      props[vertical] = `${pos.y}px`;
      this.$el.css(props);
    }
  } // /**
  //  * Renders the view.
  //  *
  //  * If `data` is provided, the view will be rendered with the specified data. Otherwise, the
  //  * existing data will be used, if any.
  //  *
  //  * @param {*} [data]
  //  * @memberof View
  //  */
  // public render(data?: any) {
  // 	if (!this.$el || this.$el.length === 0) return;
  // 	if (data) this._data = cloneDeep(data);
  // 	data = data || {};
  // 	// if view requires data but data is empty, then don't render or show this view
  // 	if (this.opts.requiresData && isEmpty(data)) {
  // 		this.$el.hide();
  // 		this.$el.empty();
  // 		return;
  // 	}
  // 	if (this.$el.css('display') === 'none') {
  // 		this.$el.show();
  // 	}
  // 	this._beforeRender();
  // 	const renderer = this.opts.renderer;
  // 	let output: string;
  // 	if (renderer) {
  // 		if (isFunction(renderer)) {
  // 			output = (<Function>renderer)(data);
  // 		} else if (isString(renderer)) {
  // 			output = <string>renderer;
  // 		}
  // 	} else {
  // 		output = this._render(data);
  // 	}
  // 	if (isset(output)) {
  // 		this.$el.html(output);
  // 		this._renderCount += 1;
  // 	}
  // 	this._needsRender = false;
  // 	if (this._opts.ui) {
  // 		this.setUI(this._opts.ui);
  // 	}
  // 	this._afterRender();
  // }


  _render(data) {
    return '<div></div>';
  }

  _layout() {}

  _onData(data) {
    return data;
  }

  _beforeRender() {}

  _afterRender() {
    this._renderCount += 1;
  }

  _setupEvents() {}

  _afterEvents() {}

  _onAddedToDOM() {}

  _onResize() {
    if (this._shouldLayout()) {
      this._layout();
    }

    this._lastSize = this.size();
  }

  _shouldLayout() {
    const size = this.size();

    if (size.width !== this._lastSize.width || size.height !== this._lastSize.height) {
      return true;
    }

    return false;
  }

}

var _default = View;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 334 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = exports.buttonIdentifier = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _ButtonControls = _interopRequireDefault(__webpack_require__(335));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const buttonIdentifier = id => (id || '').replace(/\:.+$/, '').replace(/[^a-zA-Z0-9_]/g, '-').replace(/-+/g, '-').replace(/,/g, '__').toLowerCase();
/**
 * A `Button` is a component that triggers an event when clicked and supports a toggleable
 * selected state.
 *
 * @export
 * @class Button
 * @extends {Component<T, S>}
 * @implements {Toggleable}
 * @template T
 * @template S
 */


exports.buttonIdentifier = buttonIdentifier;

class Button extends _Component.default {
  /**
   * Initializes and returns a button instance with the specified configuration options.
   *
   * @param {*} [opts]
   * @memberof Button
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      toggleable: true,
      controls: {
        close: true,
        activity: true
      }
    }, opts, {
      className: opts.className ? `ui-btn ${opts.className}` : 'ui-btn',
      ui: {
        target: '.awxjs__ui-btn-target',
        label: '.awxjs__ui-btn-label',
        close: '.awxjs__ui-btn-close',
        settings: '.awxjs__ui-btn-settings',
        controls: '.awxjs__ui-btn-controls'
      }
    });
    opts.id = opts.id || (opts.value ? opts.value.replace(/,/g, '__') : null);
    super(opts);

    if (opts.controls) {
      this._controls = new _ButtonControls.default({
        controls: opts.controls
      });
    }

    this.setState({
      selected: false
    });
    this.initialize();
  }
  /**
   * Button identifier.
   *
   * @readonly
   * @type {string}
   * @memberof Button
   */


  get id() {
    return buttonIdentifier(this.opts.id || this.opts.value);
  }

  get key() {
    return `${this.parentId ? `${this.parentId}::` : ''}${this.groupId ? `${this.groupId}::` : ''}${this.id}`;
  }

  get parentId() {
    return this.opts.parent;
  }

  get groupId() {
    return this.opts.group;
  }

  get info() {
    return {
      id: this.id,
      key: this.key,
      value: this.value,
      group: this.groupId,
      parent: this.parentId,
      options: this.options
    };
  }
  /**
   * A Boolean indicated whether the button is currently selected.
   *
   * @readonly
   * @type {boolean}
   * @memberof Button
   */


  get selected() {
    const {
      selected
    } = this.state;
    return selected;
  }

  get toggleable() {
    return this.opts.toggleable;
  }

  get controls() {
    return this._controls;
  }
  /**
   * Value associated with the button, if any.
   *
   * @readonly
   * @type {*}
   * @memberof Button
   */


  get value() {
    return this.opts.value;
  }
  /**
   * Title label displayed for the button.
   *
   * @readonly
   * @type {string}
   * @memberof Button
   */


  get title() {
    return this.opts.title;
  }
  /**
   * Custom data associated with the button, if any.
   *
   * @readonly
   * @type {*}
   * @memberof Button
   */


  get options() {
    return this.opts.options;
  }
  /**
   * Selects the button.
   *
   * @memberof Button
   */


  select(trigger = true) {
    if (this.selected === false) {
      this.$el.addClass('selected');

      this._onSelect(trigger);
    }
  }
  /**
   * Deselects the button.
   *
   * @memberof Button
   */


  deselect(trigger = true) {
    if (this.selected) {
      this.$el.removeClass('selected');

      this._onDeselect(trigger);
    }
  }
  /**
   * Enables or disables the button.
   * If disabled, button will not react to click events.
   */


  disable(value) {
    this.$el.attr('data-disabled', value ? 1 : 0);
  }

  matches(check) {
    const ids = !(0, _utils.isArray)(check) ? [check] : check;
    return ids.filter(id => this.id === id || this.key === id || this.value === id).length > 0;
  }

  setLoading(loading) {
    if (this.controls) {
      this.controls.setLoading(loading);
    }
  }

  _onSelect(trigger = true) {
    this.setState({
      selected: true
    });

    if (trigger) {
      this.trigger("select"
      /* SELECT */
      , {
        value: this.value
      });

      if (this.opts.onSelect) {
        this.opts.onSelect(this);
      }
    }
  }

  _onDeselect(trigger = true) {
    this.setState({
      selected: false
    });

    if (trigger) {
      this.trigger("deselect"
      /* DESELECT */
      , {
        value: this.value
      });

      if (this.opts.onDeselect) {
        this.opts.onDeselect(this);
      }
    }
  }

  _render() {
    return `
			<div class="awxjs__ui-btn">
				<div class="awxjs__ui-btn-target">
					<div class="awxjs__ui-btn-label">${this.opts.title}</div>
				</div>
			</div>
		`;
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    this.$el.attr('data-id', this.id);

    if (this.opts.selected) {
      this.select();
    }

    if (this.controls) {
      this.controls.addToButton(this);
    }
  }

  _setupEvents() {
    super._setupEvents();

    this.$el.on('click', e => {
      e.stopPropagation();
      const disabled = (0, _utils.toBool)(this.$el.attr('data-disabled')) || false;

      if (!disabled) {
        if (this.selected) {
          if (this.toggleable) {
            this.deselect();
          }
        } else {
          this.select();
        }
      }
    });
    const controls = this.controls;

    if (controls) {
      controls.on('change', e => {
        this.trigger('control:change', Object.assign(Object.assign({}, this.info), {
          control: Object.assign({}, e.data)
        }));
      });

      if (controls.ui.settings && !this.opts.selected) {
        controls.ui.settings.hide();
      }

      if (controls.ui.close) {
        this.ui.target.on('mouseenter', () => {
          if (this.$el.hasClass('selected') && (0, _utils.toBool)(this.$el.attr('data-disabled')) !== true) {
            controls.ui.close.css('opacity', 1);
          }
        }).on('mouseleave', e => {
          controls.ui.close.css('opacity', 0);
        });
      }
    }
  }

}

var _default = Button;
exports["default"] = _default;

/***/ }),
/* 335 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(302));

var _Tooltip = _interopRequireDefault(__webpack_require__(336));

var _LayerControlsView = _interopRequireDefault(__webpack_require__(339));

var _utils = __webpack_require__(17);

var _View = _interopRequireDefault(__webpack_require__(333));

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// store a reference to the active popover so it can be dismissed when a new one is presented
let activePopover = null;

class ButtonControls extends _View.default {
  constructor(opts) {
    var _a;

    super((0, _utils.extend)({
      controls: [{
        close: true,
        activity: false,
        settings: undefined
      }]
    }, opts, {
      ui: {
        close: '.awxjs__ui-btn-close',
        settings: '.awxjs__ui-btn-settings',
        controls: '.awxjs__ui-btn-controls'
      }
    }));

    this._handleWindowClick = e => {
      const $target = (0, _DOM.default)(e.target);
      const $view = this._popover.$el;

      if ($view !== $target && $view.contains($target) === false) {
        this._hidePopover();

        window.removeEventListener('click', this._handleWindowClick);
      }
    };

    if ((_a = opts.controls) === null || _a === void 0 ? void 0 : _a.onChange) {
      this._onChange = opts.controls.onChange;
    }

    const controls = this.opts.controls;

    if (controls.activity) {
      this._indicator = new _ActivityIndicator.default({
        size: 24,
        strokeWidth: 2
      });
    }
  }

  setLoading(loading) {
    if (this._indicator) {
      if (loading) {
        this._indicator.startAnimating();
      } else {
        this._indicator.stopAnimating();
      }
    }

    this.ui.close.css('opacity', loading ? 0 : 1);

    if (this.ui.settings) {
      this.ui.settings.css('opacity', loading ? 0 : 1);
    }
  }

  addToButton(button) {
    if (button.ui.target) {
      this.remove();
      this.addTo(button.$el);
      button.on('select', () => {
        if (this.ui.settings) {
          this.ui.settings.show();
        }
      }).on('deselect', () => {
        if (this.ui.close) {
          this.ui.close.css('opacity', 0);
        }

        if (this.ui.settings) {
          this.ui.settings.hide();
        }

        if (this._popover) {
          this._hidePopover();
        }
      });
    }
  }

  _render() {
    const controls = this.opts.controls;
    let result = '';

    if (controls.close) {
      result += `
				<div class="awxjs__ui-btn-action awxjs__ui-btn-close" title="Close">
					<svg width="100pt" height="100pt" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
						<path d="m22.699 77.301c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992l21.699-21.602 21.699 21.699c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992c1.6016-1.6016 1.6016-4.1016 0-5.6992l-21.602-21.699 21.699-21.699c1.6016-1.6016 1.6016-4.1016 0-5.6992-1.6016-1.6016-4.1016-1.6016-5.6992 0l-21.699 21.699-21.699-21.602c-1.6016-1.6016-4.1016-1.6016-5.6992 0-1.6016 1.6016-1.6016 4.1016 0 5.6992l21.699 21.602-21.602 21.699c-1.5977 1.5-1.5977 4.1016 0 5.6016z"/>
					</svg>
				</div>
			`;
    }

    if (controls.settings) {
      result += `
				<div class="awxjs__ui-btn-action awxjs__ui-btn-settings" title="Settings">
					<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
						<path d="m94.801 40.801-10.602-1.8008c-0.60156-1.8984-1.3984-3.6992-2.3008-5.5l6.1992-8.6992c0.89844-1.3008 0.80078-3.1016-0.30078-4.1992l-8.5-8.5c-1.1016-1.1016-2.8984-1.3008-4.1992-0.30078l-8.6992 6.1992c-1.6992-0.89844-3.6016-1.6992-5.5-2.3008l-1.6992-10.5c-0.30078-1.6016-1.6016-2.6992-3.1992-2.6992h-12c-1.6016 0-2.8984 1.1016-3.1992 2.6992l-1.8008 10.602c-1.8984 0.60156-3.6992 1.3984-5.5 2.3008l-8.6992-6.1992c-1.3008-0.89844-3.1016-0.80078-4.1992 0.30078l-8.5 8.5c-1.1016 1.1016-1.3008 2.8984-0.30078 4.1992l6.1992 8.6992c-0.89844 1.6992-1.6992 3.6016-2.3008 5.5l-10.5 1.6992c-1.6016 0.30078-2.6992 1.6016-2.6992 3.1992v12c0 1.6016 1.1016 2.8984 2.6992 3.1992l10.602 1.8008c0.60156 1.8984 1.3984 3.6992 2.3008 5.5l-6.1992 8.6992c-0.89844 1.3008-0.80078 3.1016 0.30078 4.1992l8.5 8.5c1.1016 1.1016 2.8984 1.3008 4.1992 0.30078l8.6992-6.1992c1.6992 0.89844 3.6016 1.6992 5.5 2.3008l1.8008 10.602c0.30078 1.6016 1.6016 2.6992 3.1992 2.6992h12c1.6016 0 2.8984-1.1016 3.1992-2.6992l1.6992-10.703c1.8984-0.60156 3.6992-1.3984 5.5-2.3008l8.6992 6.1992c1.3008 0.89844 3.1016 0.80078 4.1992-0.30078l8.5-8.5c1.1016-1.1016 1.3008-2.8984 0.30078-4.1992l-6.1992-8.6992c0.89844-1.6992 1.6992-3.6016 2.3008-5.5l10.602-1.8008c1.6016-0.30078 2.6992-1.6016 2.6992-3.1992v-11.898c-0.10156-1.6016-1.2031-2.8984-2.8008-3.1992zm-44.801 26.301c-9.5 0-17.102-7.6992-17.102-17.102 0-9.5 7.6992-17.102 17.102-17.102 9.3984 0 17.102 7.6016 17.102 17.102s-7.6016 17.102-17.102 17.102z"/>
					</svg>
				</div>
			`;
    }

    if (result !== '') {
      result = `<div class="awxjs__ui-btn-controls">${result}</div>`;
    }

    return result;
  }

  _setupEvents() {
    super._setupEvents();

    const controls = this.opts.controls;

    if (this._indicator) {
      this._indicator.appendTo(this.$el);
    }

    if (controls.settings && this.ui.settings) {
      this.ui.settings.on('click', e => {
        e.preventDefault();
        e.stopPropagation();

        if (!this._popover) {
          const view = new _LayerControlsView.default({
            controls: controls.settings
          });
          view.on('change', ee => {
            const payload = Object.assign({}, ee.data);
            this.trigger('change', payload);

            if (this._onChange) {
              this._onChange(payload);
            }
          });
          const tooltip = new _Tooltip.default(view.$el, {
            place: 'left',
            className: 'awxjs__ui-layer-controls-popover',
            showClose: true
          });
          view.addTo(tooltip.$el);
          tooltip.attachTo(this.parent());
          tooltip.setContent(view.$el);
          this._popover = tooltip;
          this._controls = view;
        }

        if (this._popover.visible) {
          this._hidePopover();
        } else {
          this._showPopover();
        }

        window.addEventListener('click', this._handleWindowClick);
      });
    }
  }

  _showPopover() {
    if (activePopover) {
      activePopover.hide();
    }

    this._popover.show();

    activePopover = this._popover;
  }

  _hidePopover() {
    this._popover.hide();

    activePopover = null;
  }

}

var _default = ButtonControls;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 336 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _KeyObserver = _interopRequireDefault(__webpack_require__(337));

var _utils = __webpack_require__(17);

var icons = _interopRequireWildcard(__webpack_require__(338));

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 * Check whether value is a window object.
 *
 * Uses duck typing to determine window. Without IE8 all we need is:
 *
 *   var type = Object.prototype.toString.call(val);
 *   return type === '[object global]' || type === '[object Window]' || type === '[object DOMWindow]';
 *
 * @param  {Mixed} val
 * @return {Boolean}
 */
const isWindow = val => {
  const doc = val ? val.document : null;
  const docWin = doc ? doc.defaultView || doc.parentWindow : null;
  return !!(val && typeof val === 'object' && typeof val.window === 'object' && val.window === val && val.setTimeout && val.alert && (0, _utils.isset)(doc) && typeof doc === 'object' && (0, _utils.isset)(docWin) && typeof docWin === 'object' && docWin === val);
};
/**
 * @ignore
 */


const transitionDuration = element => {
  const computed = window.getComputedStyle(element);
  const duration = String(computed.getPropertyValue('transition-duration') || computed.getPropertyValue('-webkit-transition-duration'));
  const match = duration.match(/([0-9.]+)([ms]{1,2})/);
  let val = 0;

  if (match) {
    val = Number(match[1]);
    if (match[2] === 's') val *= 1000;
  }

  return val || 0;
};
/**
 * @ignore
 * Returns element's position object with `left`, `top`, `bottom`, `right`,
 * `width`, and `height` properties indicating the position and dimensions
 * of element on a page, or relative to other element.
 *
 * @param {Element} element
 * @param {Element} [relativeTo] Defaults to `document.documentElement`.
 *
 * @return {Object|null}
 */


const position = (element, relativeTo) => {
  const isWin = isWindow(element);
  const doc = isWin ? element.document : element.ownerDocument || element;
  const docEl = doc.documentElement;
  const win = isWindow(relativeTo) ? relativeTo : doc.defaultView || window; // normalize arguments

  if (element === doc) element = docEl;
  relativeTo = !relativeTo || relativeTo === doc ? docEl : relativeTo;
  const winTop = (win.pageYOffset || docEl.scrollTop) - docEl.clientTop;
  const winLeft = (win.pageXOffset || docEl.scrollLeft) - docEl.clientLeft;
  const box = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  };

  if (isWin) {
    box.width = win.innerWidth || docEl.clientWidth;
    box.height = win.innerHeight || docEl.clientHeight;
    box.right = box.width;
    box.bottom = box.height;
  } else if (element === docEl) {
    // we need to do  this manually because docEl.getBoundingClientRect
    // is inconsistent in <IE11
    box.top = -winTop;
    box.left = -winLeft;
    box.width = Math.max(docEl.clientWidth, docEl.scrollWidth);
    box.height = Math.max(docEl.clientHeight, docEl.scrollHeight);
    box.right = box.width - winLeft;
    box.bottom = box.height - winTop;
  } else if (docEl.contains(element) && element.getBoundingClientRect) {
    // new object needed because DOMRect properties are read-only
    const bounds = element.getBoundingClientRect();
    Object.keys(box).forEach(key => {
      box[key] = bounds[key];
    }); // width & height don't exist in <IE9

    box.width = box.right - box.left;
    box.height = box.bottom - box.top;
  } else {
    return null;
  } // current box is already relative to window


  if (relativeTo === win) return box; // add window offsets, making the box relative to documentElement

  box.top += winTop;
  box.left += winLeft;
  box.right += winLeft;
  box.bottom += winTop; // current box is already relative to documentElement

  if (relativeTo === docEl) return box; // subtract position of other element

  const relBox = position(relativeTo);
  box.left -= relBox.left;
  box.right -= relBox.left;
  box.top -= relBox.top;
  box.bottom -= relBox.top;
  return box;
};

let activeTooltip;
/**
 * A `Tooltip` is a component for displaying additional information or content in a popover when
 * the target element is hovered over or clicked on.
 *
 * @export
 * @class Tooltip
 * @extends {EventDispatcher}
 */

class Tooltip extends _EventDispatcher.default {
  /**
   * Initializes and returns a tooltip instance configured with the specified content and options.
   *
   * @param {(string | HTMLElement)} [content]
   * @param {TooltipOptions} [opts]
   * @memberof Tooltip
   */
  constructor(content, opts) {
    super();
    this._size = {
      width: 0,
      height: 0
    };
    this._observers = {
      mutation: undefined,
      key: new _KeyObserver.default()
    };

    this._reposition = () => {
      const raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || (fn => {
        return setTimeout(fn, 17);
      });

      const requestReposition = () => {
        raf(() => {
          this.position();
        });
      };

      requestReposition();
    };

    this._opts = (0, _utils.extend)({
      place: 'top',
      effect: 'slide',
      spacing: 5,
      showClose: false
    }, opts);
    this._hidden = true;
    this._element = (0, _DOM.default)('<div class="awxjs__ui-tooltip"></div>');
    const closeBtn = this._opts.showClose ? `
			<button class="awxjs__ui-btn-icon-sm awxjs__ui-tooltip-close">
				${icons.close()}
			</button>
		` : '';
    this.$el.html(`
			${closeBtn}
			<div class="awxjs__ui-tooltip-content"></div>
		`);

    if (this._opts.className) {
      this.$el.addClass(this._opts.className);
    }

    if (this._opts.effect) {
      this.$el.addClass(this._opts.effect);
    }

    if (content) {
      this.setContent(content);
    }

    this._observers.key.on('escape', () => {
      this.hide();
    }); // observe when DOM elements are removed from the DOM tree and check if the tooltip's
    // target still exists, otherwise remove the tooltip from the DOM


    this._observers.mutation = new MutationObserver((records, observer) => {
      if (records && this._target.length > 0) {
        const target = this._target[0];
        records.forEach(record => {
          if (record.removedNodes && record.removedNodes.length > 0) {
            if (document.body.contains(target) === false) {
              this.destroy();
            }
          }
        });
      }
    });
  }
  /**
   * DOM element.
   *
   * @readonly
   * @type {*}
   * @memberof Tooltip
   */


  get $el() {
    return this._element;
  }

  get $content() {
    return (0, _DOM.default)('.awxjs__ui-tooltip-content', this.$el);
  }

  get $close() {
    return (0, _DOM.default)('.awxjs__ui-tooltip-close', this.$el);
  }
  /**
   * Target DOM element.
   *
   * @readonly
   * @type {*}
   * @memberof Tooltip
   */


  get $target() {
    return this._target;
  }
  /**
   * Size of the tooltip.
   *
   * @readonly
   * @type {Size}
   * @memberof Tooltip
   */


  get size() {
    return this._size;
  }
  /**
   * A Boolean indicating whether the tooltip is currently visible.
   *
   * @readonly
   * @type {boolean}
   * @memberof Tooltip
   */


  get visible() {
    return this._hidden === false;
  }
  /**
   * Shows the tooltip from the previously configured target.
   *
   * To present the tooltip from a different target, call `attachTo()` before showing the
   * tooltip.
   *
   * @param {boolean} [hideOthers=true] A Boolean indicating whether all existing tooltips
   * should be hidden when showing this instance.
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  show(hideOthers = true) {
    clearTimeout(this._hideTimeout);

    if (activeTooltip && hideOthers) {
      activeTooltip.hide();
      activeTooltip = this;
    }

    if (this._target) {
      this.position(this._target);
    }

    if (this._hidden) {
      this._hidden = false;
      (0, _DOM.default)('body').append(this.$el);
    }

    this._observers.key.start();

    this.$close.on('click', this.hide.bind(this));
    (0, _DOM.default)(window).on('scroll resize', this._reposition); // trigger layout and start the transition

    setTimeout(() => {
      this.$el.addClass('in');
    }, 100);
    return this;
  }
  /**
   * Hides the tooltip.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  hide() {
    if (this._hidden) {
      return this;
    }

    this._observers.key.stop();

    this.$close.off('click', this.hide.bind(this));
    this.$el.removeClass('in');
    (0, _DOM.default)(window).off('scroll resize', this._reposition);
    clearTimeout(this._hideTimeout);
    const duration = transitionDuration(this.$el[0]);
    this._hideTimeout = setTimeout(() => {
      this.$el.remove();
    }, duration);
    this._hidden = true;
    return this;
  }
  /**
   * Toggles the visibility of the tooltip.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  toggle() {
    if (this.visible) {
      return this.hide();
    }

    return this.show();
  }
  /**
   * Sets the content, which can either be a text string or HTML string.
   *
   * @param {(string | HTMLElement)} content
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  setContent(content) {
    if ((0, _utils.isString)(content)) {
      this.$content.html(content);
    } else {
      this.$content.empty().append(content);
    }

    this._updateSize();

    return this;
  }
  /**
   * Sets the current target.
   *
   * @param {*} element
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  attachTo(element) {
    this._target = element;

    if (element) {
      this._observers.mutation.disconnect();

      this._observers.mutation.observe(document, {
        childList: true,
        subtree: true
      });
    }

    if (!this._hidden) {
      this.position();
    }

    return this;
  }
  /**
   * Hides the tooltip and removes its associated with the current target.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  detach() {
    this.hide();
    this._target = null;

    this._observers.mutation.disconnect();

    return this;
  }
  /**
   * Detaches the tooltip from its associated target and removes it from the DOM.
   *
   * @memberof Tooltip
   */


  destroy() {
    this.detach();
    this.$el.remove();
  }
  /**
   * Updates the tooltip's position.
   *
   * This method accepts either an x and y pixel coordinate from which to position the tooltip.
   * Alternatively, a single DOM element argument can be provided which will be used when
   * calculating the new position.
   *
   * @param {(number | Element)} [x]
   * @param {number} [y]
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  position(x, y) {
    x = x || this._target;

    if (!(0, _utils.isset)(x) && this._p) {
      x = this._p[0];
      y = this._p[1];
    } else {
      this._p = [];
      if (x) this._p.push(x);
      if (y) this._p.push(y);
    }

    x = x[0] || x;
    const target = (0, _utils.isNumber)(x) ? {
      left: x || 0,
      right: x || 0,
      top: y || 0,
      bottom: y || 0,
      width: 0,
      height: 0
    } : position(x);

    if (!target) {
      return this;
    }

    const spacing = this._opts.spacing || 0;

    const newPlace = this._pickPlace(target);

    if (newPlace !== this._lastPlace) {
      if (this._lastPlace) {
        this.$el.removeClass(this._lastPlace);
      }

      this.$el.addClass(newPlace);
      this._lastPlace = newPlace;
    } // position the tip


    const anchor = this._lastPlace;
    const {
      width: w,
      height: h
    } = this.size;
    let top = 0;
    let left = 0;

    if (/^top/.test(anchor)) {
      top = target.top - h - spacing;
    } else if (/^bottom/.test(anchor)) {
      top = target.bottom + spacing;
    } else if (/^left/.test(anchor)) {
      left = target.left - w - spacing;
    } else if (/^right/.test(anchor)) {
      left = target.right + spacing;
    }

    if (/-left$/.test(anchor)) {
      left = target.right - w;
    } else if (/-right$/.test(anchor)) {
      left = target.left;
    } else if (/-top$/.test(anchor)) {
      top = target.bottom - h;
    } else if (/-bottom$/.test(anchor)) {
      top = target.top;
    }

    if (anchor === 'left' || anchor === 'right') {
      top = target.top + target.height / 2 - h / 2;
    } else if (anchor === 'top' || anchor === 'bottom') {
      left = target.left + target.width / 2 - w / 2;
    }

    this.$el.css({
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`
    });
    return this;
  }

  _updateSize() {
    if (this._hidden) {
      this.$el.css('visibility', 'hidden');
      (0, _DOM.default)('body').append(this.$el);
    }

    this._size = {
      width: this.$el.outerWidth(true),
      height: this.$el.outerHeight(true)
    };

    if (this._hidden) {
      this.$el.remove();
      this.$el.css('visibility', '');
    } else {
      this.position();
    }
  }

  _pickPlace(target) {
    const pos = position(window);

    const place = this._opts.place.split('-');

    const spacing = this._opts.spacing || 0;
    const verticals = ['top', 'bottom'];

    if (verticals.indexOf(place[0]) !== -1) {
      if (target.top - this.size.height - spacing <= pos.top) {
        place[0] = 'bottom';
      } else if (target.bottom + this.size.height + spacing >= pos.bottom) {
        place[0] = 'top';
      }

      switch (place[1]) {
        case 'left':
          if (target.right - this.size.width <= pos.left) {
            place[1] = 'right';
          }

          break;

        case 'right':
          if (target.left + this.size.width >= pos.right) {
            place[1] = 'left';
          }

          break;

        default:
          if (target.left + target.width / 2 + this.size.width / 2 >= pos.right) {
            place[1] = 'left';
          } else if (target.right - target.width / 2 - this.size.width / 2 <= pos.left) {
            place[1] = 'right';
          }

      }
    } else {
      if (target.left - this.size.width - spacing <= pos.left) {
        place[0] = 'right';
      } else if (target.right + this.size.width + spacing >= pos.right) {
        place[0] = 'left';
      }

      switch (place[1]) {
        case 'top':
          if (target.bottom - this.size.height <= pos.top) {
            place[1] = 'bottom';
          }

          break;

        case 'bottom':
          if (target.top + this.size.height >= pos.bottom) {
            place[1] = 'top';
          }

          break;

        default:
          if (target.top + target.height / 2 + this.size.height / 2 >= pos.bottom) {
            place[1] = 'top';
          } else if (target.bottom - target.height / 2 - this.size.height / 2 <= pos.top) {
            place[1] = 'bottom';
          }

      }
    }

    return place.join('-');
  }

}

var _default = Tooltip;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 337 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class KeyObserver extends _EventDispatcher.default {
  constructor() {
    super();

    this.keyHandler = e => {
      this.listenForKeys(e);
    };
  }

  start() {
    (0, _DOM.default)(document).on('keyup keypress', this.keyHandler);
  }

  stop() {
    (0, _DOM.default)(document).off('keyup keypress', this.keyHandler);
  }

  listenForKeys(e) {
    const event = e.type;
    const key = (e.key || '').toLowerCase();
    this.trigger(event, {
      event,
      key
    });

    if (event === 'keyup') {
      if (key === 'escape' || key === 'esc' || e.keyCode === 27) {
        this.trigger('escape');
      } else if (key === 'enter') {
        this.trigger('enter');
      }
    }
  }

}

var _default = KeyObserver;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 338 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.legends = exports.close = void 0;

const close = () => `
	<svg width="100pt" height="100pt" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
		<path d="m22.699 77.301c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992l21.699-21.602 21.699 21.699c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992c1.6016-1.6016 1.6016-4.1016 0-5.6992l-21.602-21.699 21.699-21.699c1.6016-1.6016 1.6016-4.1016 0-5.6992-1.6016-1.6016-4.1016-1.6016-5.6992 0l-21.699 21.699-21.699-21.602c-1.6016-1.6016-4.1016-1.6016-5.6992 0-1.6016 1.6016-1.6016 4.1016 0 5.6992l21.699 21.602-21.602 21.699c-1.5977 1.5-1.5977 4.1016 0 5.6016z"/>
	</svg>
`;

exports.close = close;

const legends = () => `
	<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 90 90">
		<g>
			<path d="M45,9c19.9,0,36,16.1,36,36S64.9,81,45,81S9,64.9,9,45C9,25.1,25.1,9,45,9 M45,0C20.1,0,0,20.1,0,45s20.1,45,45,45
				s45-20.1,45-45C90,20.1,69.9,0,45,0z"/>
			<path d="M48.7,29.3c0,1-0.4,1.9-1.1,2.7c-0.7,0.7-1.6,1.1-2.6,1.1c-0.5,0-0.9-0.1-1.4-0.3c-0.4-0.2-0.8-0.5-1.2-0.8
				c-0.3-0.3-0.6-0.7-0.8-1.2c-0.2-0.5-0.3-0.9-0.3-1.5c0-0.5,0.1-0.9,0.3-1.3c0.2-0.4,0.5-0.8,0.8-1.2c0.3-0.3,0.7-0.6,1.2-0.8
				c0.4-0.2,0.9-0.3,1.4-0.3s0.9,0.1,1.4,0.3c0.4,0.2,0.8,0.5,1.2,0.8c0.4,0.3,0.6,0.7,0.8,1.1C48.6,28.3,48.7,28.8,48.7,29.3
				L48.7,29.3z M48.3,59.8c0,1.1-0.3,2-0.9,2.6c-0.6,0.7-1.4,1-2.4,1s-1.8-0.3-2.4-1c-0.6-0.7-0.9-1.5-0.9-2.6v-18
				c0-1.1,0.3-2,0.9-2.6c0.6-0.7,1.4-1,2.4-1s1.8,0.3,2.4,1c0.6,0.7,0.9,1.5,0.9,2.6V59.8z"/>
		</g>
	</svg>
`;

exports.legends = legends;

/***/ }),
/* 339 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _Component = _interopRequireDefault(__webpack_require__(332));

var _RangeSlider = _interopRequireDefault(__webpack_require__(340));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const CONTROL_TYPES = {
  opacity: {
    type: 'slider',
    label: 'Opacity',
    options: {
      value: [100],
      range: {
        min: 0,
        max: 100
      },
      marksEvery: '% 50',
      marksFormatter: v => `${v}%`,
      step: 5,
      dots: false,
      tooltip: value => `${value}%`
    }
  }
};

class LayerControlsView extends _Component.default {
  constructor(opts) {
    super(opts);
    this.initialize();
  }

  _render(data) {
    return `
			<div class="awxjs__ui-layer-controls"></div>
		`;
  }

  _setupEvents() {
    super._setupEvents();

    const controls = this.opts.controls || [];
    controls.map(config => {
      const {
        type
      } = config,
            rest = __rest(config, ["type"]);

      const keys = Object.keys(CONTROL_TYPES);

      if (keys.indexOf(type) > -1) {
        return (0, _utils.extend)({}, CONTROL_TYPES[type], rest);
      }

      return config;
    }).forEach(({
      type,
      id,
      label,
      options
    }) => {
      const controlId = id || label.replace(/\s+/, '-').toLowerCase();

      if (type === 'slider') {
        const slider = new _RangeSlider.default((0, _utils.extend)(Object.assign(Object.assign({}, options), {
          title: label,
          width: 150
        }), {}));
        slider.addTo(this.$el);
        slider.on('change', e => {
          let value = (0, _utils.get)(e, 'data.value');

          if (value && (0, _utils.isset)(value[0])) {
            value = value[0];
          }

          this.trigger('change', {
            id: controlId,
            value
          });
        });
      }
    });
  }

}

var _default = LayerControlsView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 340 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _SliderHandle = _interopRequireDefault(__webpack_require__(341));

var _Tooltip = _interopRequireDefault(__webpack_require__(336));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 */
const isValueOutOfRange = (value, min, max) => value < min || value > max;
/**
 * @ignore
 */


const getClosestPoint = (value, marks, step, min, max) => {
  const points = Object.keys(marks).map(parseFloat);

  if (step !== null) {
    const maxSteps = Math.floor((max - min) / step);
    const steps = Math.min((value - min) / step, maxSteps);
    const closest = Math.round(steps) * step + min;
    points.push(closest);
  }

  const diffs = points.map(point => Math.abs(value - point));
  return points[diffs.indexOf(Math.min(...diffs))];
};
/**
 * @ignore
 */


const getPrecision = step => {
  const str = step.toString();
  let precision = 0;

  if (str.indexOf('.') >= 0) {
    precision = str.length - str.indexOf('.') - 1;
  }

  return precision;
};
/**
 * @ignore
 */


const ensureValueInRange = (value, min, max) => {
  if (value <= min) {
    return min;
  }

  if (value >= max) {
    return max;
  }

  return value;
};
/**
 * @ignore
 */


const ensureValuePrecision = (value, marks, step, min, max) => {
  const v = getClosestPoint(value, marks, step, min, max);
  const closest = Number.isFinite(v) ? v : 0;
  return !(0, _utils.isset)(step) ? closest : parseFloat(closest.toFixed(getPrecision(step)));
};
/**
 * @ignore
 */


const isEventFromHandle = (e, handles) => {
  try {
    if ((0, _utils.isArray)(handles)) {
      return handles.some(element => e.target === element);
    }

    return Object.keys(handles).some(key => e.target === handles[key]);
  } catch (error) {
    return false;
  }
};
/**
 * @ignore
 */


const getHandlePosition = element => {
  const bounds = (0, _DOM.default)(element).bounds();
  return window.pageXOffset + bounds.left + bounds.width * 0.5;
};

const positionInfoForEvent = e => {
  if (e.touches) {
    const te = e;

    if (te.touches.length > 0) {
      return te.touches[0];
    }
  }

  return e;
};

;
/**
 * A `RangeSlider` is a slider component that allows you to define a value range and step interval
 * along the slider to allow a user to change values associated with the control.
 *
 * @export
 * @class RangeSlider
 * @extends {Component<RangeSliderOptions, RangeSliderState>}
 */

class RangeSlider extends _Component.default {
  /**
   * Initializes and returns a range slider instance configured with the specified options.
   *
   * @param {RangeSliderOptions} [opts]
   * @memberof RangeSlider
   */
  constructor(opts) {
    super((0, _utils.extend)({
      range: {
        min: 0,
        max: 100
      },
      count: 1,
      step: 10,
      marks: {},
      marksEvery: undefined,
      dots: true,
      disabled: false,
      tooltip: true,
      ui: {
        inner: '.awxjs__ui-slider-range-inner',
        track: '.awxjs__ui-slider-range-track',
        rail: '.awxjs__ui-slider-range-rail',
        steps: '.awxjs__ui-slider-range-steps',
        marks: '.awxjs__ui-slider-range-marks',
        handles: '.awxjs__ui-slider-range-handle'
      }
    }, opts, {
      className: (0, _utils.get)(opts, 'className') ? `ui-slider-range ${opts.className}` : 'ui-slider-range'
    }));
    this._handles = [];

    this._onBoundsChange = state => {
      const {
        bounds
      } = state;
      const offsets = bounds.map(value => this._offsetForValue(value));

      if ((0, _utils.isset)(this._handles) && this._handles.length <= offsets.length) {
        offsets.forEach((offset, index) => {
          const handleRef = this._handles[index];

          if (handleRef) {
            handleRef.updatePosition(offsets[index]);
          }
        });
      }

      this._onChange(state);
    };

    this._onChange = state => {
      if ((0, _utils.isEmpty)(this._handles)) return;
      const {
        bounds,
        handle
      } = state;
      const offsets = bounds.map(value => this._offsetForValue(value));
      const handleRef = this._handles[handle];

      if (handleRef) {
        handleRef.updatePosition(offsets[handle]);

        this._updateTooltip(bounds[handle], handle);
      }

      if (offsets.length === 1) {
        this.ui.track.css({
          left: '0%',
          width: `${offsets[0]}%`
        });
      } else {
        const range = offsets[offsets.length - 1] - offsets[0];
        this.ui.track.css({
          left: `${offsets[0]}%`,
          width: `${range}%`
        });
      }

      this.setState({
        bounds
      });

      const lower = this._getLowerBound();

      const upper = this._getUpperBound();

      this.ui.steps.children().forEach(el => {
        const $el = (0, _DOM.default)(el);
        const point = parseFloat($el.data('key'));
        const active = point === upper || point <= upper && point >= lower;

        if (active) {
          $el.addClass('awxjs__ui-slider-range-dot-active');
        } else {
          $el.removeClass('awxjs__ui-slider-range-dot-active');
        }
      });
      this.ui.marks.children().forEach(el => {
        const $el = (0, _DOM.default)(el);
        const point = parseFloat($el.data('key'));
        const active = point === upper || point <= upper && point >= lower;

        if (active) {
          $el.addClass('awxjs__ui-slider-range-mark-text-active');
        } else {
          $el.removeClass('awxjs__ui-slider-range-mark-text-active');
        }
      });
      this.trigger('change', {
        value: Object.assign({}, state.bounds)
      });
    };

    this._onStart = position => {
      const bounds = this.value;

      const value = this._valueAtPosition(position);

      const closest = this._getClosestBound(value);

      const prevMovedHandle = this._getBoundNeedMoving(value, closest);

      this.trigger('change:start', {
        value: this.value
      });
      this.setState({
        handle: prevMovedHandle,
        recent: prevMovedHandle
      });
      const prevValue = bounds[prevMovedHandle];
      if (value === prevValue) return;
      const nextBounds = [...this.state.bounds];
      nextBounds[prevMovedHandle] = value;
      this._lastMovedHandle = prevMovedHandle;

      this._onChange({
        bounds: nextBounds,
        handle: prevMovedHandle
      });
    };

    this._onEnd = (force = false) => {
      const {
        handle
      } = this.state;

      this._removeDocumentEvents();

      if ((0, _utils.isset)(handle) || force) {}

      this.setState({
        handle: null
      });
      this.trigger('change:end', {
        value: this.value
      });
    };

    this._onMove = (e, position) => {
      const {
        bounds,
        handle
      } = this.state;

      const value = this._valueAtPosition(position);

      const previous = bounds[handle];
      if (value === previous) return;

      this._moveTo(value);
    };

    this._onKeyboard = e => {};

    this._onMouseDown = e => {
      const target = e.target;

      const handleTargets = this._handles.map(handle => handle.$el[0]);

      if (handleTargets.indexOf(target) === -1) return;
      e.preventDefault();
      let position = positionInfoForEvent(e).pageX;

      if (isEventFromHandle(e, this._handles.map(handle => handle.$el)) === false) {
        this._dragOffset = 0;
      } else {
        const handlePosition = getHandlePosition(target);
        this._dragOffset = position - handlePosition;
        position = handlePosition;
      }

      this._removeDocumentEvents();

      this._onStart(position);

      this._addDocumentEvents();

      const {
        bounds,
        handle
      } = this.state;

      this._updateTooltip(bounds[handle], handle);

      this._tooltip.show(false);
    };

    this._onMouseUp = e => {
      this._tooltip.hide();

      this._onEnd();
    };

    this._onMouseMove = e => {
      if (!this.ui.rail) {
        this._onEnd();

        return;
      }

      const pos = positionInfoForEvent(e).pageX;

      this._onMove(e, pos - this._dragOffset);
    }; // if `value` is defined, check that it's divisible by the `step value, otherwise we won't
    // be able to show the correct range


    if ((0, _utils.isArray)(this.opts.value)) {
      const [from, to] = this.opts.value;
      const step = this.opts.step;

      if (from % step !== 0) {
        const msg = `[Aeris] The 'value' property passed to the range configuration
					([${from}, ${to}]) does not contain from/to values equally divisible by the
					step value (${step}, which may affect the rendered step range in the
					control.`;
        console.warn(msg.replace(/\s+/g, ' '));
      }
    }

    const initialValue = this.opts.value || Array(...Array(this.opts.count + 1)).map(() => this.opts.range.min);
    const bounds = initialValue.map((v, i) => this._trimAlignValue(v, i));
    this.setState({
      bounds
    });
    this._tooltip = new _Tooltip.default();
    this.update();
  }
  /**
   * Current value, which is an array of values corresponding to the bounds. The first value is
   * the minimum value in the range, whereas the second value in the array is the maximum value.
   *
   * @readonly
   * @type {number[]}
   * @memberof RangeSlider
   */


  get value() {
    const {
      bounds
    } = this.state;
    return bounds;
  }

  set value(bounds) {
    const value = bounds.map((v, i) => this._trimAlignValue(v, i));
    this.setState({
      bounds: value
    });

    this._onBoundsChange(this.state);
  } // public render(data?: any) {
  // 	const { bounds } = this.state;
  // 	if (!bounds) {
  // 		return;
  // 	}
  // 	super.render(data);
  // }


  _render() {
    const {
      bounds
    } = this.state;
    if (!bounds) return null;
    const {
      range: {
        min,
        max
      },
      marks,
      marksEvery,
      step
    } = this.opts;
    const range = max - min;
    const dots = this.opts.dots && step > 1;
    const points = Object.keys(marks).map(parseFloat).filter(value => value >= min && value <= max).sort((a, b) => a - b);

    if (dots) {
      for (let i = min; i <= max; i += step) {
        if (points.indexOf(i) === -1) {
          points.push(i);
        }
      }
    }

    const _marks = marks || {};

    if ((0, _utils.isset)(marksEvery)) {
      let every = 1;
      let modulo = false;

      if ((0, _utils.isString)(marksEvery)) {
        const str = `${marksEvery}`;
        modulo = /^%\s*\d+$/.test(str);
        every = parseInt(str.replace(/\D/, ''), 10);
      } else {
        every = parseInt(`${marksEvery}`, 10);
      }

      let n = min;
      let i = 0;

      while (n <= max) {
        const include = modulo ? n % every === 0 : i % every === 0;

        if (include) {
          const val = `${n}`;

          if (!(0, _utils.isset)(_marks[n])) {
            const formatter = this.opts.marksFormatter;
            _marks[val] = (0, _utils.isset)(formatter) && (0, _utils.isFunction)(formatter) ? formatter(n) : val;
          }
        }

        n += step;
        i += 1;
      } // update `marks` value on the main config


      (0, _utils.set)(this.opts, 'marks', _marks);
    }

    const labels = Object.keys(_marks).map(parseFloat).filter(value => value >= min && value <= max).sort((a, b) => a - b).map(point => {
      const label = _marks[point];

      if ((0, _utils.isEmpty)(label)) {
        return null;
      }

      const offset = `${Math.abs(point - min) / range * 100}%`;
      return `<div
					class="awxjs__ui-slider-range-mark-text"
					style="left:${offset};transform:translateX(-50%);msTransform:translateX(-50%);"
					data-key="${point}"
				>${label}</div>`;
    });
    const steps = points.map(point => {
      const offset = `${Math.abs(point - min) / range * 100}%`;
      return `<div
				class="awxjs__ui-slider-range-dot"
				style="left:${offset};"
				data-key="${point}"
			></div>`;
    }); // generate handle objects and append to container

    this._handles = bounds.map((value, index) => new _SliderHandle.default({
      values: {
        min,
        max,
        current: value
      }
    }));
    return `
			<div class="awxjs__ui-slider-range">
				${this.opts.title ? `<div class="awxjs__ui-slider-range-title">${this.opts.title}</div>` : ''}
				<div class="awxjs__ui-slider-range-inner">
					<div class="awxjs__ui-slider-range-rail"></div>
					<div class="awxjs__ui-slider-range-track"></div>
					<div class="awxjs__ui-slider-range-steps">${steps.join('')}</div>
					<div class="awxjs__ui-slider-range-marks">${labels.join('')}</div>
				</div>
			</div>
		`;
  }

  _afterRender() {
    const {
      bounds
    } = this.state;
    const offsets = bounds.map(value => this._offsetForValue(value));

    if (this.opts.ui) {
      this.setUI(this.opts.ui);

      if (this.ui.marks.children().length > 0) {
        this.$el.addClass('awxjs__ui-slider-range-with-marks');
      }

      this._setupEvents();

      if (this.opts.width > 0) {
        this.ui.inner.width(this.opts.width);
      }

      this._handles.forEach((handle, index) => {
        handle.addTo(this.ui.inner);
        handle.updatePosition(offsets[index]);
      });
    }

    this._onChange(this.state);
  }

  _setupEvents() {
    super._setupEvents();

    this.$el.on('mousedown touchstart', this._onMouseDown);
  }

  _getClosestBound(value) {
    const {
      bounds
    } = this.state;
    let closest = 0;

    for (let i = 1; i < bounds.length - 1; i += 1) {
      if (value > bounds[i]) {
        closest = i;
      }
    }

    if (Math.abs(bounds[closest + 1] - value) < Math.abs(bounds[closest] - value)) {
      closest += 1;
    }

    return closest;
  }

  _getBoundNeedMoving(value, closestBound) {
    const {
      bounds,
      recent
    } = this.state;
    let boundNeedMoving = closestBound;
    const atSamePoint = bounds[closestBound + 1] === bounds[closestBound];

    if (atSamePoint && bounds[recent] === bounds[closestBound]) {
      boundNeedMoving = recent;
    }

    if (atSamePoint && value !== bounds[closestBound + 1]) {
      boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
    }

    return boundNeedMoving;
  }

  _getLowerBound() {
    const {
      bounds
    } = this.state;
    const {
      range: {
        min,
        max
      }
    } = this.opts;

    if (bounds.length === 1) {
      return min;
    }

    return bounds[0];
  }

  _getUpperBound() {
    const {
      bounds
    } = this.state;
    return bounds[bounds.length - 1];
  }

  _getPoints() {
    const {
      marks,
      range: {
        min,
        max
      },
      step
    } = this.opts;
    const cache = this._points;

    if (!cache || cache.marks !== marks || cache.step !== step) {
      const points = Object.assign({}, marks);

      if ((0, _utils.isset)(step)) {
        for (let p = min; p <= max; p += step) {
          points[p] = p;
        }
      }

      const result = Object.keys(points).map(parseFloat);
      result.sort((a, b) => a - b);
      this._points = {
        marks,
        step,
        points: result
      };
    }

    return this._points.points;
  }

  _moveTo(value, isFromKeyboardEvent = false) {
    const {
      handle,
      recent,
      bounds
    } = this.state;
    const target = !(0, _utils.isset)(handle) ? recent : handle;
    const nextBounds = [...bounds];
    nextBounds[target] = value;
    const nextHandle = target;

    this._onChange({
      handle: nextHandle,
      bounds: nextBounds
    }); // if (isFromKeyboardEvent) {
    // }

  }

  _trimAlignValue(value, handle) {
    const {
      range: {
        min,
        max
      }
    } = this.opts;
    const inRange = ensureValueInRange(value, min, max);

    const notConflict = this._ensureValueNotConflict(inRange, handle);

    return ensureValuePrecision(notConflict, this.opts.marks, this.opts.step, this.opts.range.min, this.opts.range.max);
  }

  _ensureValueNotConflict(value, handle) {
    const {
      bounds,
      handle: stateHandle
    } = this.state;
    const allowCross = false;
    handle = !(0, _utils.isset)(handle) ? stateHandle : handle;

    if (!allowCross && (0, _utils.isset)(handle) && (0, _utils.isset)(bounds)) {
      if (handle > 0 && value <= bounds[handle - 1]) {
        return bounds[handle - 1];
      }

      if (handle < bounds.length - 1 && value >= bounds[handle + 1]) {
        return bounds[handle + 1];
      }
    }

    return value;
  }

  _valueAtPosition(pos) {
    const sliderBounds = this.ui.rail.bounds();
    const offset = pos - (sliderBounds.left + window.pageXOffset);

    const nextValue = this._trimAlignValue(this._valueAtOffset(offset));

    return nextValue;
  }

  _valueAtOffset(offset) {
    const {
      range: {
        min,
        max
      }
    } = this.opts;
    const length = this.ui.rail ? this.ui.rail.bounds().width : 0;
    const ratio = Math.abs(Math.max(offset, 0) / length);
    return ratio * (max - min) + min;
  }

  _offsetForValue(value) {
    const {
      range: {
        min,
        max
      }
    } = this.opts;
    const ratio = (value - min) / (max - min);
    return ratio * 100;
  }

  _updateTooltip(value, handle) {
    if ((0, _utils.isEmpty)(this._handles)) return;
    const handleRef = this._handles[handle];
    let str = value.toString();

    if ((0, _utils.isFunction)(this.opts.tooltip)) {
      str = this.opts.tooltip(value);
    }

    this._tooltip.setContent(str).position(handleRef.$el);
  }

  _addDocumentEvents() {
    (0, _DOM.default)(document).on('mousemove touchmove', this._onMouseMove).on('mouseup touchend', this._onMouseUp);
  }

  _removeDocumentEvents() {
    (0, _DOM.default)(document).off('mousemove touchmove', this._onMouseMove).off('mouseup touchend', this._onMouseUp);
  }

}

var _default = RangeSlider;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 341 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;
;

class SliderHandle extends _Component.default {
  constructor(opts) {
    super((0, _utils.extend)({}, opts, {
      className: (0, _utils.get)(opts, 'className') ? `ui-slider-range-handle ${opts.className}` : 'ui-slider-range-handle'
    }));

    this._handleMouseDown = e => {
      this.focus();
    };

    this._handleMouseUp = e => {
      if (document.activeElement === this.$el[0]) {
        this.setClickFocus(true);
      }
    };

    this._handleBlur = e => {
      this.setClickFocus(false);
    };

    this.initialize();
    this.$el.on('mousedown', this._handleMouseDown);
    this.$el.on('blur', this._handleBlur);
    (0, _DOM.default)(document).on('mouseup', this._handleMouseUp);
  }

  initialize(data) {
    super.initialize(data);
    this.updatePosition(0, this.opts);
  }

  setClickFocus(focused) {
    this.setState({
      clickFocused: focused
    });

    if (focused) {
      this.$el.addClass('awxjs__ui-slider-range-handle-click-focused');
    } else {
      this.$el.removeClass('awxjs__ui-slider-range-handle-click-focused');
    }
  }

  clickFocus() {
    this.setClickFocus(true);
    this.focus();
  }

  focus() {
    this.$el[0].focus();
  }

  blur() {
    this.$el[0].blur();
  }

  updatePosition(offset, opts) {
    this.$el.css('left', `${offset}%`);

    if (opts) {
      this.$el.attr('aria-valuemin', opts.values.min);
      this.$el.attr('aria-valuemax', opts.values.max);
      this.$el.attr('aria-valuenow', opts.values.current);
      this.$el.attr('aria-disabled', opts.disabled === true);
    }
  }

  _render(data) {
    return `
			<div class="awxjs__ui-slider-range-handle"></div>
		`;
  }

  _afterRender() {
    this.$el.attr('role', 'slider');

    if ((0, _utils.isset)(this.opts.tabindex)) {
      this.$el.attr('tabindex', this.opts.tabindex);
    }
  }

}

var _default = SliderHandle;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 342 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Button = _interopRequireDefault(__webpack_require__(334));

var _ButtonSegment = _interopRequireDefault(__webpack_require__(343));

var _ButtonSegmentGroup = _interopRequireDefault(__webpack_require__(344));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `SegmentedButton` is a button subclass that also contains a segmented control within the
 * button, which can be used to change the current value of the button or to use as a secondary
 * value associated with the button's value, such as filters.
 *
 * @export
 * @class SegmentedButton
 * @extends {Button<SegmentedButtonOptions, SegmentedButtonState>}
 */
class SegmentedButton extends _Button.default {
  /**
   * Initializes and returns a segmented button instance configured with the specified options.
   *
   * @param {SegmentedButtonOptions} [opts]
   * @memberof SegmentedButton
   */
  constructor(opts) {
    super((0, _utils.extend)({
      filter: false,
      multiselect: false,
      groupMultiselect: true,
      reloadOnChange: true,
      ui: {
        all: '.awxjs__ui-btn-segmented__option-all',
        segments: '.awxjs__ui-btn-segments',
        groups: '.awxjs__ui-btn-segmented__groups'
      }
    }, opts, {
      className: opts.className ? `ui-btn-segmented ${opts.className}` : 'ui-btn-segmented'
    }));
    this._segments = [];
    this._groups = [];
    this._groupsById = {};
    this._value = null;
    this._expanded = false;
    this._handleValueChange = (0, _utils.debounce)((info = {}, triggerEvents = true) => {
      const previousValue = !(0, _utils.isEmpty)(this._value) ? (0, _utils.cloneDeep)(this._value) : [];
      let previousSegmentsInfo;
      const value = this.value; // set previous segments to include in event payload

      if ((0, _utils.isPlainObject)(previousValue)) {
        previousSegmentsInfo = this.segments().filter(segment => {
          let include = false;
          Object.keys(previousValue).forEach(key => {
            if (segment.value === previousValue[key] && segment.groupId === key) {
              include = true;
            }
          });
          return include;
        }).map(segment => segment.info);
      } else if ((0, _utils.isArray)(previousValue)) {
        previousSegmentsInfo = this.segments().filter(segment => previousValue.indexOf(segment.value) !== -1).map(segment => segment.info);
      } // console.log('_handleValueChange', this.segments(), value, previousValue, previousSegmentsInfo);


      this._value = (0, _utils.cloneDeep)(value);

      if (triggerEvents) {
        this.trigger('value:change', {
          value,
          previous: previousValue,
          previousSegments: previousSegmentsInfo,
          reload: this.opts.reloadOnChange
        });
      }

      if (this.opts.onChange) {
        this.opts.onChange(this);
      } // this._value = cloneDeep(value);

    }, 200);
    this._triggerTimeout = null;
  }
  /**
   * Value associated with the currently selected segment(s).
   *
   * @readonly
   * @type {*}
   * @memberof SegmentedButton
   */


  get value() {
    const selected = this.selectedSegments(); // const segments = selected.map((segment) => ({
    // 	...segment.info,
    // 	options: extend({}, this.options, segment.options)
    // }));

    if (this._groups.length > 0) {
      if (!this.opts.groupMultiselect) {
        return this._groups.map(group => group.value).filter(v => !(0, _utils.isEmpty)(v));
      }

      return this._groups.reduce((result, group) => {
        result[group.id] = group.value;
        return result;
      }, {}); // if (this.opts.filter === true) {
      // 	return {
      // 		filters: vals,
      // 		segments,
      // 		reload: this.opts.reloadOnChange
      // 	};
      // }
      // return vals;
    } // if (this.opts.filter === true) {
    // 	return {
    // 		id: this.id,
    // 		value: this.id,
    // 		filters: selected.map((segment) => segment.value).join(';'),
    // 		segments,
    // 		parent: this.id,
    // 		options: this.options
    // 	};
    // }
    // return { segments };


    return selected.map(segment => segment.value);
  }

  set value(value) {
    const arr = !(0, _utils.isArray)(value) ? [value] : value;
    const selected = this.selectedSegments();

    if (value instanceof Array) {
      // select segments from new value
      arr.forEach(v => {
        this.selectSegment(v);
      }); // deselect any segments not included in new value

      selected.forEach(segment => {
        if (arr.indexOf(segment.value) === -1 && arr.indexOf(segment.key) === -1) {
          this.deselectSegment(segment.key);
        }
      });
    } else if (this._groups.length > 0) {
      this._groups.forEach(group => {// group.value = value[group.id];
      });
    }
  }
  /**
   * Returns the button metadata, including identifier, key, current value, and selected segments.
   *
   * @readonly
   * @type {ButtonInfo}
   * @memberof SegmentedButton
   */


  get info() {
    return Object.assign(Object.assign({}, super.info), {
      valueSegments: this.segmentInfo(true),
      filter: this.opts.filter,
      reload: this.opts.filter && this.opts.reloadOnChange
    });
  }
  /**
   * Returns whether the button is currently expanded.
   *
   * @readonly
   * @type {boolean}
   * @memberof SegmentedButton
   */


  get isExpanded() {
    return this._expanded;
  }
  /**
   * Returns whether the segments are configured as filter options.
   *
   * @readonly
   * @type {boolean}
   * @memberof SegmentedButton
   */


  get isFilter() {
    return this.opts.filter;
  }

  size() {
    const size = super.size(); // calculate height if element is currently selected

    if (this.selected) {
      const $target = this.ui.groups || this.ui.segments;
      const maxh = $target.css('max-height');
      $target.css('max-height', 'auto');
      let h = parseFloat(maxh.replace(/[^0-9\.]/, ''));
      h += this.el('.awxjs__ui-btn-label').outerHeight(true);
      $target.css('max-height', maxh);
      const pad = this.$el.padding();
      h += pad.top + pad.bottom;
      const margins = this.$el.margins();
      h += margins.top + margins.bottom;
      size.height = h;
    }

    return size;
  }
  /**
   * Returns an array of child button segment for the button.
   *
   * @returns {ButtonSegment[]}
   * @memberof SegmentedButton
   */


  segments() {
    if (this._groups.length > 0) {
      return this._groups.reduce((result, group) => {
        result = result.concat(group.segments);
        return result;
      }, []);
    }

    return this._segments;
  }
  /**
   * Returns an array of values from the button segments.
   *
   * @returns {string[]}
   * @memberof SegmentedButton
   */


  segmentValues() {
    return this.segments().map(segment => segment.value);
  }
  /**
   * Returns an array of identifiers from the button segments.
   *
   * @returns {string[]}
   * @memberof SegmentedButton
   */


  segmentIds(includeParent = true) {
    return this.segments().map(segment => {
      if (includeParent) {
        return segment.key.replace(/^.+___/, '');
      }

      return segment.id.replace(/^.+___/, '');
    });
  }

  segmentInfo(selectedOnly = false) {
    const segments = selectedOnly ? this.selectedSegments() : this.segments();
    return segments.map(segment => segment.info);
  }
  /**
   * Returns the button segment groups associated with the button.
   *
   * @returns {ButtonSegmentGroup[]}
   * @memberof SegmentedButton
   */


  segmentGroups() {
    return this._groups;
  }
  /**
   * Returns `true` if the button contains a segment option associated with the specified
   * value. This can either be a button segment value or identifier.
   *
   * @param {string} value
   * @returns
   * @memberof SegmentedButton
   */


  containsValue(value) {
    const check = value.replace(/^.+::/, '');
    return this.segmentValues().indexOf(check) > -1 || this.segmentIds().indexOf(check) > -1;
  }

  containsId(id) {
    return this.segmentIds(true).indexOf(id) > -1;
  }
  /**
   * Selects the button segment associated with the specified option. If `select` is `true`, then
   * then parent button will also be selected.
   *
   * @param {string | Record<string, any>} option
   * @param {boolean} [select=true]
   * @memberof SegmentedButton
   */


  selectSegment(option, select = true) {
    this.setSegmentSelected(option, true, select); // if (found && select) {
    // 	// update cached value
    // 	this.select();
    // 	// this._value = { ...this.value };
    // }
  }
  /**
   * Deselects the button segment associated with the specified option.
   *
   * @param {(string | Record<string, any>)} option
   * @memberof SegmentedButton
   */


  deselectSegment(option) {
    this.setSegmentSelected(option, false);
  }

  setSegmentSelected(option, selected, autoSelectParent = false) {
    let found = false;
    const segments = this.segments();

    if (segments && segments.length > 0) {
      segments.forEach(segment => {
        if ((0, _utils.isString)(option)) {
          if (segment.id === option || segment.key === option) {
            if (selected) {
              segment.select();
            } else {
              segment.deselect();
            }

            found = true;
          } else if (this.id === option) {
            found = true;
          }
        } else if ((0, _utils.isPlainObject)(option)) {
          Object.keys(option).forEach(groupId => {
            const group = this._groupsById[groupId];

            if (group) {
              group.segments.forEach(groupSegment => {
                if (groupSegment.id === option || groupSegment.key === option) {
                  if (selected) {
                    segment.select();
                  } else {
                    segment.deselect();
                  }

                  found = true;
                }
              });
            }
          });
        }
      });
    }

    if (found && selected && autoSelectParent) {
      if ((0, _utils.isEmpty)(this._value)) {
        this._value = this.value;
      }

      this.select();
    }

    return found;
  }
  /**
   * Returns the selected button segment(s).
   *
   * @returns {ButtonSegment[]}
   * @memberof SegmentedButton
   */


  selectedSegments() {
    return this.segments().filter(segment => segment.selected);
  }

  _onSelect(trigger = true) {
    if (!this.isExpanded) {
      this._showSegments(true);
    }

    super._onSelect(trigger);
  }

  _onDeselect(trigger = true) {
    if (this.isExpanded) {
      this._showSegments(false);
    }

    super._onDeselect(trigger);
  }

  _render(data) {
    let output = '';
    const segments = (0, _utils.get)(this.opts, 'segments');

    if (segments) {
      if ((0, _utils.isArray)(segments)) {
        this._renderSegments(segments);

        output += `<div class="awxjs__ui-btn-segments"><ul></ul></div>`;
      } else if (segments.groups) {
        this._renderGroups(segments.groups);

        output += `<div class="awxjs__ui-btn-segmented__groups"></div>`;
      }
    }

    return `
			<div class="awxjs__ui-btn-segmented">
				<div class="awxjs__ui-btn-target">
					<div class="awxjs__ui-btn-label">${this.opts.title}</div>
				</div>
				${output}
			</div>
		`;
  }

  _renderSegments(segments) {
    this._segments = (segments || []).map(config => {
      const localConfig = (0, _utils.cloneDeep)(config);
      localConfig.id = localConfig.id || localConfig.value.replace(/\:.+$/, '').replace(/,/, '--').replace(/;/, '__');
      localConfig.options = (0, _utils.extend)({}, this.options, localConfig.options);
      return new _ButtonSegment.default(Object.assign(Object.assign({
        multiselect: this.opts.multiselect
      }, localConfig), {
        loader: false,
        toggleable: this.opts.multiselect === true,
        parent: this.id
      }));
    });
  }

  _renderGroups(groups) {
    if (!(0, _utils.isset)(this._groupsById)) {
      this._groupsById = {};
    }

    this._groups = (groups || []).map((config, index) => {
      const localConfig = (0, _utils.cloneDeep)(config);
      localConfig.id = localConfig.id || `${this.id}-${index}`;
      localConfig.options = (0, _utils.extend)({}, this.options, localConfig.options);
      const group = new _ButtonSegmentGroup.default(Object.assign({
        filter: this.opts.filter,
        multiselect: this.opts.multiselect,
        requiresSelection: this.opts.groupMultiselect === true,
        reloadOnChange: this.opts.reloadOnChange,
        parentId: this.id
      }, localConfig));
      this._groupsById[localConfig.id] = group;
      return group;
    });
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    if (this._groups && this.ui.groups) {
      this._groups.forEach(group => {
        group.addTo(this.ui.groups);
        group.on('change', e => {
          const {
            id,
            value,
            reload
          } = e.data || {};

          if (this.opts.groupMultiselect === false && (0, _utils.isset)(value)) {
            this._groups.forEach(target => {
              if (target.id !== id) {
                target.clear(false);
              }
            });
          }

          this._handleValueChange({
            reload
          });
        });
      });
    } else if (this._segments && this.ui.segments) {
      const $target = (0, _DOM.default)('ul', this.ui.segments);

      this._segments.forEach(segment => {
        segment.addTo($target);
        segment.on("select"
        /* SELECT */
        , e => {
          this._handleSelectSegment(segment, this.selected);
        }).on("deselect"
        /* DESELECT */
        , e => {
          this._handleDeselectSegment(segment, this.selected);
        });
      });
    } // set initial value based on currently selected segments


    this._value = this.value;
  }

  _setupEvents() {
    super._setupEvents(); // this.on('select', () => {
    // 	this._showSegments(true);
    // }).on('deselect', () => {
    // 	this._showSegments(false);
    // });


    if (this.ui.groups) {
      this.ui.groups.on('click', e => {
        e.stopPropagation();
      });
    }
  }

  _handleSelectSegment(segment, triggerEvents = true) {
    const allowMultiselect = this.opts.multiselect && segment.value !== 'all' && segment.multiselect !== false; // this.selectedSegmentsProp('multiselect').forEach((allow) => {
    // 	if (!allow) allowMultiselect = false;
    // })

    if (allowMultiselect === false) {
      this.selectedSegments().forEach(item => {
        if (item.value !== segment.value) {
          item.deselect();
        }
      });
    } else {
      // deselect all segments that don't support multiselect
      this.selectedSegments().forEach(item => {
        if (item.multiselect === false) {
          item.deselect();
        }
      });
    }

    if (this.opts.onSelectSegment) {
      this.opts.onSelectSegment(segment);
    }

    this._handleValueChange({
      reload: this.opts.filter && this.opts.reloadOnChange
    }, triggerEvents);
  }

  _handleDeselectSegment(segment, triggerEvents = true) {
    if (this.state.selected) {
      const selectedCount = this.selectedSegments().length; // console.log('handleDeselectSegment', segment.id, segment.key, segment.value, triggerEvents, selectedCount);

      if (selectedCount === 0) {
        // if no selection and we have non-multiselect options (or 'all'), then select
        // that one instead by default
        if (this.opts.multiselect) {
          let selectedSegment;
          this.segments().forEach(item => {
            if (!selectedSegment && (item.value === 'all' || item.multiselect === false)) {
              item.select();
              selectedSegment = item;
            }
          });
        } else {// this.deselect();
        }
      }

      if (this.opts.onDeselectSegment) {
        this.opts.onDeselectSegment(segment);
      }
    }

    this._handleValueChange({
      reload: this.opts.filter && this.opts.reloadOnChange
    }, triggerEvents);
  }

  _showSegments(show) {
    var _a;

    if (show) {
      if (this._value && this._value.length > 0) {
        this._handleValueChange();
      } else if (this._groups && this._groups.length > 0) {
        let lastSelectedSegment = null;

        this._groups.forEach(group => {
          if (group.segments.length > 0 && (!(0, _utils.isset)(lastSelectedSegment) || this.opts.groupMultiselect === true)) {
            group.segments[0].select();
            lastSelectedSegment = group.segments[0];
          }
        });
      } else {
        const segments = this.segments();
        (_a = segments[0]) === null || _a === void 0 ? void 0 : _a.select();
      }
    }

    let height = 0;
    let collapseTarget = this.ui.segments;

    if (this.ui.groups && this.ui.groups.length > 0) {
      collapseTarget = this.ui.groups;
      height = this.ui.groups.children().reduce((val, el) => {
        val += (0, _DOM.default)(el).outerHeight(true);
        return val;
      }, 0);
    } else {
      height = (0, _DOM.default)('ul', this.ui.segments).height();
    }

    collapseTarget.css({
      'max-height': `${show ? height : 0}px`
    });

    if (this._triggerTimeout) {
      clearTimeout(this._triggerTimeout);
    }

    this._expanded = show;
    this._triggerTimeout = setTimeout(() => {
      const eventName = show ? 'expanded' : 'collapsed';
      this.trigger(eventName);
    }, show ? 0 : 600);
  }

}

var _default = SegmentedButton;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 343 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _utils = __webpack_require__(17);

var _Button = _interopRequireDefault(__webpack_require__(334));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-restricted-globals */
class ButtonSegment extends _Button.default {
  constructor(opts) {
    if (opts.value === 'all') {
      opts.multiselect = false;
    } else if (!(0, _utils.isset)(opts.multiselect)) {
      opts.multiselect = true;
    }

    super(opts);
  }

  get key() {
    return `${this.parentId ? `${this.parentId}::` : ''}${this.groupId ? `${this.groupId}::` : ''}${this.id}`;
  }

  get multiselect() {
    return this.opts.multiselect;
  }

  _render(data) {
    return `
			<li>${this.title}</li>
		`;
  }

}

var _default = ButtonSegment;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 344 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _ButtonSegment = _interopRequireDefault(__webpack_require__(343));

var _globals = __webpack_require__(134);

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ButtonSegmentGroup extends _Component.default {
  constructor(opts) {
    super((0, _utils.extend)({
      reloadOnChange: true
    }, opts, {
      ui: {
        segments: '.awxjs__ui-btn-segments ul'
      }
    }));
    this.storedSegments = [];
  }

  get id() {
    return this.opts.id;
  }

  get parentId() {
    return this.opts.parentId;
  }

  get title() {
    return this.opts.title;
  }

  get value() {
    const values = this.selectedSegments().map(segment => segment.value);

    if (this.opts.multiselect === false) {
      return values.join(',');
    }

    return values;
  }

  get segments() {
    return this.storedSegments;
  }

  setSegments(segments) {
    this.storedSegments = segments;

    if (this.ui.segments) {
      segments.forEach(segment => {
        segment.addTo(this.ui.segments);
        segment.on("select"
        /* SELECT */
        , e => {
          this._handleSelectSegment(segment);
        }).on("deselect"
        /* DESELECT */
        , e => {
          this._handleDeselectSegment(segment);
        });
      });
    }
  }

  selectedSegments() {
    return this.segments.filter(segment => segment.selected);
  }

  clear(triggerEvents = true) {
    this.selectedSegments().forEach(item => {
      item.deselect(triggerEvents);
    });
  }

  _handleSelectSegment(segment) {
    const allowMultiselect = this.opts.multiselect && segment.value !== 'all' && segment.multiselect !== false;

    if (allowMultiselect === false) {
      this.selectedSegments().forEach(item => {
        if (item.value !== segment.value) {
          item.deselect();
        }
      });
    } else {
      // deselect all segments that don't support multiselect
      this.selectedSegments().forEach(item => {
        if (item.multiselect === false) {
          item.deselect();
        }
      });
    }

    this._handleValueChange();
  }

  _handleDeselectSegment(segment) {
    // if no selection and we have non-multiselect options (or 'all'), then select
    // that one instead by default or the first one if no 'all' option
    if (this.selectedSegments().length === 0) {
      if (this.opts.multiselect) {
        let selectedSegment;
        this.segments.forEach(item => {
          if (!selectedSegment && (item.value === 'all' || item.multiselect === false)) {
            item.select();
            selectedSegment = item;
          }
        });
      } else if (this.opts.requiresSelection) {
        this.segments[0].select();
      }
    }

    this._handleValueChange();
  }

  _handleValueChange() {
    if (this.opts.onChange) {
      this.opts.onChange(this);
    } // const previousValue = { ...this._value };
    // const value = this.value;
    // this.trigger('value:change', { value, previous: previousValue });
    // this._value = { ...value };


    this.trigger('change', {
      id: this.id,
      value: this.value,
      reload: this.opts.reloadOnChange
    });
  }

  _render(data) {
    return `
			<div data-group="${this.id}" class="${_globals.Globals.cssPrefix}ui-btn-segmented__group">
				${!(0, _utils.isEmpty)(this.title) ? `<p class="${_globals.Globals.cssPrefix}ui-btn-segmented__group-title">${this.title}</p>` : ''}
				<div class="${_globals.Globals.cssPrefix}ui-btn-segments"><ul></ul></div>
			</div>
		`;
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    const segments = this.opts.segments;
    const result = (segments || []).map(config => {
      const localConfig = (0, _utils.cloneDeep)(config);
      const valueKey = localConfig.value.replace(/\:.+$/, '').replace(/,/, '--').replace(/;/, '__');
      localConfig.id = localConfig.id || valueKey;
      return new _ButtonSegment.default(Object.assign(Object.assign({}, localConfig), {
        loader: false,
        toggleable: this.opts.multiselect === true,
        parent: this.parentId,
        group: this.id
      }));
    });
    this.setSegments(result);
  }

}

var _default = ButtonSegmentGroup;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 345 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _Button = _interopRequireWildcard(__webpack_require__(334));

var _SegmentedButton = _interopRequireDefault(__webpack_require__(342));

var _utils = __webpack_require__(17);

var _globals = __webpack_require__(134);

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;
/**
 * A `ButtonGroup` is a component that triggers an event when clicked and supports a toggleable
 * selected state.
 *
 * @export
 * @class ButtonGroup
 * @extends {Component<T, S>}
 * @template T
 * @template S
 */

class ButtonGroup extends _Component.default {
  /**
   * Initializes and returns a button group instance with the specified configuration options.
   *
   * @param {*} [opts]
   * @memberof ButtonGroup
   */
  constructor(opts) {
    opts = opts || {};
    opts = (0, _utils.extend)({
      defaultType: 'data-item',
      multiselect: true
    }, opts, {
      className: opts.className ? `ui-btn-group ${opts.className}` : 'ui-btn-group',
      ui: {
        label: `.${_globals.Globals.cssPrefix}ui-btn-group-label`,
        buttons: `.${_globals.Globals.cssPrefix}ui-btn-group-items`
      }
    });
    super(opts);
    this._buttons = [];
    this.setState({
      expanded: true
    });
  }

  get id() {
    return (0, _Button.buttonIdentifier)(this.opts.id || this.opts.title);
  }

  get key() {
    return this.id;
  }
  /**
   * Array of button elements included in the group.
   *
   * @readonly
   * @type {Toggleable[]}
   * @memberof ButtonGroup
   */


  get buttons() {
    return this._buttons;
  }
  /**
   * Returns the button from the group associated with the specified identifier, if any.
   *
   * @param {string} id
   * @returns {Toggleable}
   * @memberof ButtonGroup
   */


  buttonForId(id) {
    let result;
    this.buttons.forEach((button, index) => {
      if (button.id === id && !(0, _utils.isset)(result)) {
        result = button;
      }
    });
    return result;
  }

  buttonForKey(key) {
    let result;
    this.buttons.forEach((button, index) => {
      if (button.key === key && !(0, _utils.isset)(result)) {
        result = button;
      }
    });
    return result;
  }
  /**
   * Returns the button from the group associated with the specified value, if any.
   *
   * @param {string} value
   * @returns {Toggleable}
   * @memberof ButtonGroup
   */


  buttonForValue(value) {
    let result;
    this.buttons.forEach((button, index) => {
      if (button.value === value && !(0, _utils.isset)(result)) {
        result = button;
      }
    });
    return result;
  }

  size() {
    const size = super.size();
    let h = 0;

    if (this.ui.label) {
      h += this.ui.label.outerHeight(true);
    }

    this.buttons.forEach(button => {
      h += button.size().height;
    });
    const pad = this.$el.padding();
    const borders = this.$el.borders();
    h += pad.top + pad.bottom;
    h += borders.top + borders.bottom;
    size.height = h;
    return size;
  }

  _render(data) {
    const title = !(0, _utils.isEmpty)(this.opts.title) ? `<div class="${_globals.Globals.cssPrefix}ui-btn-group-label">${this.opts.title}</div>` : '';
    return `
			<div class="awxjs__ui-btn-group">
				${title}
				<div class="${_globals.Globals.cssPrefix}ui-btn-group-items" data-multiselect="${this.opts.multiselect ? 1 : 0}"></div>
			</div>
		`;
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    if (this.opts.buttons) {
      this._buttons = (this.opts.buttons || []).map(opts => {
        opts.parent = this.id;
        opts.options = Object.assign(Object.assign({}, this.opts.options), opts.options); // allow each button to inherit parent controls

        if (this.opts.controls && !(0, _utils.isset)(opts.controls)) {
          opts.controls = (0, _utils.extend)({}, this.opts.controls);
        }

        if (opts.segments) {
          return new _SegmentedButton.default(opts);
        }

        const buttonType = opts.type || this.opts.defaultType;
        return new _Button.default(opts);
      });
    }

    if (this.ui.buttons && this.ui.buttons.children().length === 0) {
      this.buttons.forEach(button => {
        button.addTo(this.ui.buttons);
      });
    }
  }

  _setupEvents() {
    super._setupEvents();

    this.buttons.forEach(button => {
      if (button instanceof _SegmentedButton.default) {
        button.on('expanded collapsed', e => {
          this.trigger('change:size', e.data);
        });
      }
    });

    if (this.opts.multiselect === false) {
      this.buttons.forEach(button => {
        if (button.selected) {
          button.disable(true);
          this._selectedButton = button;
        }

        button.on('select', () => {
          if (this._selectedButton) {
            this._selectedButton.deselect();

            this._selectedButton.disable(false);
          }

          this._selectedButton = button;
          button.disable(true);

          if ((0, _utils.isFunction)(this.opts.onChange)) {
            this.opts.onChange(button.value);
          }

          this.trigger('change', {
            value: button.value
          });
        });
      });
    }
  }

}

var _default = ButtonGroup;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 346 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Panel = _interopRequireDefault(__webpack_require__(331));

var _InfoPanelContentView = _interopRequireDefault(__webpack_require__(347));

var _InfoPanelView = _interopRequireDefault(__webpack_require__(348));

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(302));

var _utils = __webpack_require__(17);

var _layout = __webpack_require__(208);

var icons = _interopRequireWildcard(__webpack_require__(338));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `InfoPanel` is a panel component that is responsible for displaying a variety of content
 * related to map data, such as markers and/or polygons, or requesting and rendering data assocated
 * with a specific geographical coordinate.
 *
 * @export
 * @class InfoPanel
 * @extends {Panel<InfoPanelOptions, InfoPanelState>}
 */
class InfoPanel extends _Panel.default {
  /**
   * Initializes and returns an info panel instance for the specified configuration options.
   *
   * @param {InfoPanelOptions} [opts]
   * @memberof InfoPanel
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      metric: false,
      ui: {
        container: '.awxjs__app__ui-panel-info-container',
        inner: '.awxjs__app__ui-panel-info-inner',
        title: '.awxjs__app__ui-panel-info-title',
        content: '.awxjs__app__ui-panel-info-content',
        close: '.awxjs__app__ui-panel-info-close'
      }
    }, opts);
    opts.className = (0, _utils.isset)(opts.className) ? `app__ui-panel-info ${opts.className}` : 'app__ui-panel-info';
    super(opts);
    this._account = opts.account;
    this._indicator = new _ActivityIndicator.default();
    this.setState({
      visible: false
    });
    this._content = {};
    this.units = opts.metric ? "metric"
    /* Metric */
    : "imperial"
    /* Imperial */
    ;

    if (opts.sections) {
      Object.keys(opts.sections).forEach(key => {
        _InfoPanelView.default.setSection(key, opts.sections[key]);
      });
    }

    if (opts.views) {
      Object.keys(opts.views).forEach((key, index) => {
        const config = opts.views[key];
        const view = this.setContentView(key, config);

        if (view && index === 0) {
          this._contentView = view;
        }
      });
    }
  }

  get units() {
    return this._units;
  }

  set units(value) {
    if (value !== this._units) {
      this._units = value;

      if (this._contentView) {
        this._contentView.units = value;
      }

      this.trigger('change:units', {
        units: value
      });
    }
  }
  /**
   * Shows the info panel with optional title and data. If data is provided, it will be used
   * when rendering the current content view.
   *
   * To change the content view used, see `showContent()`.
   *
   * @param {string} [title]
   * @param {*} [data]
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  show(title, data) {
    this.setState({
      visible: true
    });

    if (data) {
      this.update(data);
    }

    if (title) {
      this.setTitle(title);
    }

    this._updateSize();

    this.ui.content.css({
      opacity: 1
    });
    this.trigger('show');
    return this;
  }
  /**
   * Returns the DOM element container for the view content.
   *
   * @returns {*}
   * @memberof Panel
   */


  getContentContainer() {
    return this.ui.inner;
  }
  /**
   * Shows the info panel using the content view associated with the specified `key` and with
   * optional title and data.
   *
   * @param {string} key The key associated with the content view to use when rendering the panel content
   * @param {string} [title]
   * @param {*} [data]
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  showContent(key, title, data) {
    const view = this._content[key];

    if (view) {
      view.units = this.units;

      if (view !== this._contentView) {
        this.reset();
        this._contentView = view;
      }

      if (!this._contentView.parent()) {
        this._contentView.addTo(this.ui.content);
      }

      if (data) {
        this.update(data);
      }

      this.trigger('change:content', {
        key
      });
      this.show(title, null);
    } else {
      console.error(`[Aeris] Invalid view key '${key}' requested for InfoPanel. Make sure view has been defined in the InfoPanel 'views' configuration.`);
    }

    return this;
  }
  /**
   * Adds a content view option to the panel and associates it with the specified key identifier.
   *
   * @param {string} key
   * @param {InfoPanelContentViewOptions} config
   * @returns {InfoPanelContentView}
   * @memberof InfoPanel
   */


  setContentView(key, config) {
    let view;

    if ((0, _utils.isPlainObject)(config)) {
      view = new _InfoPanelContentView.default(config);
    } else if (config instanceof _InfoPanelContentView.default) {
      view = config;
    }

    if (view) {
      view.on('load:start', () => {
        this._indicator.startAnimating();

        this.ui.content.css({
          opacity: 0
        });
        this.trigger('load:start');
      }).on('load:done', () => {
        this._indicator.stopAnimating();

        this.ui.content.css({
          opacity: 1
        });
        this.trigger('load:done');
      }).on('update', () => {
        this._updateSize();
      }).on('change:units', e => {
        this.units = e.data.units;
      });
      this._content[key] = view;
    }

    return view;
  }
  /**
   * Closes the info panel.
   *
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  close() {
    this._indicator.stopAnimating();

    this.setHeight(0);
    this.ui.content.css({
      opacity: 0
    });
    this.setState({
      visible: false
    });
    this.trigger('close');
    setTimeout(() => {
      this.ui.content.empty();
    }, 500);
    return this;
  }
  /**
   * Sets the current title.
   *
   * @param {string} value
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  setTitle(value) {
    this.ui.title.html(value);
    return this;
  }
  /**
   * Updates the content view using the specified data.
   *
   * @param {*} [data]
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  update(data) {
    if (this._contentView) {
      this._contentView.update(data);
    }

    return this;
  }
  /**
   * Sets the width of the panel.
   *
   * @param {number} width
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  setWidth(width) {
    this.$el.css({
      'max-width': `${width}px`
    });
    return this;
  }
  /**
   * Sets the maximum height for the panel. Depending on the internal content view, the actual
   * rendered height may be less than the value provided.
   *
   * @param {number} height
   * @returns {InfoPanel}
   * @memberof InfoPanel
   */


  setHeight(height) {
    this.$el.css({
      'max-height': `${height}px`
    });
    const innerBounds = this.ui.inner.bounds();

    this._indicator.$el.css({
      'max-height': `${height - innerBounds.top - 75}px`
    });

    return this;
  }
  /**
   * Sets the measurement units to display.
   *
   * @param {boolean} isMetric
   * @memberof InfoPanel
   */


  setMetric(isMetric) {
    this.opts.metric = isMetric;
    this.units = isMetric ? "metric"
    /* Metric */
    : "imperial"
    /* Imperial */
    ;
  }
  /**
   * Loads and renders data for the current content view.
   *
   * @param {*} [params] Parameters to use with the data request (optional)
   * @param {*} [append] Data to append to the loaded data that is also used in the content view (optional)
   * @memberof InfoPanel
   */


  load(params, append) {
    if (this._contentView) {
      this._contentView.load(this._account, params, append);
    } else {
      console.error('[Aeris] Cannot load data for InfoPanel, no active content view defined. Use `showContent(:key, :title, :data)` to set the active content view before calling `load()`.');
    }
  }
  /**
   * Resets the content view.
   *
   * @memberof InfoPanel
   */


  reset() {
    if (this._contentView) {
      this._contentView.remove();
    }

    this.ui.content.empty();
  }

  _render() {
    return `
			<div class="awxjs__app__ui-panel-info">
				<div class="awxjs__app__ui-panel-info-top">
					<div class="awxjs__app__ui-panel-info-title"></div>
				</div>
				<div class="awxjs__app__ui-panel-info-container">
					<div class="awxjs__app__ui-panel-info-inner">
						<div class="awxjs__app__ui-panel-info-content"></div>
					</div>
				</div>
				<button class="awxjs__app__ui-panel-info-close">
					${icons.close()}
				</button>
			</div>
		`;
  } // protected _layout() {
  // 	const $parent = this.parent();
  // 	if ($parent) {
  // 		// if width is less than mobile breakpoint, adjust width so it fits within the view and doesn't overlap
  // 		// the map control elements
  // 		if ($parent.width() < 600) {
  // 			const x = parseFloat(this.$el.css('left').replace(/[^\d-\.]/, ''));
  // 			this.setWidth(Math.min(400, $parent.width() - x * 2));
  // 			this.setHeight(400);
  // 		} else {
  // 			this.$el.css('max-width', 'auto');
  // 			this.setHeight($parent.height() - 100);
  // 		}
  // 	}
  // }
  // protected _shouldLayout(): boolean {
  // 	const $parent = this.parent();
  // 	if ($parent) {
  // 		return $parent.width() < 600;
  // 	}
  // 	return super._shouldLayout();
  // }


  _setupEvents() {
    super._setupEvents();

    this._indicator.appendTo(this.ui.inner);

    this.ui.close.on('click', () => {
      this.close();
    });
  }

  _updateSize() {
    if (!this.visible) return; // const size = windowSize();

    const parent = this.$el.parent();

    if (!parent) {
      return;
    }

    const parentBounds = parent.bounds(true);
    const bounds = this.$el.bounds(true);
    const innerBounds = this.ui.inner.bounds(true);
    const offset = bounds.top - parentBounds.top;
    let maxh = parentBounds.height - offset * 2 - 100;
    let h = Math.max(175, innerBounds.height + (innerBounds.top - bounds.top));
    if (maxh > 900) maxh = 900;
    const vp = (0, _layout.viewportSizeClass)(); // if width is less than mobile breakpoint, adjust width so it fits within the view and doesn't overlap
    // the map control elements

    if (vp.width === 'compact') {
      this.setWidth(parentBounds.width - bounds.left * 2);
      h = parentBounds.height * 0.5;
    } else if (bounds.width > parentBounds.width * 0.3) {
      this.setWidth(Math.max(300, Math.ceil(parentBounds.width * 0.3)));
    } else {
      this.setWidth(400);
    }

    if (this.$el.width() <= 320) {
      this.$el.addClass('awxjs__app__ui-panel-info-compact');
    } else {
      this.$el.removeClass('awxjs__app__ui-panel-info-compact');
    }

    this.setHeight(Math.min(maxh, h));
  }

}

var _default = InfoPanel;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 347 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _InfoPanelView = _interopRequireDefault(__webpack_require__(348));

var _View = _interopRequireDefault(__webpack_require__(333));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `InfoPanelContentView` is a view component that manages and renders a series of individual
 * views to display within as an info panel's content. This object also requests remote data
 * required for the view as needed.
 *
 * @export
 * @class InfoPanelContentView
 * @extends {View<InfoPanelContentViewOptions>}
 */
class InfoPanelContentView extends _View.default {
  /**
   * Initializes and returns an info panel content view configured with the specified options.
   *
   * @param {InfoPanelContentViewOptions} [opts]
   * @param {*} [data]
   * @memberof InfoPanelContentView
   */
  constructor(opts, data) {
    opts = (0, _utils.extend)({
      units: "imperial"
      /* Imperial */
      ,
      className: opts.className ? `app__ui-panel-info__content-view ${opts.className}` : 'app__ui-panel-info__content-view'
    }, opts);
    super(opts, data);
    this.units = opts.units;

    if ((0, _utils.isArray)(opts.views)) {
      this._views = [];
      opts.views.forEach(view => {
        if ((0, _utils.isPlainObject)(view)) {
          const config = view;
          view = new _InfoPanelView.default(config);
        }

        if (view instanceof _InfoPanelView.default) {
          this._views.push(view);
        }
      });
    }
  }
  /**
   * Array of views associated with the content view.
   *
   * @readonly
   * @type {InfoPanelView[]}
   * @memberof InfoPanelContentView
   */


  get views() {
    return this._views;
  }

  get units() {
    return this._units;
  }

  set units(value) {
    if (value !== this._units) {
      this._units = value;
      this.trigger('change:units', {
        units: value
      });
      this.update();
    }
  }
  /**
   * Requests data for the content view and renders the view with the new data.
   *
   * @param {*} [params] Parameters to use with the data request (optional)
   * @param {*} [append] Data to append to the loaded data that is also used in the content
   * view (optional)
   * @memberof InfoPanelContentView
   */


  load(account, params, append) {
    let request = (0, _utils.isFunction)(this.opts.request) ? this.opts.request(append) : this.opts.request; // if no request defined for the content view, iterate through each section view and determine if there are requests
    // defined per each to build a single request from

    if (!request) {
      const requests = [];

      this._views.forEach(view => {
        if (view.request && (0, _utils.isFunction)(view.request)) {
          const result = view.request(account, params, view.opts.config);

          if (result) {
            requests.push(result);
          }
        }
      });

      if (requests.length > 0) {
        request = account.api();
        requests.forEach(r => {
          if (r.requests && r.requests.length > 0) {
            r.requests.forEach(rr => request.addRequest(rr));
          } else {
            request.addRequest(r);
          }
        });
      }
    }

    if (request) {
      if (params) {
        request.setParams(params);
      }

      this.trigger('load:start');
      request.get().then(result => {
        let data = result.data || {}; // handle batch request by grouping data keyed by endpoint path

        if (data.responses && data.responses.length > 0) {
          const sections = {};
          data.responses.forEach(response => {
            const key = response.request.replace(/\?.*$/, '').replace(/^\//, '').replace(/(\/|,)/g, '_');
            sections[key] = response.response;
          });
          data = sections;
        }

        data = Object.assign(Object.assign({}, data), append);
        this.update(data);
        this.trigger('load:done');
      }).catch(error => {
        console.error('awxjs.InfoPanelContentView.load', error);
      });
    } else if (append) {
      this.update(append);
    }
  }

  update(data) {
    super.update(data, false);

    if (!(0, _utils.isset)(this.data) || Object.keys(this.data).length === 0) {
      return;
    }

    if (this.$el) {
      if (this.views) {
        this.views.forEach((view, index) => {
          const viewData = this._dataForView(view);

          if (view.isMounted === false) {
            this._renderView(view, data, index);
          } else if (view.static !== true) {
            view.update(viewData);
          }
        });

        this._afterRender();
      }
    }
  }

  _render(data) {
    return `
			<div class="awxjs__app__ui-panel-info__content-view"></div>
		`;
  }

  _renderView(view, data = {}, index = -1) {
    const viewData = this._dataForView(view); // const allow = isset(viewData) && ((isPlainObject(viewData) && Object.keys(viewData).length > 0) || (isArray(viewData) && viewData.length > 0));


    view.update(viewData);
    view.addToContentView(this, index);
  }

  _dataForView(view) {
    const data = this.data;
    const viewData = (0, _utils.isFunction)(view.opts.data) ? view.opts.data((0, _utils.cloneDeep)(data), view.opts.config) : data;

    if (viewData) {
      viewData.units = this.units;
    }

    return viewData;
  }

  _afterRender() {
    if (this.$el.parent()) {
      this.trigger('update');
    }
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    const data = this.data;

    if (this.views) {
      this.views.forEach(view => this._renderView(view, data));
    }
  }

}

var _default = InfoPanelContentView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 348 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _View = _interopRequireDefault(__webpack_require__(333));

var _utils = __webpack_require__(17);

var _defaultInfoPanelViews = _interopRequireDefault(__webpack_require__(349));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `InfoPanelView` is a view component that renders content associated with a single dataset or
 * content type within an info panel's content view.
 *
 * @export
 * @class InfoPanelView
 * @extends {View<InfoPanelViewOptions>}
 */
class InfoPanelView extends _View.default {
  /**
   * Initializes and returns an info panel view instance configured with the specified
   * configuration options and optional data.
   *
   * @param {InfoPanelViewOptions} [opts]
   * @param {*} [data]
   * @memberof InfoPanelView
   */
  constructor(opts, data) {
    opts = (0, _utils.extend)({}, opts, {
      className: opts.className ? `app__ui-panel-info__view ${opts.className}` : 'app__ui-panel-info__view'
    });

    if ((0, _utils.isString)(opts.renderer)) {
      const section = InfoPanelView.getSection(opts.renderer);

      if (section) {
        opts = (0, _utils.extend)({}, section, opts, {
          renderer: section.renderer
        });
      }
    }

    if (opts.id) {
      opts.className += ` awxjs__app__ui-panel-info__view-${opts.id}`;
    }

    super(opts, data);
  }

  get static() {
    return this.opts.static;
  }

  get request() {
    return this.opts.request;
  }

  addToContentView(view, index = -1) {
    const initializer = this.opts.init;
    this.addTo(view.$el, false, index);

    if (initializer && (0, _utils.isFunction)(initializer)) {
      initializer(this, view);
    }
  }
  /** Class Methods */

  /**
   * Adds a view to the cache using the specified key identifier.
   *
   * @static
   * @param {string} key
   * @param {InfoPanelSectionView} section
   * @memberof InfoPanelView
   */


  static setSection(key, section) {
    _defaultInfoPanelViews.default[key] = section;
  }
  /**
   * Returns the cached view associated with the key identifier, if any.
   *
   * @static
   * @param {string} key
   * @returns {InfoPanelSectionView}
   * @memberof InfoPanelView
   */


  static getSection(key) {
    return _defaultInfoPanelViews.default[key];
  }

  _render(data) {
    let content = '';
    let renderer = this.opts.renderer;

    if (this.opts.requiresData && (0, _utils.isEmpty)(data)) {
      renderer = null;
    }

    if (renderer) {
      // update renderer to account for title and passing renderers to render function
      const sections = Object.keys(_defaultInfoPanelViews.default).reduce((previous, key) => {
        previous[key] = _defaultInfoPanelViews.default[key].renderer;
        return previous;
      }, {}); // if (this.opts.requiresData && isEmpty(data)) {
      // 	return '';
      // }

      const title = this.opts.title ? `<div class="awxjs__app__ui-panel-info__view-title">${this.opts.title}</div>` : '';

      if ((0, _utils.isFunction)(renderer)) {
        const renderFn = renderer;
        content = `
					${title}
					${renderFn(data || {}, sections)}
				`;
      } else if ((0, _utils.isString)(renderer)) {
        content = `
					${title}
					${renderer}
				`;
      }
    }

    return `
			<div class="awxjs__${this.opts.className}">${content}</div>
		`;
  }

}
/**
 * Built-in views keyed by unique type identifiers.
 *
 * @static
 * @memberof InfoPanelView
 */


InfoPanelView.cached = _defaultInfoPanelViews.default;
var _default = InfoPanelView;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 349 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _units = __webpack_require__(182);

var _utils = __webpack_require__(254);

var _Switch = _interopRequireDefault(__webpack_require__(350));

var _utils2 = __webpack_require__(17);

var _strings = __webpack_require__(133);

var _Indices = __webpack_require__(351);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const cachedInfoPanelViews = {
  units: {
    id: 'units',
    static: true,
    renderer: data => `
			<div class="awxjs__app__ui-panel-info__units">
				<div class="awxjs__ui-cols align-center justify-between">
					<div class="label">Units</div>
					<div class="control"></div>
				</div>
			</div>
		`,
    init: (view, contentView) => {
      const control = new _Switch.default({
        values: [{
          label: 'Imperial',
          value: "imperial"
          /* Imperial */

        }, {
          label: 'Metric',
          value: "metric"
          /* Metric */

        }]
      });

      const update = () => {
        if (contentView.units === "metric"
        /* Metric */
        ) {
            control.select();
          } else {
          control.deselect();
        }
      };

      contentView.on('change:units', e => {
        update();
      });
      control.addTo(view.el('.control'));
      control.on('select', () => {
        contentView.units = "metric"
        /* Metric */
        ;
      }).on('deselect', () => {
        contentView.units = "imperial"
        /* Imperial */
        ;
      });
      update();
    }
  },
  place: {
    id: 'place',
    requiresData: true,
    request: (account, data) => account.api().endpoint('places'),
    data: data => {
      if ((0, _utils2.isEmpty)(data)) return null;
      data = data.places || data;
      return data.place;
    },
    renderer: data => `
			<div class="awxjs__app__ui-panel-info__place">
				<div class="awxjs__app__ui-panel-info__place-name">${data.name}${!(0, _utils2.isEmpty)(data.state) ? `, ${data.state}` : ''}, ${data.country}</div>
			</div>
		`
  },
  obs: {
    id: 'observations',
    requiresData: true,
    request: (account, data) => account.api().endpoint('conditions'),
    data: data => {
      var _a;

      if ((0, _utils2.isEmpty)(data)) return null;
      data = data.observations || data; // handle conditions

      if (((_a = data.conditions) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        const result = data.conditions[0] || [];
        return result.periods[0];
      }

      return data.ob;
    },
    renderer: data => {
      const date = (0, _utils2.dateFromISO)(data.dateTimeISO);
      const metric = data.units === "metric"
      /* Metric */
      ;
      return `
				<div class="awxjs__app__ui-panel-info__obs">
					<div class="awxjs__app__ui-panel-info__obs-timestamp">Last updated at ${(0, _utils2.formatDate)(date, metric ? 'HH:mm, MMM d, yyyy' : 'h:mm a, MMM dd, yyyy')}</div>
					<div class="awxjs__ui-cols">
						<div>
							<div class="awxjs__ui-cols">
								<div>
									<div class="awxjs__app__ui-panel-info__obs-temp">${(0, _units.formatDataValue)(data, 'tempF', 'tempC', metric) || 'N/A'}</div>
								</div>
								<div>
									<img class="awxjs__app__ui-panel-info__obs-icon" src="https://cdn.aerisapi.com/wxblox/icons/${data.icon || 'na.png'}">
								</div>
							</div>
							<div class="awxjs__app__ui-panel-info__obs-wx">${data.weatherPrimary}</div>
						</div>
						<div class="awxjs__app__ui-panel-info__obs-details">
							<div class="awxjs__ui-row">
								<div>Winds</div>
								<div>${data.windSpeedMPH > 0 ? `${(0, _units.formatDataValue)(data, 'windSpeedMPH', 'windSpeedKPH', metric)}` : `Calm`}</div>
							</div>
							<div class="awxjs__ui-row">
								<div>Dew Point</div>
								<div>${(0, _units.formatDataValue)(data, 'dewpointF', 'dewpointC', metric)}</div>
							</div>
							<div class="awxjs__ui-row">
								<div>Humidity</div>
								<div>${(0, _units.formatDataValue)(data, 'humidity')}</div>
							</div>
							<div class="awxjs__ui-row">
								<div>Pressure</div>
								<div>${(0, _units.formatDataValue)(data, 'pressureIN', 'pressureMB', metric)}</div>
							</div>
							<div class="awxjs__ui-row">
								<div>Visibility</div>
								<div>${(0, _units.formatDataValue)(data, 'visibilityMI', 'visibilityKM', metric)}</div>
							</div>
							<div class="awxjs__ui-row">
								<div>Sky Cover</div>
								<div>${(0, _units.formatDataValue)(data, 'sky')}</div>
							</div>
						</div>
					</div>
				</div>
			`;
    }
  },
  forecast: {
    id: 'forecast',
    requiresData: true,
    request: (account, data) => {
      const forecastFields = `
					timestamp,dateTimeISO,tempF,tempC,icon,weatherPrimary,windSpeedMPH,windSpeedKPH,windSpeedMinMPH,windSpeedMinKPH,
					windSpeedMaxMPH,windSpeedMaxKPH,windGustMPH,windGustKPH,snowIN,snowCM,precipIN,precipMM
				`.split(',').map(key => `periods.${key}`);
      return account.api().endpoint('forecasts').fields(forecastFields.join(',')).filter('3hr').limit(7);
    },
    data: data => {
      if ((0, _utils2.isEmpty)(data)) return null;
      data = data.forecasts || data;

      if (data) {
        if (data[0]) data = data[0];
        data = data.periods;
      }

      return {
        periods: data || []
      };
    },
    renderer: data => {
      const metric = data.units === "metric"
      /* Metric */
      ;
      return data.periods.map(period => {
        const date = (0, _utils2.dateFromISO)(period.dateTimeISO);
        let winds = 'Calm';

        if (period.windSpeedMaxMPH > 5) {
          if (metric) {
            winds = `${(0, _utils2.toRangeStr)(period.windSpeedMinKPH, period.windSpeedMaxKPH, 5)} ${(0, _units.unitsForDataType)('speed', true)}`;
          } else {
            winds = `${(0, _utils2.toRangeStr)(period.windSpeedMinMPH, period.windSpeedMaxMPH, 5)} ${(0, _units.unitsForDataType)('speed', false)}`;
          }
        } else if (period.windSpeedMaxMPH < 5 && period.windSpeedMinMPH > 0) {
          winds = metric ? '< 8 kmh' : '< 5 mph';
        }

        return `
					<div class="awxjs__app__ui-panel-info__forecast">
						<div class="awxjs__app__ui-panel-info__forecast-period">
							<div class="awxjs__ui-cols align-center">
								<div class="awxjs__app__ui-panel-info__forecast-ts">${(0, _utils2.formatDate)(date, metric ? 'HH:00' : 'h a')}</div>
								<div><img class="awxjs__app__ui-panel-info__forecast-icon" src="https://cdn.aerisapi.com/wxblox/icons/${period.icon || 'na.png'}"></div>
								<div class="awxjs__app__ui-panel-info__forecast-temp">${(0, _units.formatDataValue)(period, 'tempF', 'tempC', metric)}</div>
								<div class="awxjs__app__ui-panel-info__forecast-conditions">
									<div class="awxjs__app__ui-panel-info__forecast-wx">${period.weatherPrimary}</div>
									<div class="awxjs__app__ui-panel-info__forecast-detail"><span>Winds</span> ${winds}</div>
								</div>
							</div>
						</div>
					</div>
				`;
      }).join('');
    }
  },
  alerts: {
    id: 'alerts',
    requiresData: true,
    request: (account, data) => account.api().endpoint('alerts').fields('details.type,details.name,timestamps'),
    data: data => {
      if ((0, _utils2.isEmpty)(data)) return null; // add parent places.profile to each alert so we can do proper timezone conversions

      const profile = (0, _utils2.get)(data, 'places.profile');
      if (data.alerts) data = data.alerts;

      if ((0, _utils2.isArray)(data)) {
        return data.map(record => (0, _utils2.extend)(record, {
          profile
        }));
      }

      return null;
    },
    renderer: data => {
      const metric = data.units === "metric"
      /* Metric */
      ;
      const alerts = data.map(alert => {
        let range = '';
        const ts = alert.timestamps;

        if (ts) {
          const offset = (0, _utils2.get)(alert, 'profile.tzoffset') ? (0, _utils2.get)(alert, 'profile.tzoffset') * 1000 : 0;
          const utcOffset = new Date().getTimezoneOffset() * 60000;
          const tzShift = utcOffset + offset;
          const tz = (0, _utils2.get)(alert, 'profile.tzname') || ''; // need to add timezone offset difference between the local and alert timezones

          const now = new Date(new Date().getTime() + tzShift);
          const start = new Date(new Date(ts.begins * 1000).getTime() + tzShift);
          const end = new Date(new Date(ts.expires * 1000).getTime() + tzShift);
          const fmt = metric ? `HH:00 [${tz}], ddd M/d` : `h:mm a '${tz}', EEE M/d`;

          if (start.getTime() < now.getTime()) {
            range = ` until ${(0, _utils2.formatDate)(end, fmt)}`;
          } else {
            range = ` from ${(0, _utils2.formatDate)(start, fmt)} until ${(0, _utils2.formatDate)(end, fmt)}`;
          }
        }

        return `
					<div class="awxjs__app__ui-panel-info__alert">
						<span class="awxjs__app__ui-panel-info__alert-name"><strong>${(0, _strings.ucwords)(alert.details.name.toLowerCase())}</strong></span>
					<br>${range}</div>
				`;
      }).join('');
      return `<div class="awxjs__app__ui-panel-info__alerts">${alerts}</div>`;
    }
  },
  threats: {
    id: 'threats',
    requiresData: true,
    request: (account, data) => account.api().endpoint('threats').radius('50mi'),
    data: data => (0, _utils2.get)(data, 'threats.0.periods.0.storms'),
    renderer: data => (0, _utils.renderWithFallback)(threat => `<div class="awxjs__app__ui-panel-info__threats"><div class="awxjs__app__ui-panel-info__threats-row">${(0, _strings.formatDirections)(threat.phrase.long)}</div></div>
		`, data)
  },
  outlook: {
    id: 'outlook',
    requiresData: true,
    request: (account, data) => account.api().endpoint('phrases/summary'),
    data: data => (0, _utils2.get)(data, 'phrases_summary.0'),
    renderer: data => (0, _utils.renderWithFallback)(outlook => {
      const metric = outlook.units === "metric"
      /* Metric */
      ;
      return `<div class="awxjs__app__ui-panel-info__outlook">${metric ? (0, _utils2.get)(outlook, 'phrases.longMET') : (0, _utils2.get)(outlook, 'phrases.long')}</div>`;
    }, data)
  },
  hazards: {
    id: 'hazards',
    requiresData: true,
    config: {
      lightning: false
    },
    request: (account, data, config = {}) => {
      if (!(0, _utils2.isset)(data.p)) {
        return undefined;
      }

      const request = account.api();
      const forecastFields = `
					timestamp,dateTimeISO,tempF,tempC,icon,weatherPrimary,windSpeedMPH,windSpeedKPH,windSpeedMinMPH,windSpeedMinKPH,
					windSpeedMaxMPH,windSpeedMaxKPH,windGustMPH,windGustKPH,snowIN,snowCM,precipIN,precipMM
				`.split(',').map(key => `periods.${key}`);
      request.addRequest(account.api().endpoint('forecasts').fields(forecastFields.join(',')).filter('3hr').limit(7));
      request.addRequest(account.api().endpoint('observations'));
      request.addRequest(account.api().endpoint('convective/outlook').action("contains"
      /* CONTAINS */
      ));

      if (config.lightning) {
        request.addRequest(account.api().endpoint('lightning/summary').action("closest"
        /* CLOSEST */
        ).radius('60mi').limit(100));
      }

      return request;
    },
    data: (data, config = {}) => {
      if ((0, _utils2.isEmpty)(data)) {
        return undefined;
      }

      const ob = (0, _utils2.get)(data, 'observations.ob') || {};
      const forecasts = (0, _utils2.get)(data, 'forecasts');
      const convective = (0, _utils2.get)(data, 'convective_outlook_contains');
      const lightning = (0, _utils2.get)(data, 'lightning_summary_closest');

      if ((0, _utils2.isEmpty)(ob) && (0, _utils2.isEmpty)(forecasts)) {
        return undefined;
      }

      const result = [];

      if (forecasts && forecasts.length > 0) {
        const periods = forecasts[0].periods;
        let snow = 0;
        let rain = 0;
        let wind = 0;
        let ice = 0;

        if (ob) {
          if (ob.tempF <= 30 && /snow/.test(ob.weatherPrimary) === false) {
            ice += ob.precipIN;
          }
        }

        periods.forEach(period => {
          snow += period.snowIN;
          wind = Math.max(wind, period.windGustMPH);

          if (period.tempF >= 30) {
            rain += period.precipIN;
          }

          if (period.tempF >= 28 && period.tempF <= 32) {
            ice += period.precipIN;
          }
        });
        result.push({
          type: 'snow',
          name: 'Snow',
          value: snow
        });
        result.push({
          type: 'ice',
          name: 'Ice',
          value: ice
        });
        result.push({
          type: 'rain',
          name: 'Rain',
          value: rain
        });
        result.push({
          type: 'wind',
          name: 'Wind',
          value: wind
        });
      }

      if (convective && convective.length > 0) {
        const risk = convective[0].details.risk;
        result.push({
          type: 'convective',
          name: 'Convective',
          value: risk.type
        });
      } else {
        result.push({
          type: 'convective',
          name: 'Convective',
          value: 'none'
        });
      }

      if (config.lightning === true) {
        if (lightning) {
          const count = (0, _utils2.get)(lightning[0] || lightning, 'summary.pulse.count');
          result.push({
            type: 'lightning',
            name: 'Lightning',
            value: count
          });
        } else {
          result.push({
            type: 'lightning',
            name: 'Lightning',
            value: 0
          });
        }
      }

      return result;
    },
    renderer: data => {
      const hazards = data.map(hazard => {
        const index = (0, _Indices.valueForIndice)(hazard.type, hazard.value) || 0;
        const percent = Math.round(index / 5 * 1000) / 10;
        const indexStr = `${index}`.replace(/\./g, 'p'); // determine impact level based on percentage

        let level = 'None';
        if (percent >= 80) level = 'Major';else if (percent >= 60) level = 'High';else if (percent >= 40) level = 'Moderate';else if (percent >= 20) level = 'Low';else if (percent > 0) level = 'Minimal';
        return `
					<div class="awxjs__app__ui-panel-info__hazard awxjs__ui-cols align-center">
						<div class="awxjs__app__ui-panel-info__hazard-label">${hazard.name}</div>
						<div class="awxjs__app__ui-panel-info__hazard-bar">
							<div class="awxjs__app__ui-panel-info__hazard-bar-inner">
								<div class="awxjs__app__ui-panel-info__hazard-bar-progress awxjs__app__ui-panel-info__hazard-indice-fill-${indexStr}" style="width:${percent}%;"></div>
							</div>
						</div>
						<div class="awxjs__app__ui-panel-info__hazard-value awxjs__app__ui-panel-info__hazard-value-${indexStr}">${level}</div>
					</div>
				`;
      });
      return `<div class="awxjs__app__ui-panel-info__hazards">${hazards.join('')}</div>`;
    }
  }
};
var _default = cachedInfoPanelViews;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 350 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Button = _interopRequireDefault(__webpack_require__(334));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

class Switch extends _Button.default {
  /**
   * Current value based on the switch selected state.
   *
   * @readonly
   * @type {*}
   * @memberof Switch
   */
  get value() {
    let value = this.opts.value;
    const {
      values
    } = this.opts;

    if (values) {
      values.forEach((v, index) => {
        if (this.selected && index === 1) {
          value = v.value || v;
        } else if (!this.selected && index === 0) {
          value = v.value || v;
        }
      });
    }

    return value;
  }
  /**
   * Initializes and returns a switch control instance with the specified configuration options.
   *
   * @param {*} [opts]
   * @memberof Switch
   */


  constructor(opts) {
    opts = (0, _utils.extend)({
      loader: false
    }, opts, {
      className: opts.className ? `ui-switch ${opts.className}` : 'ui-switch'
    }); // normalize values array

    if (opts.values) {
      opts.values = opts.values.map(v => {
        if (!(0, _utils.isPlainObject)(v)) {
          return {
            label: v,
            value: v
          };
        }

        return v;
      });
    }

    super(opts);
  }

  _render(data) {
    const {
      label,
      values
    } = this.opts;
    const labels = {
      left: '',
      right: ''
    };

    if (values) {
      values.forEach((v, index) => {
        const key = index === 0 ? 'left' : 'right';
        let content = '';

        if ((0, _utils.isPlainObject)(v)) {
          content = v.label;
        } else {
          content = v;
        }

        labels[key] = `<div class="awxjs__ui-switch-label awxjs__ui-switch-label-${key}">${content}</div>`;
      });
    }

    return `
			<div class="awxjs__ui-switch">
				${label ? `<div class="awxjs__ui-switch-label">${label}</div>` : ''}
				${labels.left}
				<div class="awxjs__ui-switch__control">
					<div class="awxjs__ui-switch__control-indicator"></div>
				</div>
				${labels.right}
			</div>
		`;
  }

}

var _default = Switch;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 351 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.valueForIndice = exports.Indices = void 0;
var Indices;
exports.Indices = Indices;

(function (Indices) {
  ;

  Indices.snow = value => {
    if (value >= 4) return 5;
    if (value >= 3) return 4;
    if (value >= 2) return 3;
    if (value >= 1) return 2;
    if (value > 0.1) return 1;
    return 0;
  };

  Indices.ice = value => {
    if (value >= 0.4) return 5;
    if (value >= 0.3) return 4;
    if (value >= 0.2) return 3;
    if (value >= 0.1) return 2;
    if (value < 0.1 && value > 0) return 1;
    return 0;
  };

  Indices.rain = value => {
    if (value >= 1) return 5;
    if (value >= 0.75) return 4;
    if (value >= 0.5) return 3;
    if (value >= 0.25) return 2;
    if (value >= 0.1) return 1;
    return 0;
  };

  Indices.wind = value => {
    if (value >= 50) return 5;
    if (value >= 40) return 4;
    if (value >= 30) return 3;
    if (value >= 20) return 2;
    if (value > 10) return 1;
    return 0;
  };

  Indices.lightning = value => {
    if (value >= 80) return 5;
    if (value >= 60) return 4;
    if (value >= 40) return 3;
    if (value >= 15) return 2;
    if (value < 15 && value > 0) return 1;
    return 0;
  };

  Indices.convective = value => {
    const mapping = {
      high: 5,
      moderate: 4,
      enhanced: 3,
      slight: 2,
      marginal: 1,
      general: 0.5,
      none: 0
    };
    return mapping[value];
  };
})(Indices || (exports.Indices = Indices = {}));

;

const valueForIndice = (type, value) => {
  if (type === "snow"
  /* SNOW */
  ) {
      return Indices.snow(value);
    }

  if (type === "ice"
  /* ICE */
  ) {
      return Indices.ice(value);
    }

  if (type === "rain"
  /* RAIN */
  ) {
      return Indices.rain(value);
    }

  if (type === "wind"
  /* WIND */
  ) {
      return Indices.wind(value);
    }

  if (type === "lightning"
  /* LIGHTNING */
  ) {
      return Indices.lightning(value);
    }

  if (type === "convective"
  /* CONVECTIVE */
  ) {
      return Indices.convective(value);
    }

  return 0;
};

exports.valueForIndice = valueForIndice;

/***/ }),
/* 352 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Panel = _interopRequireDefault(__webpack_require__(331));

var _TimeSlider = _interopRequireDefault(__webpack_require__(353));

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(302));

var _RangeSlider = _interopRequireDefault(__webpack_require__(340));

var _Tooltip = _interopRequireDefault(__webpack_require__(336));

var _utils = __webpack_require__(17);

var _layout = __webpack_require__(208);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `TimelinePanel` is a panel component that renders and manages a timeline animation slider
 * control that allows a user to scrub an animation's current time position and change the
 * animation start/end time range.
 *
 * @export
 * @class TimelinePanel
 * @extends {Panel<TimelinePanelOptions, PanelState>}
 */
class TimelinePanel extends _Panel.default {
  /**
   * Initializes and returns a timeline panel instance configured with the specified animation and options.
   * @param {Animation} animation
   * @param {TimelinePanelOptions} [opts]
   * @memberof TimelinePanel
   */
  constructor(animation, opts) {
    super((0, _utils.extend)({
      className: `app__ui-panel-timeline${!(0, _utils.isEmpty)(opts.className) ? ` ${opts.className}` : ''}`,
      range: {},
      formatters: {
        time: 'h:mm a',
        day: 'EEE, MMM d'
      },
      ui: {
        left: '.awxjs__app__ui-panel-timeline-left',
        center: '.awxjs__app__ui-panel-timeline-center',
        right: '.awxjs__app__ui-panel-timeline-right',
        controls: '.awxjs__app__ui-panel-timeline-center',
        timeline: '.awxjs__app__ui-panel-timeline-right',
        play: '.awxjs__ui-btn-play',
        now: '.awxjs__ui-btn-now',
        time: '.awxjs__app__ui-panel-timeline-daytime',
        settings: '.awxjs__ui-btn-settings'
      },
      icon: `
				<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 96.3 85.4">
					<g>
						<path d="M75.2,39.9h9.4v5.2h-9.4L75.2,39.9z"/>
						<path d="M49,64.9h5.2v9.4H49V64.9z"/>
						<path d="M65.5,24.9l6.6-6.6l3.7,3.7l-6.6,6.6L65.5,24.9z"/>
						<path d="M69.2,56.5l6.6,6.6l-3.7,3.7l-6.6-6.6L69.2,56.5z"/>
						<path d="M36.6,56.7l12.4-12.4l0-25.1h8v28.3c-0.6,0.6-14.8,14.9-14.8,14.9L36.6,56.7z"/>
						<path d="M53.6,0v7.5c19.4,0,35.2,15.8,35.2,35.2c0,19.4-15.8,35.2-35.2,35.2c-17.8,0-32.6-13.3-34.9-30.5l5.4,5.3l5.3-5.3
							L14.7,32.7L0,47.4l5.3,5.3l5.8-5.8c2.1,21.6,20.4,38.5,42.5,38.5c23.5,0,42.7-19.2,42.7-42.7S77.1,0,53.6,0L53.6,0z"/>
					</g>
				</svg>
			`
    }, opts));
    this._activityCount = 0;
    const customMarks = (0, _utils.get)(opts, 'range.marks');
    const vp = (0, _layout.viewportSizeClass)();
    this._animation = animation;
    this._timeline = new _TimeSlider.default(animation);
    this._indicator = new _ActivityIndicator.default({
      size: 30,
      strokeWidth: 2
    });
    this._slider = new _RangeSlider.default((0, _utils.extend)({
      title: 'Time Range <span>(hours)</span>',
      width: vp.width === 'compact' ? 200 : 300,
      value: [-6, 0],
      range: {
        min: -24,
        max: 24
      },
      marksEvery: (0, _utils.get)(opts, 'range.marksEvery') || '% 12',
      marks: customMarks || {
        0: 'Now'
      },
      step: vp.width === 'compact' ? 6 : 2,
      tooltip: value => {
        if (value === 0) {
          return 'Now';
        }

        const prefix = value > 0 ? '+' : '';
        return `${prefix}${value} hours`;
      }
    }, this.opts.range));
  }

  close() {
    super.close();

    if (this._tooltip) {
      this._tooltip.hide();
    }
  }
  /**
   * Updates the string format for the time and day displayed in the panel.
   * Values must be a string format supported by the date-fns library: https://date-fns.org/docs/format
   *
   * @param {{ time?: string, day?: string }} value
   * @memberof TimelinePanel
   */


  setFormatters(value) {
    this.opts.formatters = (0, _utils.extend)({}, this.opts.formatters, value);

    if ((0, _utils.isset)(this._time)) {
      this._setTime(this._time);
    }

    this._timeline.setFormatters({
      time: this.opts.formatters.time
    });
  } // public contentSize(): Size {
  // 	const size = {
  // 		width: 0, height: 0
  // 	};
  // 	const $content = this.getContentContainer();
  // 	size.height = $content.outerHeight(true);
  // 	size.width = $content.outerWidth(true);
  // 	$('.awxjs__ui-cols', this.$el).children().forEach((col: any) => {
  // 		const $el = $(col);
  // 		size.width += $el.outerWidth(true);
  // 	});
  // 	return size;
  // }


  setSize(width, height) {
    const insets = this.ui.content.padding();
    const left = this.ui.left.outerWidth(true);
    const center = this.ui.center.outerWidth(true);
    const right = this.ui.right.outerWidth(true);
    let barWidth = width;
    barWidth -= insets.left + insets.right;
    barWidth -= left + center; // subtract bar margins

    const margins = this._timeline.$el.margins();

    barWidth -= margins.left + margins.right;
    barWidth -= 20;
    barWidth = Math.floor(barWidth);

    const ts = this._timeline.size();

    if (ts.width !== barWidth) {
      if (barWidth < 200) {
        this.ui.settings.hide();

        this._timeline.hide();
      } else {
        this.ui.settings.show();

        this._timeline.show();

        this._timeline.setSize(barWidth, 0);
      }
    } // super.setSize(width, height);

  }

  showLoading(loading) {
    const increment = loading ? 1 : -1;
    this._activityCount = Math.max(0, this._activityCount + increment);

    if (this._activityCount > 0) {
      this._indicator.startAnimating();
    } else {
      this._indicator.stopAnimating();
    }
  }

  _render() {
    return `
			<div class="awxjs__app__ui-panel-timeline">
				<div class="awxjs__app__ui-panel-container">
					<div class="awxjs__app__ui-panel-toolbar">
						${this.opts.title ? `<div class="awxjs__app__ui-panel-title">${this.opts.title}</div>` : ''}
						<button class="awxjs__app__ui-panel-close">
							<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
								<path d="m22.699 77.301c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992l21.699-21.602 21.699 21.699c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992c1.6016-1.6016 1.6016-4.1016 0-5.6992l-21.602-21.699 21.699-21.699c1.6016-1.6016 1.6016-4.1016 0-5.6992-1.6016-1.6016-4.1016-1.6016-5.6992 0l-21.699 21.699-21.699-21.602c-1.6016-1.6016-4.1016-1.6016-5.6992 0-1.6016 1.6016-1.6016 4.1016 0 5.6992l21.699 21.602-21.602 21.699c-1.5977 1.5-1.5977 4.1016 0 5.6016z"/>
							</svg>
						</button>
					</div>
					<div class="awxjs__app__ui-panel-content">
						<div class="awxjs__ui-cols align-center">
							<div class="awxjs__app__ui-panel-timeline-left">
								<div class="awxjs__app__ui-panel-timeline-daytime"></div>
							</div>
							<div class="awxjs__app__ui-panel-timeline-center">
								<div class="awxjs__app__ui-panel-timeline-controls awxjs__ui-row align-center">
									<button class="awxjs__ui-btn awxjs__ui-btn-icon awxjs__ui-btn-play">
										<svg width="100pt" height="100pt" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
											<path transform="scale(.3003)" d="m260 166.99l-93.006 54.008-93.994 52.994v-214.99l93.994 53.995zm0 0" fill-rule="evenodd" />
										</svg>
									</button>
									<button class="awxjs__ui-btn awxjs__ui-btn-now">Now</button>
								</div>
							</div>
							<div class="awxjs__app__ui-panel-timeline-right"></div>
						</div>
						<div class="awxjs__ui-btn-icon awxjs__ui-btn-settings">
							<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
								<path d="m94.801 40.801-10.602-1.8008c-0.60156-1.8984-1.3984-3.6992-2.3008-5.5l6.1992-8.6992c0.89844-1.3008 0.80078-3.1016-0.30078-4.1992l-8.5-8.5c-1.1016-1.1016-2.8984-1.3008-4.1992-0.30078l-8.6992 6.1992c-1.6992-0.89844-3.6016-1.6992-5.5-2.3008l-1.6992-10.5c-0.30078-1.6016-1.6016-2.6992-3.1992-2.6992h-12c-1.6016 0-2.8984 1.1016-3.1992 2.6992l-1.8008 10.602c-1.8984 0.60156-3.6992 1.3984-5.5 2.3008l-8.6992-6.1992c-1.3008-0.89844-3.1016-0.80078-4.1992 0.30078l-8.5 8.5c-1.1016 1.1016-1.3008 2.8984-0.30078 4.1992l6.1992 8.6992c-0.89844 1.6992-1.6992 3.6016-2.3008 5.5l-10.5 1.6992c-1.6016 0.30078-2.6992 1.6016-2.6992 3.1992v12c0 1.6016 1.1016 2.8984 2.6992 3.1992l10.602 1.8008c0.60156 1.8984 1.3984 3.6992 2.3008 5.5l-6.1992 8.6992c-0.89844 1.3008-0.80078 3.1016 0.30078 4.1992l8.5 8.5c1.1016 1.1016 2.8984 1.3008 4.1992 0.30078l8.6992-6.1992c1.6992 0.89844 3.6016 1.6992 5.5 2.3008l1.8008 10.602c0.30078 1.6016 1.6016 2.6992 3.1992 2.6992h12c1.6016 0 2.8984-1.1016 3.1992-2.6992l1.6992-10.703c1.8984-0.60156 3.6992-1.3984 5.5-2.3008l8.6992 6.1992c1.3008 0.89844 3.1016 0.80078 4.1992-0.30078l8.5-8.5c1.1016-1.1016 1.3008-2.8984 0.30078-4.1992l-6.1992-8.6992c0.89844-1.6992 1.6992-3.6016 2.3008-5.5l10.602-1.8008c1.6016-0.30078 2.6992-1.6016 2.6992-3.1992v-11.898c-0.10156-1.6016-1.2031-2.8984-2.8008-3.1992zm-44.801 26.301c-9.5 0-17.102-7.6992-17.102-17.102 0-9.5 7.6992-17.102 17.102-17.102 9.3984 0 17.102 7.6016 17.102 17.102s-7.6016 17.102-17.102 17.102z"/>
							</svg>
						</div>
					</div>
					<div class="awxjs__app__ui-panel-toggle">${this.opts.icon}</div>
				</div>
			</div>
		`;
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    this._timeline.addTo(this.ui.timeline);

    this._indicator.appendTo(this.ui.timeline);

    this._setTime(this._animation.currentTime);
  }

  _setupEvents() {
    super._setupEvents();

    this._animation.on('load:start play', () => {
      this.ui.play.html(`
				<svg width="100pt" height="100pt" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
					<path d="m76.5 15h-53c-4.6875 0-8.5 3.8125-8.5 8.5v53c0 4.6875 3.8125 8.5 8.5 8.5h53c4.6875 0 8.5-3.8125 8.5-8.5v-53c0-4.6875-3.8125-8.5-8.5-8.5z"/>
				</svg>
			`);
    }).on('stop', () => {
      this.ui.play.html(`
				<svg width="100pt" height="100pt" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
					<path transform="scale(.3003)" d="m260 166.99l-93.006 54.008-93.994 52.994v-214.99l93.994 53.995zm0 0" fill-rule="evenodd" />
				</svg>
			`);
    }).on('advance', e => {
      const {
        time
      } = e.data;

      if (time) {
        this._setTime(time);
      }
    }).on('start:change end:change', () => {
      this._slider.value = [this._animation.startOffset() / (3600 * 1000), this._animation.endOffset() / (3600 * 1000)];
      this.trigger('change:range', {
        start: this._animation.startDate(),
        end: this._animation.endDate()
      });
    });

    if (this._indicator) {
      this._animation.on('load:start', () => {
        this.showLoading(true);
      }).on('load:done', () => {
        this.showLoading(false);
      });
    }

    this._timeline.slider.on('change', e => {
      const {
        progress
      } = e.data;

      if ((0, _utils.isset)(progress)) {
        const anim = this._animation;
        const delta = anim.endDate().getTime() - anim.startDate().getTime();
        const time = Math.round(anim.startDate().getTime() + delta * progress);

        this._setTime(time);
      }
    });

    this._slider.on('change:end', e => {
      const [min, max] = e.data.value;

      this._animation.setStartOffset(min * 3600 * 1000);

      this._animation.setEndOffset(max * 3600 * 1000);
    });

    this.ui.play.on('click', () => {
      if (this._animation.isAnimating() || this._animation.isLoading()) {
        this._animation.stop();
      } else {
        this._animation.play();
      }
    });
    this.ui.now.on('click', () => {
      this._animation.goToInit();
    });

    if (this.ui.settings) {
      this.ui.settings.on('click', () => {
        if (!this._tooltip) {
          this._slider.initialize(); // const tooltip = new Tooltip(this._range.$el);


          const tooltip = new _Tooltip.default(this._slider.$el, {
            showClose: true
          });
          tooltip.attachTo(this.ui.settings);
          this._tooltip = tooltip;
        }

        if (this._tooltip.visible) {
          this._tooltip.hide();
        } else {
          this._tooltip.show();
        }
      });
    }
  }

  _setTime(time) {
    this._time = time;

    if (!this.ui.time) {
      return;
    }

    const date = new Date(time);
    this.ui.time.html(`
			<div class="awxjs__app__ui-panel-timeline-time">${(0, _utils.formatDate)(date, this.opts.formatters.time)}</div>
			<div class="awxjs__app__ui-panel-timeline-day">${(0, _utils.formatDate)(date, this.opts.formatters.day)}</div>
		`);
  }

}

var _default = TimelinePanel;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 353 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _startOfDay = _interopRequireDefault(__webpack_require__(354));

var _addDays = _interopRequireDefault(__webpack_require__(355));

var _isEqual = _interopRequireDefault(__webpack_require__(356));

var _View = _interopRequireDefault(__webpack_require__(333));

var _Slider = _interopRequireDefault(__webpack_require__(357));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

class TimeSlider extends _View.default {
  constructor(animation, opts) {
    opts = (0, _utils.extend)({
      className: (0, _utils.get)(opts, 'className') ? `ui-timeline ${opts.className}` : 'ui-timeline',
      ui: {
        periods: '.awxjs__ui-timeline__periods'
      },
      formatters: {
        time: 'h:mm',
        date: 'M/d',
        day: 'EEE',
        dateFull: 'EEE MMM d'
      }
    }, opts);
    super(opts);
    this._slider = new _Slider.default(opts.slider);
    this._animation = animation;
  }

  get slider() {
    return this._slider;
  }

  setPosition(value, fireEvents = true) {
    this._slider.setPosition(value, fireEvents);
  }

  setProgress(value, fireEvents = true) {
    this._slider.setProgress(value, fireEvents);
  }
  /**
   * Updates the string format for the time and day strings displayed in the component.
   * Values must be a string format supported by the date-fns library: https://date-fns.org/docs/format
   *
   * @param {{
   * 			time?: string;
   * 			date?: string;
   * 			day?: string;
   * 			dateFull?: string;
   * 		}} value
   * @memberof TimeSlider
   */


  setFormatters(value) {
    this.opts.formatters = (0, _utils.extend)({}, this.opts.formatters, value);

    this._layout();
  }

  _render() {
    return `
			<div class="awxjs__ui-timeline">
				<div class="awxjs__ui-timeline__periods"></div>
			</div>
		`;
  }

  _layout() {
    const from = this._animation.startDate();

    const to = this._animation.endDate();

    this._layoutPeriods(from, to);

    this._setupSliderTicks(from, to);
  }

  _onAddedToDOM() {
    this._slider.addTo(this.$el);

    if (this._animation) {
      this._handleDateRangeChange(this._animation.startDate(), this._animation.endDate());

      this._updateForTime(this._animation.currentTime);
    }
  }

  _setupEvents() {
    const anim = this._animation;
    const slider = this._slider;

    if (anim) {
      anim.on('start:change end:change', e => {
        const {
          from,
          to
        } = e.data;

        if (from && to) {
          this._handleDateRangeChange(from, to); // this._updateForTime(anim.currentTime);

        }
      }).on('advance', e => {
        this._updateForTime(anim.currentTime);
      });
    }

    if (slider) {
      if (!this._sliderChangeHandler) {
        this._sliderChangeHandler = (0, _utils.debounce)(e => {
          const delta = anim.endDate().getTime() - anim.startDate().getTime();
          const time = Math.round(anim.startDate().getTime() + delta * e.data.progress);
          anim.stop();
          anim.goToTime(time);
        }, 250);
      } // update animation position when slider drag occurs


      slider.on('change', e => {
        anim.pause();

        this._sliderChangeHandler(e);
      });
    }
  }

  _updateForTime(time) {
    const anim = this._animation;

    if (anim) {
      // update slider position during animation playback
      const delta = anim.endDate().getTime() - anim.startDate().getTime();
      const progress = anim.currentOffset / delta;
      this.setProgress(progress, false);
    }
  }

  _handleDateRangeChange(from, to) {
    this._layout();

    this._slider.setDateRange(from, to);
  }

  _layoutPeriods(from, to) {
    const range = to.getTime() - from.getTime();
    const $periods = this.ui.periods;
    let maxWidth = $periods.width();
    let x = 0;

    if (this._slider) {
      const size = this._slider.indicatorSize();

      maxWidth -= size.width;
      x = size.width / 2;
    }

    const formatters = this.opts.formatters;
    $periods.empty();

    if (from.getDate() !== to.getDate() || from.getMonth() !== to.getMonth()) {
      let tw = 0;
      let time = (0, _startOfDay.default)(from).getTime(); // get start date ignoring time

      let totalWidth = 0;
      let runningWidth = 0;
      let runningLabel;
      let isDST;
      let index = 0;
      const allowedWidth = 40;
      const fromDate = new Date(from.getFullYear(), from.getMonth(), from.getDate());
      const toDate = new Date(to.getFullYear(), to.getMonth(), to.getDate());
      const dayDelta = Math.round((toDate.getTime() - fromDate.getTime()) / (86400 * 1000));

      while (time < to.getTime()) {
        let date = new Date(time); // check if there's a Daylight Saving Time switch between periods and adjust
        // the current period's time accordingly so we don't get weird period issues

        const tz = date.toString().replace(/^[^\(]+/, '').replace(/[^a-zA-Z]/g, '');

        if (!(0, _utils.isEmpty)(tz)) {
          const dst = /^(\wDT|\w+DaylightTime)/.test(tz);

          if ((0, _utils.isset)(isDST) && dst !== isDST) {
            const timeShift = 3600 * 1000 * (isDST && !dst ? 1 : -1);
            isDST = dst;
            time += timeShift;
            date = new Date(time);
          }

          isDST = dst;
        } // calculate the total width of this period as a percentage of the total time range


        let w = 1;

        if ((0, _isEqual.default)((0, _startOfDay.default)(date), (0, _startOfDay.default)(from))) {
          const d = (0, _startOfDay.default)((0, _addDays.default)(date, 1));
          w = (d.getTime() - from.getTime()) / range;
        } else if ((0, _isEqual.default)((0, _startOfDay.default)(date), (0, _startOfDay.default)(to))) {
          w = 1 - tw;
        } else {
          const d1 = (0, _startOfDay.default)(date);
          const d2 = (0, _addDays.default)(date, 1);
          w = (d2.getTime() - d1.getTime()) / range;
        }

        w = Math.min(1, Math.max(w, 0));
        const dateOrDay = dayDelta >= 10 ? formatters.date : formatters.day;
        const dateFormat = w * maxWidth < 100 ? dateOrDay : formatters.dateFull;
        const itemLabel = (0, _utils.formatDate)(date, dateFormat);
        let itemWidth = Math.round(w * 100 * 100) / 100; // make sure itemWidth percentage never forces totalWidth over 100%
        // itemWidth = Math.min(itemWidth, (100 - totalWidth));

        itemWidth = Math.min(w * maxWidth, maxWidth);
        runningWidth += itemWidth;

        if (index === 0 || index === dayDelta || index > 0 && runningWidth >= allowedWidth) {
          $periods.append(`<div class="awxjs__ui-timeline__periods-item" style="left:${x}px;width:${runningWidth}px;"><span>${runningWidth >= allowedWidth - 10 ? runningLabel || itemLabel : '&nbsp;'}</span></div>`);
          x += runningWidth;
          runningWidth = 0;
          runningLabel = undefined;
        } else if (!(0, _utils.isset)(runningLabel)) {
          runningLabel = itemLabel;
        }

        time += 86400 * 1000;
        tw += w; // x += itemWidth;

        totalWidth += itemWidth;
        index += 1;
      }
    } else {
      const itemLabel = (0, _utils.formatDate)(to, formatters.dateFull);
      $periods.append(`<div class="awxjs__ui-timeline__periods-item" style="left:${x}px;width:${maxWidth}px;"><span>${itemLabel}</span></div>`);
    } // if (this._slider) {
    // 	this._slider.updateRanges(from, to);
    // }

  }

  _setupSliderTicks(from, to) {
    const range = to.getTime() - from.getTime();
    const intervals = {
      second: 1000,
      minute: 60000,
      hour: 3600000,
      day: 86400000
    };
    intervals.minute5 = intervals.minute * 5;
    intervals.minute10 = intervals.minute * 10;
    intervals.minute15 = intervals.minute * 15;
    intervals.minute30 = intervals.minute * 30;
    intervals.hour2 = intervals.hour * 2;
    intervals.hour3 = intervals.hour * 3;
    intervals.hour6 = intervals.hour * 6;
    intervals.hour12 = intervals.hour * 12;
    intervals.day2 = intervals.day * 2;
    intervals.day3 = intervals.day * 3;
    intervals.day7 = intervals.day * 7;
    intervals.month = intervals.day * 30;
    intervals.year = intervals.day * 365;
    intervals.decade = intervals.year * 10;
    let maxWidth = this.ui.periods.width();

    if (this._slider) {
      const size = this._slider.indicatorSize();

      maxWidth -= size.width;
    }

    const timeUnitForRange = timeRange => {
      let result = 0;
      const units = Object.keys(intervals).map(key => intervals[key]);
      units.sort((a, b) => a - b).forEach(interval => {
        const total = timeRange / interval;
        const spacing = maxWidth / total;

        if (spacing >= 40 && result === 0) {
          result = interval;
        }
      });
      return result;
    };

    if (this._slider) {
      const fromTime = from.getTime();
      const toTime = to.getTime();
      const timeDelta = toTime - fromTime; // let tickInterval = 15 * 60 * 1000;

      let tickInterval = timeUnitForRange(timeDelta); // console.log('using interval', tickInterval, 'from', new Date(fromTime));
      // let tickSpacing = maxWidth / (timeDelta / tickInterval);
      // // determine if the configured tick interval will allow proper spacing
      // // if not, then increase the interval until we find a good fit
      // if (tickSpacing < 50) {
      // 	const factor = Math.ceil(50 / tickSpacing);
      // 	tickInterval *= factor;
      // 	tickSpacing = maxWidth / (timeDelta / tickInterval);
      // }
      // get the tick start time by starting at the beginning of the day in the range

      const startTime = new Date(from.getFullYear(), from.getMonth(), from.getDate()).getTime(); // let tickValue = Math.floor(fromTime);

      let tickValue = startTime;
      let isDayInterval = false;

      if (tickValue % tickInterval !== 0) {
        // if tick interval is a day interval, start ticks at the next day
        if (tickInterval % intervals.day === 0) {
          tickValue += intervals.day;
          isDayInterval = true;
        } else {// tickValue += (tickInterval - (tickValue % tickInterval));
        }
      } // force day tick interval if calculated interval is based on days


      if (isDayInterval) {
        tickInterval = intervals.day;
      }

      const ticks = {};

      while (tickValue <= toTime) {
        const delta = (tickValue - fromTime) / range;

        if (tickValue >= fromTime) {
          ticks[delta] = isDayInterval ? '' : (0, _utils.formatDate)(new Date(tickValue), this.opts.formatters.time || 'h:mm');
        }

        tickValue += tickInterval;
      }

      this._slider.setTicks(ticks);
    }
  }

}

var _default = TimeSlider;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 354 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfDay)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);


/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),
/* 355 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ addDays)
/* harmony export */ });
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);



/**
 * @name addDays
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} - the new date with the days added
 * @throws {TypeError} - 2 arguments required
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * const result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */

function addDays(dirtyDate, dirtyAmount) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  var amount = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])(dirtyAmount);

  if (isNaN(amount)) {
    return new Date(NaN);
  }

  if (!amount) {
    // If 0 days, no-op to avoid changing times in the hour before end of DST
    return date;
  }

  date.setDate(date.getDate() + amount);
  return date;
}

/***/ }),
/* 356 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isEqual)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);


/**
 * @name isEqual
 * @category Common Helpers
 * @summary Are the given dates equal?
 *
 * @description
 * Are the given dates equal?
 *
 * @param {Date|Number} dateLeft - the first date to compare
 * @param {Date|Number} dateRight - the second date to compare
 * @returns {Boolean} the dates are equal
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 2 July 2014 06:30:45.000 and 2 July 2014 06:30:45.500 equal?
 * const result = isEqual(
 *   new Date(2014, 6, 2, 6, 30, 45, 0),
 *   new Date(2014, 6, 2, 6, 30, 45, 500)
 * )
 * //=> false
 */

function isEqual(dirtyLeftDate, dirtyRightDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeft = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyLeftDate);
  var dateRight = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}

/***/ }),
/* 357 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Component = _interopRequireDefault(__webpack_require__(332));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;
;
/**
 * A `Slider` is a component....
 */

class Slider extends _Component.default {
  /**
   * Initializes and returns a slider instance configured with the specified options.
   *
   * @param {SliderOptions} [opts]
   * @memberof Slider
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      range: {
        min: 0,
        max: 1
      },
      ticks: true,
      ui: {
        range: '.awxjs__ui-slider-span-inner',
        past: '.awxjs__ui-slider-span-past',
        future: '.awxjs__ui-slider-span-future',
        ticks: '.awxjs__ui-slider-ticks',
        indicator: '.awxjs__ui-slider-indicator'
      }
    }, opts, {
      className: (0, _utils.get)(opts, 'className') ? `ui-slider ${opts.className}` : 'ui-slider'
    });
    super(opts);
    this.setState({
      dragging: false
    });
    this._mouse = {
      x: 0,
      y: 0
    };
  }
  /**
   * A Boolean indicating whether the slider is currently being dragged.
   *
   * @readonly
   * @type {boolean}
   * @memberof Slider
   */


  get dragging() {
    const {
      dragging
    } = this.state;
    return dragging;
  }
  /**
   * Returns the size of the slider position indicator/handle.
   *
   * @returns {Size}
   * @memberof Slider
   */


  indicatorSize() {
    return {
      height: this.ui.indicator.outerHeight(true),
      width: this.ui.indicator.outerWidth(true)
    };
  }
  /**
   * Returns either the value for the current slider position or the value at the specified
   * position value, if provided.
   *
   * @param {number} [position]
   * @returns {number}
   * @memberof Slider
   */


  value(position) {
    if (!(0, _utils.isset)(this._x)) return null;

    if (!(0, _utils.isset)(position) || Number.isNaN(position)) {
      position = this.position();
    }

    return position * ((this.opts.range.max - this.opts.range.min) / (this._x.max - this._x.min));
  }
  /**
   * Updates the slider position based on the specified value.
   *
   * @param {number} value
   * @param {boolean} [fireEvents=true]
   * @memberof Slider
   */


  setValue(value, fireEvents = true) {
    this.setPosition(value / this._increment(), fireEvents);
  }

  position() {
    let x = this.ui.indicator.css('left');

    if ((0, _utils.isEmpty)(x) || !(0, _utils.isset)(x)) {
      x = '0px';
    }

    return Number.parseInt(x.replace(/[^0-9\.-]/g, ''), 10);
  }

  setPosition(pos, fireEvents = true) {
    if (Number.isNaN(pos) === false) {
      pos = Math.max(Math.min(pos, this._x.max), 0);
      this.ui.indicator.css('left', `${pos}px`);

      if (fireEvents) {
        this.trigger('change', {
          value: this.value(),
          position: this.position(),
          progress: this.progress()
        });
      }
    }
  }

  progress() {
    const delta = this._x.max - this._x.min;
    return (this.position() - this._x.min) / delta;
  }

  setProgress(progress, fireEvents = true) {
    const delta = this._x.max - this._x.min;
    const pos = Math.round(this._x.min + delta * progress);

    if (pos !== this.position()) {
      this.setPosition(pos, fireEvents);
    }
  }

  setDateRange(start, end) {
    const now = new Date().getTime();
    const range = end.getTime() - start.getTime();
    let past = 1;
    let future = 0;

    if (end.getTime() > now) {
      if (start.getTime() > now) {
        past = 0;
        future = 1;
      } else {
        past = (now - start.getTime()) / range;
        future = (end.getTime() - now) / range;
      }
    }

    if (past > 0) {
      past = Math.min(100, Math.round(past * 100 * 100) / 100);
      this.ui.past.css({
        width: `${past}%`
      }).show();
    } else {
      this.ui.past.hide();
    }

    if (future > 0) {
      future = Math.min(100, Math.round(future * 100 * 100) / 100);
      this.ui.future.css({
        width: `${future}%`
      }).show();
    } else {
      this.ui.future.hide();
    }
  }

  setTicks(ticks) {
    if (this.opts.ticks === true && this.ui.ticks) {
      const size = this.indicatorSize();
      const x = size.width / 2;
      const w = this.$el.width() - size.width;
      this.ui.ticks.css({
        left: `${x}px`,
        width: `${w}px`
      });
      this.ui.ticks.empty();
      Object.keys(ticks).sort().forEach(pos => {
        const per = parseFloat(pos) * 100;
        this.ui.ticks.append(`
					<div class="awxjs__ui-slider-tick" style="left:${per}%;">
						<div class="awxjs__ui-slider-tick-label">${ticks[pos]}</div>
					</div>
				`);
      });
    }
  }

  _render() {
    return `
			<div class="awxjs__ui-slider">
				<div class="awxjs__ui-slider-span">
					<div class="awxjs__ui-slider-span-inner">
						<div class="awxjs__ui-slider-span-item awxjs__ui-slider-span-past"></div>
						<div class="awxjs__ui-slider-span-item awxjs__ui-slider-span-future"></div>
					</div>
				</div>
				<div class="awxjs__ui-slider-ticks"></div>
				<div class="awxjs__ui-slider-indicator"></div>
			</div>
		`;
  }

  _layout() {
    const progress = (0, _utils.isset)(this._x) ? this.progress() : 0;
    this._x = {
      min: 0,
      max: this.$el.width() - this.ui.indicator.outerWidth(true)
    };
    this.setProgress(progress);

    if (this.ui.range) {
      const size = this.indicatorSize();
      const x = size.width / 2;
      const w = this._x.max - this._x.min;
      this.ui.range.css({
        left: `${x}px`,
        width: `${w}px`
      });
    }
  }

  _setupEvents() {
    const dragHandler = e => {
      this._handleDrag(e);
    };

    const mouseUpHandler = e => {
      (0, _DOM.default)(document).off('mousemove touchmove', dragHandler);
      (0, _DOM.default)(document).off('mouseup touchend', mouseUpHandler);
      this.setState({
        dragging: false
      });
      this.ui.indicator.removeClass('is-dragging');
      this.trigger('slide:stop', {
        mouse: this._mouse
      });
    };

    this.ui.indicator.on('mousedown touchstart', e => {
      e.preventDefault();
      this.setState({
        dragging: true
      });
      this._mouse.x = e.pageX;
      this._mouse.y = e.pageY;
      this.ui.indicator.addClass('is-dragging');
      this.trigger('slide:start', {
        mouse: this._mouse
      }); // add event listeners during drag event

      (0, _DOM.default)(document).on('mousemove touchmove', dragHandler);
      (0, _DOM.default)(document).on('mouseup touchend', mouseUpHandler);
    });
    this.ui.ticks.on('click', e => {
      let x = e.layerX; // if a child node was clicked, calculate x relative to its container

      if (e.target !== this.ui.ticks[0]) {
        const b = this.ui.ticks.bounds();
        x = e.x - b.left;
      }

      const pos = x / this.ui.ticks.width();
      this.setProgress(pos);
    }); // this.parent().on('mouseoff', mouseUpHandler);
  }

  _increment() {
    return (this._x.max - this._x.min) / (this.opts.range.max - this.opts.range.min);
  }

  _handleDrag(e) {
    const {
      dragging
    } = this.state;

    if (dragging) {
      const delta = e.pageX - this._mouse.x;
      let pos = this.position();

      if (delta === 0) {
        return;
      }

      pos += delta;
      this.setPosition(pos, true);
      this._mouse.x = e.pageX;
      this._mouse.y = e.pageY;
    }
  }

}

var _default = Slider;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 358 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Panel = _interopRequireDefault(__webpack_require__(331));

var _LegendView = _interopRequireDefault(__webpack_require__(319));

var _utils = __webpack_require__(359);

var _utils2 = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `LegendPanel` is a panel component that renders and manages a `LegendView` instance.
 *
 * @export
 * @class LegendPanel
 * @extends {Panel<LegendPanelOptions, PanelState>}
 */
class LegendPanel extends _Panel.default {
  /**
   * Initializes and returns a legend panel instance configured with the specified options.
   *
   * @param {LegendPanelOptions} [opts]
   * @memberof LegendPanel
   */
  constructor(opts) {
    opts = (0, _utils2.extend)({
      legend: {
        size: {
          width: 300,
          height: 0
        }
      },
      icon: `
				<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 90 90">
					<g>
						<path d="M45,9c19.9,0,36,16.1,36,36S64.9,81,45,81S9,64.9,9,45C9,25.1,25.1,9,45,9 M45,0C20.1,0,0,20.1,0,45s20.1,45,45,45
							s45-20.1,45-45C90,20.1,69.9,0,45,0z"/>
						<path d="M48.7,29.3c0,1-0.4,1.9-1.1,2.7c-0.7,0.7-1.6,1.1-2.6,1.1c-0.5,0-0.9-0.1-1.4-0.3c-0.4-0.2-0.8-0.5-1.2-0.8
							c-0.3-0.3-0.6-0.7-0.8-1.2c-0.2-0.5-0.3-0.9-0.3-1.5c0-0.5,0.1-0.9,0.3-1.3c0.2-0.4,0.5-0.8,0.8-1.2c0.3-0.3,0.7-0.6,1.2-0.8
							c0.4-0.2,0.9-0.3,1.4-0.3s0.9,0.1,1.4,0.3c0.4,0.2,0.8,0.5,1.2,0.8c0.4,0.3,0.6,0.7,0.8,1.1C48.6,28.3,48.7,28.8,48.7,29.3
							L48.7,29.3z M48.3,59.8c0,1.1-0.3,2-0.9,2.6c-0.6,0.7-1.4,1-2.4,1s-1.8-0.3-2.4-1c-0.6-0.7-0.9-1.5-0.9-2.6v-18
							c0-1.1,0.3-2,0.9-2.6c0.6-0.7,1.4-1,2.4-1s1.8,0.3,2.4,1c0.6,0.7,0.9,1.5,0.9,2.6V59.8z"/>
					</g>
				</svg>
			`
    }, opts);
    opts.className = (0, _utils2.isset)(opts.className) ? `app__ui-panel-legends ${opts.className}` : 'app__ui-panel-legends';
    const size = (0, _utils2.get)(opts, 'legend.size');

    if (size) {
      (0, _utils2.set)(opts, 'legend.size.width', Math.min(size.width, (0, _utils.windowSize)().width));
    }

    super(opts);
  }
  /**
   * The underlying legend view instance.
   *
   * @readonly
   * @type {LegendView}
   * @memberof LegendPanel
   */


  get legend() {
    return this._legendView;
  }

  open() {
    if (this._legendView.count === 0) return;
    super.open();
  }

  contentSize() {
    const size = super.contentSize(); // account for max-height value on container

    const legendSize = this._legendView.getSize();

    const $content = this.getContentContainer();
    size.height = Math.min(legendSize.height, $content.outerHeight(true));
    const pad = $content.padding();
    size.height += pad.top + pad.bottom;
    return size;
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    this.$el.addClass('awxjs__app__ui-panel-legends');

    if (!this._legendView) {
      this._legendView = new _LegendView.default(this.ui.content, (0, _utils2.extend)({
        styles: {
          label: {
            color: '#ffffff'
          }
        }
      }, this.opts.legend));
    }

    if (this._legendView.count === 0) {
      this.hide();
    }
  }

  _setupEvents() {
    super._setupEvents();

    this._legendView.on('add remove', e => {
      const {
        count
      } = e.data;

      if (count === 0) {
        this.close();
        this.hide();
      } else {
        this.show();
      }
    }).on('resize', e => {
      this._layout();
    });
  }

}

var _default = LegendPanel;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 359 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.scrollBarWidth = exports.windowSize = void 0;

const windowSize = () => {
  if (!document || !window) return null;
  const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  return {
    width: w,
    height: h
  };
};

exports.windowSize = windowSize;

const scrollBarWidth = () => {
  const div = document.createElement('div');
  div.style.height = '100px';
  div.style.overflow = 'scroll';
  div.style.position = 'absolute';
  div.style.top = '-9999px';
  div.style.width = '100px';
  document.body.appendChild(div);
  const width = div.offsetWidth - div.clientWidth;
  document.body.removeChild(div);
  return width;
};

exports.scrollBarWidth = scrollBarWidth;

/***/ }),
/* 360 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _Panel = _interopRequireDefault(__webpack_require__(331));

var _SearchField = _interopRequireDefault(__webpack_require__(361));

var _utils = __webpack_require__(17);

var _strings = __webpack_require__(133);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `PlaceSearchPanel` is a panel component that displays and manages a search field component
 * that can be used for searching for and selecting locations.
 *
 * @export
 * @class PlaceSearchPanel
 * @extends {PanelView<PlaceSearchPanelOptions, PanelState>}
 */
class PlaceSearchPanel extends _Panel.default {
  /**
   * Initializes and returns a place search panel instance configured with the specified options.
   *
   * @param {PlaceSearchPanelOptions} [opts]
   * @memberof PlaceSearchPanel
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      field: {
        placeholder: 'Search for place...',
        data: {
          request: query => new Promise((resolve, reject) => {
            this._prepareServiceForQuery(query);

            this._service.get().then(result => {
              let data = result.data || {};

              if (data.responses) {
                let output = [];
                data.responses.forEach(response => {
                  if (response.response) {
                    output = output.concat(response.response);
                  }
                });
                data = output;
              }

              resolve(data);
            }).catch(error => {
              reject(error);
            });
          }),
          formatter: result => {
            if (!result) return null;
            if (!result.place) return null;
            const parts = [(0, _strings.ucwords)(result.place.name)];

            if (result.place.country === 'US') {
              parts.push(result.place.state.toUpperCase());
            } else {
              parts.push((0, _strings.ucwords)(result.place.countryFull));
            }

            let val = parts.join(', ');

            if (result.type && result.type === 'airport') {
              val += ' (Airport)';
            }

            return val;
          }
        }
      },
      icon: `
				<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
					<path d="m69.777 61.273 26.562 26.562c4.25 4.3672-4.1328 12.75-8.5 8.5l-26.562-26.562c-14.641 10.508-35.066 8.9727-47.934-3.8945-14.523-14.523-14.523-38.016
						0-52.539 14.523-14.523 38.016-14.523 52.539 0 12.867 12.867 14.402 33.293 3.8945 47.934zm-48.051-39.551c-9.8008 9.918-9.8008 25.855 0 35.656 9.918 9.918
						25.855 9.918 35.656 0 9.918-9.8008 9.918-25.738 0-35.656-9.8008-9.8008-25.738-9.8008-35.656 0z" fill-rule="evenodd"/>
				</svg>
			`
    }, opts);
    opts.className = opts && opts.className ? `app__ui-panel-search ${opts.className}` : 'app__ui-panel-search';
    super(opts);
    this._account = this.opts.account;
  }
  /**
   * The underlying search field component.
   *
   * @readonly
   * @type {SearchField}
   * @memberof PlaceSearchPanel
   */


  get field() {
    return this._field;
  } // public contentSize(): Size {
  // 	const size = {
  // 		width: 0, height: 0
  // 	};
  // 	const $content = this.getContentContainer();
  // 	size.height = $('.awxjs__ui-searchfield-container', this.$el).outerHeight(true) + $('.awxjs__app__ui-panel-toolbar', this.$el).outerHeight(true);
  // 	size.width = $('input', this._field.$el).outerWidth(true);
  // 	return size;
  // }


  _onAddedToDOM() {
    super._onAddedToDOM();

    if (!this._field) {
      this._field = new _SearchField.default(this.opts.field);
    }

    this._field.addTo(this.ui.content);
  }

  _setupEvents() {
    super._setupEvents();

    this._field.on('select', e => {
      this.trigger('select', e.data);
    }).on("change:value"
    /* CHANGE_VALUE */
    , e => {
      this.trigger('change:value', e.data);
    }).on("update:results"
    /* UPDATE_RESULTS */
    , e => {
      this.trigger('update:results', e.data);
    });
  }

  _prepareServiceForQuery(query) {
    if (!this._service) {
      this._service = this._account.api();
    }

    const service = this._service;
    service.removeAllRequests();
    service.resetParams(); // remove leading and trailing space

    query = query.replace(/^\s+/, '').replace(/\s+$/, ''); // replace spaces after commas

    query = query.replace(/,\s+/, ','); // replace trailing comma

    query = query.replace(/,$/, ''); // don't search, just reset if empty search string

    if (query.length === 0) {
      this._field.setResults([]);

      return;
    }

    if (/^(-?[\d\.]+),\s*(-?[\d\.]+)$/.test(query)) {
      // coordinate
      const request = this._account.api().endpoint('places').action("closest"
      /* CLOSEST */
      ).place(query);

      service.addRequest(request); // this._searchType = 'coord';
    } else if (/^(\d\d\d\d\d(?:-\d\d\d\d)?|[ABCEGHJKLMNPRSTVXY]\d[A-Z] ?\d[A-Z]\d)$/i.test(query)) {
      // zipcode
      // service.place(query);
      const request = this._account.api().endpoint('places').place(query);

      service.addRequest(request); // this._searchType = 'zipcode';
    } else {
      if (/^\w{4}$/.test(query)) {
        // try request for 4-letter airport code
        const request = this._account.api().endpoint('places').place(query);

        service.addRequest(request); // this._searchType = 'icao';
      }

      const parts = query.split(',');

      if (parts.length > 1) {
        query = `name:${parts[0]};altname:${parts[0]}`;

        if (parts.length === 3) {
          query += `,state:${parts[1]},country:${parts[2]}`;
        } else if (parts.length === 2 && parts[1].length > 0) {
          const val = parts[1];
          const altvals = [];
          let isState = false; // if length of val > 2 then check full state and/or country names

          if (val.length > 1) {
            const stateVals = (0, _strings.states)();
            const countryVals = (0, _strings.countries)();
            const allStates = (0, _utils.extend)({}, stateVals.us, stateVals.ca);
            const re = new RegExp(`^${val}`, 'i'); // states

            Object.keys(allStates).forEach(k => {
              if (re.test(allStates[k])) {
                altvals.push(k);
                isState = true;
              }
            }); // countries

            if (!isState) {
              Object.keys(countryVals).forEach(k => {
                if (re.test(countryVals[k])) {
                  altvals.push(k);
                }
              });
            }
          }

          query += `,state:^${val};country:^${val}`;

          if (altvals.length > 0) {
            altvals.forEach(v => {
              query += isState ? `;state:^${v}` : `;country:^${v}`;
            });
          }
        }
      } else {
        query = `name:^${parts[0]};altname:^${parts[0]}`;
      } // this._searchType = 'place';


      const request = this._account.api().endpoint('places').action("search"
      /* SEARCH */
      ).query(query).limit(20).sort('pop:-1,haszip:-1');

      service.addRequest(request);
    }
  }

}

var _default = PlaceSearchPanel;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 361 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _View = _interopRequireDefault(__webpack_require__(333));

var _ActivityIndicator = _interopRequireDefault(__webpack_require__(302));

var _utils = __webpack_require__(17);

var _DOM = _interopRequireDefault(__webpack_require__(141));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `SearchField` is a view component that displays an text input field and is responsible for
 * performing search requests and displaying search results based on the component's configuration.
 *
 * @export
 * @class SearchField
 * @extends {View<SearchFieldOptions>}
 */
class SearchField extends _View.default {
  /**
   * Initializes and returns a search field instance configured with the specified options.
   *
   * @param {*} [opts]
   * @memberof SearchField
   */
  constructor(opts) {
    opts = opts || {};
    opts = (0, _utils.extend)({
      placeholder: 'Search',
      autocomplete: true,
      autoselect: true,
      ui: {
        form: '.awxjs__ui-searchfield-form > form',
        input: '.awxjs__ui-searchfield-form input',
        submit: '.awxjs__ui-searchfield-form button',
        results: '.awxjs__ui-searchfield-results'
      }
    }, opts, {
      className: opts.className ? `ui-searchfield ${opts.className}` : 'ui-searchfield'
    });
    opts.id = opts.id || opts.value;
    super(opts);
    this._selectedIndex = -1;
    this._indicator = new _ActivityIndicator.default({
      size: 30,
      strokeWidth: 2
    });
  }
  /**
   * The underlying text input field value.
   *
   * @type {string}
   * @memberof SearchField
   */


  get value() {
    return this.ui.input.val();
  }

  set value(newValue) {
    this.ui.input.val(newValue);
    this.ui.input.trigger('input');
  }
  /**
   * Updates the displayed search results.
   *
   * @param {any[]} results
   * @memberof SearchField
   */


  setResults(results) {
    this.clear();
    if (!(0, _utils.isArray)(results)) results = [results];
    this._results = (0, _utils.cloneDeep)(results);

    this._renderResults(results);
  }
  /**
   * Resets the field by clearing the input field value and removing all existing results.
   *
   * @memberof SearchField
   */


  reset() {
    this.clear();
    this.ui.input.val('');
    this.ui.results.hide();
    (0, _DOM.default)(document).off('click', this._docHandler);
  }
  /**
   * Clears the existing search results.
   *
   * @memberof SearchField
   */


  clear() {
    this.ui.results.empty();
    this._results = null;
    this._selectedIndex = -1;
    this.$el.removeClass('awxjs__ui-searchfield-expanded');
  }
  /**
   * Focuses the component's input field.
   *
   * @memberof SearchField
   */


  focus() {
    this.ui.input.focus();
  }
  /**
   * Blurs the component's input field.
   *
   * @memberof SearchField
   */


  blur() {
    this.ui.input.blur();
  }

  _render(data) {
    return `
			<div class="awxjs__ui-searchfield">
				<div class="awxjs__ui-searchfield-container">
					<div class="awxjs__ui-searchfield-form">
						<form method="POST">
							<input type="text" value="" placeholder="${this.opts.placeholder}">
							<button>
								<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
									<path d="m69.777 61.273 26.562 26.562c4.25 4.3672-4.1328 12.75-8.5 8.5l-26.562-26.562c-14.641 10.508-35.066 8.9727-47.934-3.8945-14.523-14.523-14.523-38.016 0-52.539 14.523-14.523 38.016-14.523 52.539 0 12.867 12.867 14.402 33.293 3.8945 47.934zm-48.051-39.551c-9.8008 9.918-9.8008 25.855 0 35.656 9.918 9.918 25.855 9.918 35.656 0 9.918-9.8008 9.918-25.738 0-35.656-9.8008-9.8008-25.738-9.8008-35.656 0z" fill-rule="evenodd"/>
								</svg>
							</button>
						</form>
					</div>
					<div class="awxjs__ui-searchfield-results"></div>
				</div>
			</div>
		`;
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    this._indicator.appendTo(this.ui.form);
  }

  _setupEvents() {
    super._setupEvents();

    const field = this.ui.input; // only perform query if user has stopped typing after certain amount of time

    const handleInput = (0, _utils.debounce)(() => {
      const query = field.val();
      this.trigger("change:value"
      /* CHANGE_VALUE */
      , {
        value: query
      });

      if (query.length > 3) {
        this._search(field.val());
      } else if (query.length === 0) {
        this.reset();
      } else {
        this._renderResults([]);
      }
    }, 300);

    this._docHandler = e => {
      this._handleDocClick(e);
    };

    this._keyHandler = e => {
      this._listenForKeys(e);
    };

    if (this.opts.autocomplete) {
      field.on('input', handleInput);
    } else {
      field.on('input', e => {
        if (field.val() === '' || this._results && this._results.length > 0) {
          this.reset();
        }
      });
    }

    this.ui.form.on('submit', e => {
      e.preventDefault();

      this._search(field.val());

      this.trigger("submit"
      /* SUBMIT */
      , {
        value: field.val()
      });
      return false;
    });
    this.ui.submit.on('click', e => {
      e.preventDefault();
      const query = field.val();

      if (!(0, _utils.isEmpty)(query)) {
        this._search(query);

        this.trigger("submit"
        /* SUBMIT */
        , {
          value: query
        });
      }
    });
    field.on('focus', e => {
      this.$el.addClass('awxjs__ui-searchfield-focused'); // remove any existing listeners for the same events before adding to prevent duplicate triggers!

      (0, _DOM.default)(document).off('keyup keypress', this._keyHandler);
      (0, _DOM.default)(document).on('keyup keypress', this._keyHandler);
      (0, _DOM.default)(document).off('click', this._docHandler);
      (0, _DOM.default)(document).on('click', this._docHandler);
    });
    field.on('blur', e => {
      this.$el.removeClass('awxjs__ui-searchfield-focused'); // this.reset();

      (0, _DOM.default)(document).off('keyup keypress', this._keyHandler);
    });
  }

  _search(query) {
    const requestTask = (0, _utils.get)(this.opts, 'data.request');

    if (!requestTask) {
      console.error('No request task defined for SearchField, check your component configuration.');
      return;
    }

    if ((0, _utils.isFunction)(requestTask)) {
      this._indicator.startAnimating();

      requestTask(query).then(results => {
        this._indicator.stopAnimating();

        this.setResults(results);
      });
    }
  }

  _renderResults(results) {
    this.trigger("update:results"
    /* UPDATE_RESULTS */
    , results);

    if (results) {
      if (results.length === 0) {
        this.ui.results.hide();
        this.$el.removeClass('awxjs__ui-searchfield-expanded');
        return;
      }

      const formatter = (0, _utils.get)(this.opts, 'data.formatter');
      const rows = results.map((result, index) => `<li data-result="${index}">${formatter(result)}</li>`);
      this.ui.results.html(`<ul>${rows.join('')}</ul>`);
      this.$el.addClass('awxjs__ui-searchfield-expanded');
      (0, _DOM.default)('li', this.ui.results).on('click', e => {
        this._handleResultClick(e);
      }).on('mouseover', e => {
        this._handleResultMouseover(e);
      });
      this.ui.results.show(); // if configured to auto-select, always select the first result in the payload

      if (rows.length > 0 && this.opts.autoselect) {
        this._selectResultAtIndex(0);
      }
    } else {
      this.reset();
    }
  }

  _handleResultMouseover(e) {
    const $el = (0, _DOM.default)(e.target);
    const index = parseInt($el.data('result'), 10);

    this._selectResultAtIndex(index);
  }

  _handleResultClick(e) {
    const $el = (0, _DOM.default)(e.target);
    const index = parseInt($el.data('result'), 10);
    this.trigger("select"
    /* SELECT */
    , {
      result: (0, _utils.cloneDeep)(this._results[index]),
      index
    });
    this.reset();
  }

  _selectResultAtIndex(index) {
    if (index !== this._selectedIndex) {
      const $li = (0, _DOM.default)('li', this.ui.results);
      $li.removeClass('selected');

      if (index >= 0) {
        $li.eq(index).addClass('selected');
      }

      this._selectedIndex = index;
    }
  }

  _handleDocClick(e) {
    const closest = (0, _DOM.default)(e.target).closest('.awxjs__ui-searchfield-container');

    if (!closest || closest.length === 0) {
      this.reset();
    }
  }

  _listenForKeys(e) {
    const key = (e.key || '').toLowerCase();

    if (e.type === 'keypress') {
      if (key === 'enter' || e.keyCode === 13) {
        e.preventDefault();

        if (this.opts.autocomplete || this._results && this._results.length > 0) {
          this.trigger("key:enter"
          /* KEY_ENTER */
          ); // trigger selection event if user used arrow keys to select value

          if (this._selectedIndex > -1 && this._results) {
            this.trigger("select"
            /* SELECT */
            , {
              result: (0, _utils.cloneDeep)(this._results[this._selectedIndex]),
              index: this._selectedIndex
            });
            this.reset();
          }
        } else {
          this._search(this.ui.input.val());
        }
      }
    } else if (e.type === 'keyup') {
      if (key === 'escape' || key === 'esc' || e.keyCode === 27) {
        this.trigger("key:escape"
        /* KEY_ESCAPE */
        );
        this.reset();
      } else if (e.keyCode === 40) {
        // down key
        let index = this._selectedIndex;

        if (this._results && index < this._results.length - 1) {
          index += 1;
        } else if (index === -1) {
          index = 0;
        }

        this._selectResultAtIndex(index);
      } else if (e.keyCode === 38) {
        // up key
        let index = this._selectedIndex;

        if (index > 0) {
          index -= 1;
        }

        this._selectResultAtIndex(index);
      }
    }
  }

}

var _default = SearchField;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 362 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _InfoPanelView = _interopRequireDefault(__webpack_require__(348));

var _utils = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const formatControlOpts = (opts, overrides) => (0, _utils.extend)({}, opts, overrides);
/**
 * A module manager is responsible for managing a series of modules associated with an application.
 *
 * @class ModuleManager
 */


class ModuleManager extends _EventDispatcher.default {
  /**
   * Initializes a module manager with the specified application.
   *
   * @param {InteractiveMapApp} app
   * @memberof ModuleManager
   */
  constructor(app) {
    super();
    this._moduleLegendCache = {};
    this._app = app;
    this._modules = {};
  }
  /**
   * Adds a module to the application.
   *
   * The specified module must either be an instance of a class that implements the
   * `IMapSourceModule` interface or a loader function that loads and initializes the module
   * on-demand.
   *
   * @param {IMapSourceModule} module
   * @param {*} [overrides=null]
   * @returns
   * @memberof ModuleManager
   */


  add(module, overrides = null, constructorOpts = null) {
    if (!(0, _utils.isset)(module)) {
      console.error(`[Aeris] Invalid module specified, received ${module}`);
      return;
    } // setup a module group if the provided module is an instance of ModuleGroup


    if ((0, _utils.has)(module, 'id') && (0, _utils.has)(module, 'load')) {
      this.addGroup(module, overrides);
      return;
    } // determine if we're loading in a pre-built module from the library, which we then need
    // to load and then create an instance of before adding


    if ((0, _utils.isFunction)(module)) {
      module().then(Module => {
        Module = Module.default || Module;

        if (!(0, _utils.isPlainObject)(Module)) {
          this.add(new Module(constructorOpts), overrides);
        } else {
          console.error('[Aeris] Module is not a valid class.');
        }
      }).catch(e => {
        console.error('[Aeris] Failed to load built-in module', e);
      });
      return;
    }

    if ((0, _utils.isEmpty)(module.id)) {
      throw new Error('[Aeris] Map modules must provide a unique identifier using the `id` property.');
    }

    if ((0, _utils.has)(module, 'initialize') === false) {
      throw new Error(`[Aeris] Cannot add invalid map module ${module.id}. Modules must implement the IMapSourceModule interface and its required methods.`);
    }

    this._modules[module.id] = module;
    module.initialize(this._app.account, this._app); // finish setting up module only once the app is ready

    this._onAppReady(() => {
      const {
        source,
        controls,
        legend,
        infopanel
      } = overrides || {};
      const sourceOpts = (0, _utils.extend)({}, module.source(), (0, _utils.isFunction)(source) ? source() : source);
      const legendOpts = (0, _utils.extend)({}, module.legend(), legend);
      const infoPanelOpts = (0, _utils.extend)({}, module.infopanel(), infopanel);
      const controlOpts = formatControlOpts(module.controls(), controls);

      if (!(0, _utils.isset)(sourceOpts) || (0, _utils.isEmpty)(sourceOpts)) {
        throw new Error(`[Aeris] Cannot add map module ${module.id}, a valid map content source was not provided.`);
      } // setup module controls first before adding its source so that initial state selection
      // on the controls will be set properly


      if (!module.group) {
        this._setupControls(module.id, controlOpts);
      }

      this._setupLegends(module.id, legendOpts);

      this._setupInfoPanel(module.id, infoPanelOpts);

      const dataSource = this._setupSource(module.id, sourceOpts);

      module.dataSource = dataSource;

      this._setupModuleEvents(module);

      this.trigger('module:load', {
        id: module.id,
        module
      });

      const appInitLayers = this._app.initialLayers();

      const layersPanel = this._app.panels.layers;

      if (layersPanel && (appInitLayers === null || appInitLayers === void 0 ? void 0 : appInitLayers.length) > 0) {
        const button = layersPanel.buttonForId(module.id);

        if (button) {
          layersPanel.select(appInitLayers);
        }
      }
    });
  }
  /**
   * Adds a module to the application and inserts its control at the specified index.
   *
   * The specified module must either be an instance of a class that implements the
   * `IMapSourceModule` interface or a loader function that loads and initializes the module
   * on-demand.
   *
   * @param index
   * @param module
   * @param overrides
   */


  insertAt(index, module, overrides = null, constructorOpts = null) {
    this.add(module, (0, _utils.extend)(overrides, {
      controls: {
        index
      }
    }), constructorOpts);
  }
  /**
   * Adds a module group to the application.
   *
   * @param {ModuleGroup} group
   * @param {*} [overrides=null]
   * @memberof ModuleManager
   */


  addGroup(group, overrides = null) {
    overrides = overrides || {};
    group.load().then(modules => {
      // const moduleControls = modules.map((m) => m.controls());
      // const groupControls = group.controls();
      // if (groupControls) {
      // 	groupControls.id = groupControls.id || group.id;
      // 	if (isPlainObject(groupControls)) {
      // 		if (isArray(groupControls.buttons)) {
      // 			groupControls.buttons = groupControls.buttons.concat(moduleControls);
      // 		} else {
      // 			groupControls.buttons = moduleControls;
      // 		}
      // 	} else if (isArray(groupControls)) {
      // 		groupControls.concat(moduleControls);
      // 	}
      // 	this._setupControls(group.id, groupControls);
      // }
      if ((0, _utils.has)(group, 'initialize')) {
        group.initialize(this._app.account, this._app);
      }

      this._onAppReady(() => {
        const controls = group.controls();

        if (controls) {
          const {
            controls: controlOverrides
          } = overrides;
          const controlOpts = formatControlOpts(controls, controlOverrides);

          this._setupControls(group.id, controlOpts);
        }

        this._setupGroupEvents(group);
      });

      const moduleOverrides = overrides.modules || {};
      modules.forEach(m => {
        m.group = group;
        this.add(m, moduleOverrides[m.id]);
      });
    }).catch(error => {
      console.error('[Aeris] Module group failed to load - ERROR', error);
    });
  }
  /**
   * Removes a module from the application.
   *
   * @param {IMapSourceModule} module
   * @memberof ModuleManager
   */


  remove(module) {
    const map = this._app.map;
    const source = map.getSourceForId(module.id);

    if (source) {
      map.removeSource(source);
    }

    delete this._modules[module.id];
    this.trigger('module:unload', {
      id: module.id,
      module
    });
  }

  removeById(identifier) {
    let module;
    Object.keys(this._modules).forEach(id => {
      if (id === identifier) {
        module = this._modules[id];
      }
    });

    if (module) {
      this.remove(module);
    }
  }

  _onAppReady(callback) {
    if (!callback) return;

    if (this._app.isReady()) {
      callback();
    } else {
      this._app.on('ready', () => callback());
    }
  }

  _setupSource(id, opts) {
    if (opts) {
      const {
        type
      } = opts,
            rest = __rest(opts, ["type"]);

      return this._app.addSource(id, type, rest);
    }

    throw new Error(`[Aeris] Cannot add module ${id}, source is invalid.`);
  }

  _setupControls(id, opts) {
    if (!opts) return;
    const layersPanel = this._app.panels.layers;

    if (layersPanel) {
      const index = opts.index;
      const config = (0, _utils.extend)({}, opts, {
        id
      });

      if ((0, _utils.isset)(index)) {
        delete config.index;
        layersPanel.insertAt(index, config);
      } else {
        layersPanel.add(config);
      }
    }
  }

  _setupLegends(id, opts) {
    if (!opts) return;
    const legendsPanel = this._app.panels.legends;

    if (legendsPanel) {
      const map = this._app.map;

      const layersPanel = this._app.getPanel('layers');

      const removeModuleLegend = moduleId => {
        legendsPanel.legend.remove(this._moduleLegendCache[moduleId]);
        delete this._moduleLegendCache[moduleId];
      };

      const addModuleLegend = moduleId => {
        const {
          title,
          url,
          code
        } = (0, _utils.isset)(opts.get) && (0, _utils.isFunction)(opts.get) ? opts.get() : opts;

        if (code === this._moduleLegendCache[moduleId]) {
          return;
        }

        removeModuleLegend(moduleId);

        if ((0, _utils.isset)(code)) {
          legendsPanel.legend.add(code, {
            account: this._app.account,
            within: {
              bounds: this._app.map.getBounds()
            },
            title
          });
          this._moduleLegendCache[id] = code;
        } else if ((0, _utils.isset)(url)) {
          legendsPanel.legend.add(id, {
            type: 'image',
            title,
            url
          });
          this._moduleLegendCache[id] = id;
        }
      };

      map.on('source:add', e => {
        const addedId = (0, _utils.get)(e.data, 'id');

        if (id === addedId) {
          addModuleLegend(id);
        }
      }).on('source:remove', e => {
        const removedId = (0, _utils.get)(e.data, 'id');

        if (id === removedId) {
          removeModuleLegend(id);
        }
      });

      if (layersPanel) {
        layersPanel.on('change', e => {
          const changedId = (0, _utils.get)(e.data, 'id');

          if (id === changedId) {
            addModuleLegend(id);
          }
        });
      }
    }
  }

  _setupInfoPanel(id, opts) {
    if (!opts) return;
    const {
      sections,
      view
    } = opts;
    const infoPanel = this._app.panels.info;

    if (infoPanel) {
      if (sections || view) {
        if (sections) {
          Object.keys(sections).forEach(key => _InfoPanelView.default.setSection(key, sections[key]));
        }

        if (view) {
          infoPanel.setContentView(id, view);
        }
      } else {
        infoPanel.setContentView(id, opts);
      }
    }
  }

  _setupModuleEvents(module) {
    const map = this._app.map;

    if ((0, _utils.has)(module, 'onAdd')) {
      map.on('source:add', e => {
        const id = (0, _utils.get)(e.data, 'id');

        if (id === module.id) {
          module.onAdd();
        }
      });
    }

    if ((0, _utils.has)(module, 'onRemove')) {
      map.on('source:remove', e => {
        const id = (0, _utils.get)(e.data, 'id');

        if (id === module.id) {
          module.onRemove();
        }
      });
    }

    if ((0, _utils.has)(module, 'onMarkerClick')) {
      map.on('marker:click', e => {
        const element = e.data.marker;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (source === module.id) {
          module.onMarkerClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onShapeClick')) {
      map.on('shape:click', e => {
        const element = e.data.shape;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (source === module.id) {
          module.onShapeClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onInit')) {
      module.onInit();
    }
  }

  _setupGroupEvents(module) {
    const map = this._app.map;
    const ids = module.modules.map(m => m.id); // include ids/values from group controls

    const controls = module.controls();

    if (controls && controls.buttons) {
      (controls.buttons || []).forEach(control => {
        const id = control.id || control.value;

        if (ids.indexOf(id) === -1) {
          ids.push(id);
        }
      });
    }

    if ((0, _utils.has)(module, 'onMarkerClick')) {
      map.on('marker:click', e => {
        const element = e.data.marker;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (ids.indexOf(source) >= 0) {
          module.onMarkerClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onShapeClick')) {
      map.on('shape:click', e => {
        const element = e.data.shape;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (ids.indexOf(source) >= 0) {
          module.onShapeClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onInit')) {
      module.onInit();
    }
  }

}

var _default = ModuleManager;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 363 */
/***/ ((module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _EventDispatcher = _interopRequireDefault(__webpack_require__(16));

var _InteractiveMap = __webpack_require__(220);

var _utils = __webpack_require__(17);

var _sources = __webpack_require__(229);

var _utils2 = __webpack_require__(303);

var _utils3 = __webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LayerAction;

(function (LayerAction) {
  LayerAction["Select"] = "select";
  LayerAction["Deselect"] = "deselect";
  LayerAction["Change"] = "change";
})(LayerAction || (LayerAction = {}));

const getRequestParams = value => {
  const params = {};

  if ((0, _utils.isPlainObject)(value)) {
    Object.keys(value).forEach(key => {
      const v = value[key];
      params[key] = (0, _utils.isPlainObject)(v) ? v === null || v === void 0 ? void 0 : v.value : v;
    });
  } else if ((0, _utils.isArray)(value) && value.length > 0) {
    params.filter = value.join(';');
  } else if ((0, _utils.isString)(value)) {
    params.filter = value;
  } // if (value.filters) {
  // 	const filters = value.filters;
  // 	if (isPlainObject(filters)) {
  // 		params = { ...params, ...filters };
  // 	} else {
  // 		params.filter = filters;
  // 	}
  // }


  if (params.filter === 'all') {
    params.filter = '';
  }

  return params;
};

class DataSourceManager extends _EventDispatcher.default {
  constructor(map, panel) {
    super();
    this.storedSources = {};
    this.sourceState = {};
    this.respondToSourceEvents = true;
    this.map = map;
    this.linkPanel(panel);
    this.setupEvents();
  }

  get sources() {
    return this.storedSources;
  }

  linkPanel(panel) {
    if (this.panel === panel) return;

    if (this.panel) {
      this.panel.off('select', this.handleSelect).off('deselect', this.handleDeselect).off('change', this.handleOptionChange);
    }

    this.panel = panel;
    this.panel.on('select', this.handleSelect.bind(this)).on('deselect', this.handleDeselect.bind(this)).on('change', this.handleOptionChange.bind(this)).on('control:change', e => {
      const {
        key,
        valueSegments,
        control = {}
      } = e.data || {};

      if (control.id === 'opacity') {
        let source = this.findSource(key); // if `value` has a `segments` property, then it's a segmented button and we need to get the proper
        // data source for the selected segment instead of the button's id value

        if (valueSegments) {
          valueSegments.forEach(segment => {
            const segmentSource = this.findSource(segment.key, segment.value);

            if (segmentSource) {
              source = segmentSource;
            }
          });
        }

        if (source && (source instanceof _sources.TileSource || source instanceof _sources.VectorSource)) {
          const opacity = control.value / 100;
          source.setOpacity(opacity);
          this.setSourceState(key, {
            style: {
              opacity
            }
          });
        }
      }

      this.trigger("change:control"
      /* CONTROL_CHANGE */
      , e.data);
    });
  }

  getSource(id) {
    return this.sources[id];
  }

  findSource(id, value = undefined) {
    let source = this.getSource(id);

    if (!source) {
      source = this.map.getSourceForId(id);
    }

    if (!source) {
      source = this.map.getSourceForLayer(id);
    }

    if (!source && (0, _utils.isString)(value)) {
      source = this.findSource(value);
    }

    if (!source && /\:\:/.test(id) === true) {
      const code = (0, _utils2.getSourceId)(id || value);
      source = this.findSource(code);
    }

    return source;
  }

  addSource(id, source) {
    this.sources[id] = source;
  }

  setSourceState(id, state) {
    this.sourceState[id] = Object.assign(Object.assign({}, this.sourceState[id]), state);
  }

  handleSourceEvent(event, id) {
    if (!this.respondToSourceEvents) return;

    switch (event) {
      case 'add':
        this.panel.select(id, true);
        break;

      case 'remove':
        this.panel.deselect(id, true);
        break;

      default:
    }
  }

  handleSelect(e) {
    const {
      changed
    } = this.handleAction(LayerAction.Select, e.data);

    if (changed) {
      this.trigger("select"
      /* SELECT */
      , Object.assign({}, e.data));
    }
  }

  handleDeselect(e) {
    const {
      changed
    } = this.handleAction(LayerAction.Deselect, e.data);

    if (changed) {
      this.trigger("deselect"
      /* DESELECT */
      , Object.assign({}, e.data));
    }
  }

  handleOptionChange(e) {
    const {
      id,
      value,
      reload,
      filter = false
    } = e.data || {};
    if (!value) return; // if source hasn't been added to the map yet, trigger the `select` event instead since it needs to be added

    if (this.map.hasSource(id) === false && value.filters) {
      this.panel.trigger('select', e.data);
      return;
    }

    const changed = this.handleAction(LayerAction.Change, Object.assign({}, e.data));

    if (changed) {
      // const payload: Record<string, any> = {
      // 	id,
      // 	current: value,
      // 	previous,
      // 	options,
      // 	segments,
      // 	filters,
      // 	isFilter
      // };
      const params = getRequestParams(value);
      params.bounds = this.map.getBounds(); // if (isPlainObject(filters)) {
      // 	payload.filters = Object.keys(filters).reduce((result: any, key) => {
      // 		result[key] = filters[key].filters;
      // 		return result;
      // 	}, {});
      // }

      this.trigger("change"
      /* CHANGE */
      , Object.assign(Object.assign({}, e.data), {
        params
      })); // if triggered change is a filter, then reload datasource with selected filters if needed

      if (filter) {
        const source = this.findSource(id, value);

        if (source) {
          // params.filter = isArray(value) ? value.join(';') : value;
          if (!(0, _utils.isset)(reload) || reload === true) {
            source.reload(params);
          } else {
            source.render();
          }
        }
      }
    }
  } // private handleFilterChange(payload: any = {}) {
  // 	const { value, source, reload, filters } = payload || { reload: true };
  // 	const params = getRequestParams(value);
  // 	params.bounds = this.map.getBounds();
  // 	if (isPlainObject(filters)) {
  // 		payload.filters = Object.keys(filters).reduce((result: any, key) => {
  // 			result[key] = filters[key].filters;
  // 			return result;
  // 		}, {});
  // 	}
  // 	// pass in params object to event data payload so event handlers can
  // 	// override request parameters as needed
  // 	this.trigger(DataSourceManagerEvent.OPTION_CHANGE, {
  // 		...payload,
  // 		params
  // 	});
  // 	if (source) {
  // 		if (!isset(reload) || reload === true) {
  // 			source.reload(params);
  // 		} else {
  // 			source.render();
  // 		}
  // 	}
  // };


  handleAction(action, info) {
    const {
      id,
      key,
      value,
      previous,
      options,
      valueSegments,
      previousSegments,
      filter = false
    } = info;
    const saveKeys = ['id', 'key', 'value', 'options'];

    if (!value) {
      return {
        changed: false,
        added: [],
        removed: []
      };
    }

    if (this.map.isReady()) {
      let added = [];
      let removed = [];

      if (filter || value.filters) {
        if (action === LayerAction.Deselect) {
          removed.push((0, _utils.pick)(info, saveKeys));
        } else {
          added.push((0, _utils.pick)(info, saveKeys));
        } // const source = this.findSource(id, value);
        // this.handleFilterChange({
        // 	id,
        // 	value,
        // 	filters: value.filters,
        // 	options: value.options,
        // 	segments: value.segments,
        // 	source,
        // 	reload: isset(reload) ? reload : true
        // });


        if (action === LayerAction.Change) {
          return {
            changed: true,
            added,
            removed
          };
        } // } else if (value.segments) {
        // 	if (action === LayerAction.Deselect) {
        // 		removed = removed.concat(value.segments.filter((item: any) => isset(item)));
        // 	} else {
        // 		added = added.concat(value.segments.filter((item: any) => isset(item)));
        // 		if (previous && previous.segments) {
        // 			removed = removed.concat(previous.segments.filter((item: any) => isset(item)));
        // 		}
        // 	}

      } else if (action === LayerAction.Select) {
        if (valueSegments) {
          added = added.concat(valueSegments.map(item => (0, _utils.pick)(item, saveKeys)));
        } else {
          added.push((0, _utils.pick)(info, saveKeys));
        }
      } else if (action === LayerAction.Deselect) {
        if (valueSegments) {
          removed = removed.concat(valueSegments.map(item => (0, _utils.pick)(item, saveKeys)));
        } else {
          removed.push((0, _utils.pick)(info, saveKeys));
        }
      }

      if (action === LayerAction.Change) {
        if (valueSegments || previousSegments) {
          if (valueSegments) {
            added = added.concat(valueSegments.map(item => (0, _utils.pick)(item, saveKeys)));
          }

          if (previousSegments) {
            removed = removed.concat(previousSegments.map(item => (0, _utils.pick)(item, saveKeys)));
          }
        } else {
          removed.push(Object.assign(Object.assign({}, (0, _utils.pick)(info, saveKeys)), {
            value: previous
          }));
          added.push((0, _utils.pick)(info, saveKeys));
        }
      }

      if (action === LayerAction.Select) {
        removed = [];
      } else if (action === LayerAction.Deselect) {
        added = [];
      }

      const addedValues = added.map(item => item.key);
      const removedFiltered = removed.reduce((result, item) => {
        if (addedValues.indexOf(item.key) === -1) {
          result.push(item);
        }

        return result;
      }, []); // console.log('DATASOURCE', action, 'added', added, 'removed', removed, 'filtered', removedFiltered);

      if (added.length > 0 || removedFiltered.length > 0) {
        const sourcesToAdd = added.map(item => Object.assign(Object.assign({}, item), {
          parentId: id
        }));
        const sourcesToRemove = removedFiltered.map(item => Object.assign(Object.assign({}, item), {
          parentId: id
        }));
        this.updateSources(sourcesToAdd, sourcesToRemove);
        return {
          changed: true,
          added,
          removed: removedFiltered
        };
      }
    }

    return {
      changed: false,
      added: [],
      removed: []
    };
  }

  updateSources(sourcesToAdd = [], sourcesToRemove = []) {
    const added = [];
    const removed = []; // we need to disable responding to source events in `handleSourceEvent` so that add/remove events don't get captured by
    // the button panel which would then cause issues with the add/remove source changes we're performing here

    this.respondToSourceEvents = false; // console.log(sourcesToAdd, sourcesToRemove);

    sourcesToRemove.forEach(item => {
      const {
        id,
        key,
        value,
        options
      } = item;
      const source = this.findSource(id, value);

      if (source) {
        this.map.removeSource(source);
        removed.push(source);
      }
    });
    sourcesToAdd.forEach(item => {
      const {
        id,
        key,
        parentId,
        value,
        options
      } = item;
      const sourceOptions = (0, _utils.extend)({}, options, this.sourceState[id], this.sourceState[parentId]);
      const valueStr = (0, _utils.isArray)(value) ? value.join(',') : value;
      let source = this.findSource(id, valueStr); // skip MapsGL layers

      if (!(0, _utils3.isMapsGLLayer)(id) && !(0, _utils3.isMapsGLLayer)(valueStr) && (options === null || options === void 0 ? void 0 : options.mapsgl) !== true) {
        if (source) {
          this.map.addSource(source, sourceOptions);
        } else if ((0, _utils.isString)(valueStr) && (this.map.layerInfo.exists(valueStr) || sourceOptions.validate === false)) {
          this.map.addLayer(valueStr, Object.assign(Object.assign({}, sourceOptions), {
            id
          }));
          source = this.map.getSourceForLayer(id || valueStr);
        } else if (this.map.layerInfo.exists(id)) {
          // try adding source as an Aeris Maps layer instead
          this.map.addLayer(id, Object.assign(Object.assign({}, sourceOptions), {
            id
          }));
          source = this.map.getSourceForLayer(id);
        }

        if (source) {
          added.push(source);
        } else if (!(0, _InteractiveMap.isModule)(value)) {
          console.warn(`[Aeris] Cannot add map data source {${id}}, source not registered and/or not a valid Aeris Maps layer.`);
        }
      }
    }); // re-enable source events now that we've updated our data sources

    this.respondToSourceEvents = true;
    this.trigger("source:change"
    /* SOURCE_CHANGE */
    , {
      added,
      removed
    });
  }

  setupEvents() {
    this.on("source:change"
    /* SOURCE_CHANGE */
    , e => {// console.log('SOURCE CHANGE', e.data);
    });
  }

}

var _default = DataSourceManager;
exports["default"] = _default;
module.exports = exports.default;

/***/ }),
/* 364 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getMapAppDefaults = void 0;

/* eslint-disable import/prefer-default-export */
const getMapAppDefaults = vp => ({
  mode: 'light',
  map: {},
  panels: {
    layers: {
      title: 'Layers',
      enabled: true,
      toggleable: vp.width === 'compact',
      className: 'app__ui-panel-layers',
      position: {
        pin: 'topright',
        translate: {
          x: -10,
          y: 10
        }
      }
    },
    timeline: {
      title: 'Timeline',
      enabled: true,
      position: {
        pin: vp.width === 'compact' ? 'bottomleft' : 'bottom',
        translate: {
          x: vp.width === 'compact' ? 10 : 0,
          y: -10
        }
      }
    },
    info: {
      enabled: true,
      position: {
        pin: 'topleft',
        translate: {
          x: 10,
          y: 10
        }
      },
      marker: {
        svg: {
          shape: {
            type: 'circle',
            fill: {
              color: '#15a8e1'
            },
            stroke: {
              color: '#ffffff',
              width: 2
            }
          }
        },
        size: [20, 20]
      }
    },
    legends: {
      title: 'Legends',
      enabled: true,
      toggleable: true,
      position: {
        pin: 'bottomright',
        translate: {
          x: -10,
          y: -10
        }
      }
    },
    search: {
      title: 'Location Search',
      enabled: true,
      position: {
        pin: 'top',
        translate: {
          y: 10
        }
      }
    }
  }
});

exports.getMapAppDefaults = getMapAppDefaults;

/***/ }),
/* 365 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _aerisweather_javascript_sdk_dist_network_maps_MapRequest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _aerisweather_javascript_sdk_dist_network_maps_MapRequest__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_aerisweather_javascript_sdk_dist_network_maps_MapRequest__WEBPACK_IMPORTED_MODULE_0__);

window.addEventListener('load', () => {
    let staticmap = document.querySelector('[staticmap]');

    let maplayers = 'flat,radar,admin';
    let mapcenter = 'minneapolis,mn';
    let mapw = 600;
    let maph = 600;
    let mapz = 5;
    let maptile = 256;
    let mapcols = Math.ceil(mapw / maptile);
    let maprows = Math.ceil(maph / maptile);

    let mapunits = mapcols * maprows;

    console.log(mapunits);

    const request = new (_aerisweather_javascript_sdk_dist_network_maps_MapRequest__WEBPACK_IMPORTED_MODULE_0___default())({
        client: {
            id: 'ZsXEQGZcQQ297GNvUPbEw',
            secret: 'qg4V7TY719k33od8qlRPwVFGKgKwawJVZmZPFHDI'
        }
    });

    request.layers(maplayers);
    request.center(mapcenter);
    request.zoom(mapz);
    request.size(mapw, maph);
    request.get().then((result) => {
        console.log(result.image);
        staticmap.insertAdjacentElement('afterbegin', result.image);
        const estunits = (
            `<h4 class="staticmap__estunits">Estimated Map Units: <span>${mapunits}</span></h4>`
        );
        staticmap.insertAdjacentHTML('afterbegin', estunits);
    });

});

/***/ }),
/* 366 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _aerisweather_javascript_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);

window.addEventListener('load', () => {
    let interactivemap = document.querySelector('[interactivemap]');

    let maplayers = 'alerts,temperatures,radar';
    let mapcenter = {
        lat: 39.099728,
        lon: -94.578568
    }
    let mapw = 600;
    let maph = 600;
    let mapz = 4;
    let maptile = 256;
    let mapcols = Math.ceil(mapw / maptile);
    let maprows = Math.ceil(maph / maptile);

    let mapunits = mapcols * maprows;

    const aeris = new _aerisweather_javascript_sdk__WEBPACK_IMPORTED_MODULE_0__["default"]('ZsXEQGZcQQ297GNvUPbEw', 'qg4V7TY719k33od8qlRPwVFGKgKwawJVZmZPFHDI');

    aeris.views().then((views) => {
        const map = new views.Map(interactivemap, {
            map: {
                strategy: 'leaflet',
                layers: {
                    data: maplayers
                },
                center: mapcenter,
                zoom: mapz,
                size: {
                    width: mapw,
                    height: maph
                },
                timeline: {
                    from: -2 * 3600,
                    to: 0
                }
            }
        });
    });

    const estunits = (
        `<h4 class="staticmap__estunits">Estimated Map Units: <span>${mapunits}</span></h4>`
    );

    document.querySelector('.interactivemap__wrapper').insertAdjacentHTML('afterbegin', estunits);

});

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _js_currentconditions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _js_staticmap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(365);
/* harmony import */ var _js_interactivemap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(366);




})();

/******/ })()
;